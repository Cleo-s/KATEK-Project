import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS
} from "./chunk-6NOISVLF.js";

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS({
  "node_modules/abstract-logging/index.js"(exports, module) {
    "use strict";
    function noop() {
    }
    var proto = {
      fatal: noop,
      error: noop,
      warn: noop,
      info: noop,
      debug: noop,
      trace: noop
    };
    Object.defineProperty(module, "exports", {
      get() {
        return Object.create(proto);
      }
    });
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/logger.js
var require_logger = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/logger.js"(exports, module) {
    "use strict";
    var logger = require_abstract_logging();
    logger.child = function() {
      return logger;
    };
    module.exports = logger;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/enqueue.js
var require_enqueue = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/enqueue.js"(exports, module) {
    "use strict";
    module.exports = function enqueue(message, expect, emitter, cb) {
      if (this._queue.length >= this.size || this._frozen) {
        return false;
      }
      this._queue.add({ message, expect, emitter, cb });
      if (this.timeout === 0)
        return true;
      if (this._timer === null)
        return true;
      this._timer = setTimeout(queueTimeout.bind(this), this.timeout);
      return true;
      function queueTimeout() {
        this.freeze();
        this.purge();
      }
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/flush.js
var require_flush = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/flush.js"(exports, module) {
    "use strict";
    module.exports = function flush(cb) {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      const requests = Array.from(this._queue.values());
      this._queue.clear();
      for (const req of requests) {
        cb(req.message, req.expect, req.emitter, req.cb);
      }
    };
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/assert-plus/assert.js
var require_assert2 = __commonJS({
  "node_modules/assert-plus/assert.js"(exports, module) {
    var assert = require_assert();
    var Stream = require_stream().Stream;
    var util = require_util();
    var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
    function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    function _toss(name, expected, oper, arg, actual) {
      throw new assert.AssertionError({
        message: util.format("%s (%s) is required", name, expected),
        actual: actual === void 0 ? typeof arg : actual(arg),
        expected,
        operator: oper || "===",
        stackStartFunction: _toss.caller
      });
    }
    function _getClass(arg) {
      return Object.prototype.toString.call(arg).slice(8, -1);
    }
    function noop() {
    }
    var types = {
      bool: {
        check: function(arg) {
          return typeof arg === "boolean";
        }
      },
      func: {
        check: function(arg) {
          return typeof arg === "function";
        }
      },
      string: {
        check: function(arg) {
          return typeof arg === "string";
        }
      },
      object: {
        check: function(arg) {
          return typeof arg === "object" && arg !== null;
        }
      },
      number: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg);
        }
      },
      finite: {
        check: function(arg) {
          return typeof arg === "number" && !isNaN(arg) && isFinite(arg);
        }
      },
      buffer: {
        check: function(arg) {
          return Buffer.isBuffer(arg);
        },
        operator: "Buffer.isBuffer"
      },
      array: {
        check: function(arg) {
          return Array.isArray(arg);
        },
        operator: "Array.isArray"
      },
      stream: {
        check: function(arg) {
          return arg instanceof Stream;
        },
        operator: "instanceof",
        actual: _getClass
      },
      date: {
        check: function(arg) {
          return arg instanceof Date;
        },
        operator: "instanceof",
        actual: _getClass
      },
      regexp: {
        check: function(arg) {
          return arg instanceof RegExp;
        },
        operator: "instanceof",
        actual: _getClass
      },
      uuid: {
        check: function(arg) {
          return typeof arg === "string" && UUID_REGEXP.test(arg);
        },
        operator: "isUUID"
      }
    };
    function _setExports(ndebug) {
      var keys = Object.keys(types);
      var out;
      if (process.env.NODE_NDEBUG) {
        out = noop;
      } else {
        out = function(arg, msg) {
          if (!arg) {
            _toss(msg, "true", arg);
          }
        };
      }
      keys.forEach(function(k) {
        if (ndebug) {
          out[k] = noop;
          return;
        }
        var type = types[k];
        out[k] = function(arg, msg) {
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optional" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!type.check(arg)) {
            _toss(msg, k, type.operator, arg, type.actual);
          }
        };
      });
      keys.forEach(function(k) {
        var name = "arrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      keys.forEach(function(k) {
        var name = "optionalArrayOf" + _capitalize(k);
        if (ndebug) {
          out[name] = noop;
          return;
        }
        var type = types[k];
        var expected = "[" + k + "]";
        out[name] = function(arg, msg) {
          if (arg === void 0 || arg === null) {
            return;
          }
          if (!Array.isArray(arg)) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
          var i;
          for (i = 0; i < arg.length; i++) {
            if (!type.check(arg[i])) {
              _toss(msg, expected, type.operator, arg, type.actual);
            }
          }
        };
      });
      Object.keys(assert).forEach(function(k) {
        if (k === "AssertionError") {
          out[k] = assert[k];
          return;
        }
        if (ndebug) {
          out[k] = noop;
          return;
        }
        out[k] = assert[k];
      });
      out._setExports = _setExports;
      return out;
    }
    module.exports = _setExports(process.env.NODE_NDEBUG);
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module) {
    module.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module) {
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module) {
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq2 = this.peek();
      if (seq2 === null)
        return null;
      if (tag !== void 0 && tag !== seq2)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq2.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq2;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values = [];
      var value = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value <<= 7;
        value += byte & 127;
        if ((byte & 128) === 0) {
          values.push(value);
          value = 0;
        }
      }
      value = values.shift();
      values.unshift(value % 40);
      values.unshift(value / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value = 0;
      for (var i = 0; i < this.length; i++) {
        value <<= 8;
        value |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value -= 1 << i * 8;
      return value >> 0;
    };
    module.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module) {
    var assert = require_assert();
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key])
          return;
        var value = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value);
      });
      return to;
    }
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self = this;
      strings.forEach(function(s) {
        self.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq2 = this._seq.pop();
      var start = seq2 + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq2] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq2] = 129;
        this._buf[seq2 + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq2] = 130;
        this._buf[seq2 + 1] = len >> 8;
        this._buf[seq2 + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq2] = 131;
        this._buf[seq2 + 1] = len >> 16;
        this._buf[seq2 + 2] = len >> 8;
        this._buf[seq2 + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module) {
    var errors = require_errors();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module) {
    var Ber = require_ber();
    module.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/control.js
var require_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/control.js"(exports, module) {
    var assert = require_assert2();
    function Control(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalString(options.type);
      assert.optionalBool(options.criticality);
      if (options.value) {
        assert.buffer(options.value);
      }
      this.type = options.type || "";
      this.criticality = options.critical || options.criticality || false;
      this.value = options.value || null;
    }
    Object.defineProperties(Control.prototype, {
      json: {
        get: function getJson() {
          const obj = {
            controlType: this.type,
            criticality: this.criticality,
            controlValue: this.value
          };
          return typeof this._json === "function" ? this._json(obj) : obj;
        }
      }
    });
    Control.prototype.toBer = function toBer(ber) {
      assert.ok(ber);
      ber.startSequence();
      ber.writeString(this.type || "");
      ber.writeBoolean(this.criticality);
      if (typeof this._toBer === "function") {
        this._toBer(ber);
      } else {
        if (this.value) {
          ber.writeString(this.value);
        }
      }
      ber.endSequence();
    };
    Control.prototype.toString = function toString() {
      return this.json;
    };
    module.exports = Control;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/entry_change_notification_control.js
var require_entry_change_notification_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/entry_change_notification_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    function EntryChangeNotificationControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = EntryChangeNotificationControl.OID;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(EntryChangeNotificationControl, Control);
    Object.defineProperties(EntryChangeNotificationControl.prototype, {
      value: {
        get: function() {
          return this._value || {};
        },
        configurable: false
      }
    });
    EntryChangeNotificationControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence()) {
        this._value = {
          changeType: ber.readInt()
        };
        if (this._value.changeType === 8) {
          this._value.previousDN = ber.readString();
        }
        this._value.changeNumber = ber.readInt();
        return true;
      }
      return false;
    };
    EntryChangeNotificationControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence();
      writer.writeInt(this.value.changeType);
      if (this.value.previousDN) {
        writer.writeString(this.value.previousDN);
      }
      writer.writeInt(parseInt(this.value.changeNumber, 10));
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    EntryChangeNotificationControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    EntryChangeNotificationControl.OID = "2.16.840.1.113730.3.4.7";
    module.exports = EntryChangeNotificationControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/persistent_search_control.js
var require_persistent_search_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/persistent_search_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    function PersistentSearchControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = PersistentSearchControl.OID;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(PersistentSearchControl, Control);
    Object.defineProperties(PersistentSearchControl.prototype, {
      value: {
        get: function() {
          return this._value || {};
        },
        configurable: false
      }
    });
    PersistentSearchControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence()) {
        this._value = {
          changeTypes: ber.readInt(),
          changesOnly: ber.readBoolean(),
          returnECs: ber.readBoolean()
        };
        return true;
      }
      return false;
    };
    PersistentSearchControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence();
      writer.writeInt(this.value.changeTypes);
      writer.writeBoolean(this.value.changesOnly);
      writer.writeBoolean(this.value.returnECs);
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    PersistentSearchControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    PersistentSearchControl.OID = "2.16.840.1.113730.3.4.3";
    module.exports = PersistentSearchControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/paged_results_control.js
var require_paged_results_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/paged_results_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    function PagedResultsControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = PagedResultsControl.OID;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(PagedResultsControl, Control);
    Object.defineProperties(PagedResultsControl.prototype, {
      value: {
        get: function() {
          return this._value || {};
        },
        configurable: false
      }
    });
    PagedResultsControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence()) {
        this._value = {};
        this._value.size = ber.readInt();
        this._value.cookie = ber.readString(asn1.Ber.OctetString, true);
        if (!this._value.cookie) {
          this._value.cookie = Buffer.alloc(0);
        }
        return true;
      }
      return false;
    };
    PagedResultsControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence();
      writer.writeInt(this.value.size);
      if (this.value.cookie && this.value.cookie.length > 0) {
        writer.writeBuffer(this.value.cookie, asn1.Ber.OctetString);
      } else {
        writer.writeString("");
      }
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    PagedResultsControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    PagedResultsControl.OID = "1.2.840.113556.1.4.319";
    module.exports = PagedResultsControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/server_side_sorting_request_control.js
var require_server_side_sorting_request_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/server_side_sorting_request_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    function ServerSideSortingRequestControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = ServerSideSortingRequestControl.OID;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (Array.isArray(options.value)) {
          assert.arrayOfObject(options.value, "options.value must be Objects");
          for (let i = 0; i < options.value.length; i++) {
            if (Object.prototype.hasOwnProperty.call(options.value[i], "attributeType") === false) {
              throw new Error("Missing required key: attributeType");
            }
          }
          this._value = options.value;
        } else if (typeof options.value === "object") {
          if (Object.prototype.hasOwnProperty.call(options.value, "attributeType") === false) {
            throw new Error("Missing required key: attributeType");
          }
          this._value = [options.value];
        } else {
          throw new TypeError("options.value must be a Buffer, Array or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(ServerSideSortingRequestControl, Control);
    Object.defineProperties(ServerSideSortingRequestControl.prototype, {
      value: {
        get: function() {
          return this._value || [];
        },
        configurable: false
      }
    });
    ServerSideSortingRequestControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      let item;
      if (ber.readSequence(48)) {
        this._value = [];
        while (ber.readSequence(48)) {
          item = {};
          item.attributeType = ber.readString(asn1.Ber.OctetString);
          if (ber.peek() === 128) {
            item.orderingRule = ber.readString(128);
          }
          if (ber.peek() === 129) {
            item.reverseOrder = ber._readTag(129) !== 0;
          }
          this._value.push(item);
        }
        return true;
      }
      return false;
    };
    ServerSideSortingRequestControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value || this.value.length === 0) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence(48);
      for (let i = 0; i < this.value.length; i++) {
        const item = this.value[i];
        writer.startSequence(48);
        if (item.attributeType) {
          writer.writeString(item.attributeType, asn1.Ber.OctetString);
        }
        if (item.orderingRule) {
          writer.writeString(item.orderingRule, 128);
        }
        if (item.reverseOrder) {
          writer.writeBoolean(item.reverseOrder, 129);
        }
        writer.endSequence();
      }
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    ServerSideSortingRequestControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    ServerSideSortingRequestControl.OID = "1.2.840.113556.1.4.473";
    module.exports = ServerSideSortingRequestControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/errors/codes.js
var require_codes = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/errors/codes.js"(exports, module) {
    "use strict";
    module.exports = {
      LDAP_SUCCESS: 0,
      LDAP_OPERATIONS_ERROR: 1,
      LDAP_PROTOCOL_ERROR: 2,
      LDAP_TIME_LIMIT_EXCEEDED: 3,
      LDAP_SIZE_LIMIT_EXCEEDED: 4,
      LDAP_COMPARE_FALSE: 5,
      LDAP_COMPARE_TRUE: 6,
      LDAP_AUTH_METHOD_NOT_SUPPORTED: 7,
      LDAP_STRONG_AUTH_REQUIRED: 8,
      LDAP_REFERRAL: 10,
      LDAP_ADMIN_LIMIT_EXCEEDED: 11,
      LDAP_UNAVAILABLE_CRITICAL_EXTENSION: 12,
      LDAP_CONFIDENTIALITY_REQUIRED: 13,
      LDAP_SASL_BIND_IN_PROGRESS: 14,
      LDAP_NO_SUCH_ATTRIBUTE: 16,
      LDAP_UNDEFINED_ATTRIBUTE_TYPE: 17,
      LDAP_INAPPROPRIATE_MATCHING: 18,
      LDAP_CONSTRAINT_VIOLATION: 19,
      LDAP_ATTRIBUTE_OR_VALUE_EXISTS: 20,
      LDAP_INVALID_ATTRIBUTE_SYNTAX: 21,
      LDAP_NO_SUCH_OBJECT: 32,
      LDAP_ALIAS_PROBLEM: 33,
      LDAP_INVALID_DN_SYNTAX: 34,
      LDAP_ALIAS_DEREF_PROBLEM: 36,
      LDAP_INAPPROPRIATE_AUTHENTICATION: 48,
      LDAP_INVALID_CREDENTIALS: 49,
      LDAP_INSUFFICIENT_ACCESS_RIGHTS: 50,
      LDAP_BUSY: 51,
      LDAP_UNAVAILABLE: 52,
      LDAP_UNWILLING_TO_PERFORM: 53,
      LDAP_LOOP_DETECT: 54,
      LDAP_SORT_CONTROL_MISSING: 60,
      LDAP_INDEX_RANGE_ERROR: 61,
      LDAP_NAMING_VIOLATION: 64,
      LDAP_OBJECTCLASS_VIOLATION: 65,
      LDAP_NOT_ALLOWED_ON_NON_LEAF: 66,
      LDAP_NOT_ALLOWED_ON_RDN: 67,
      LDAP_ENTRY_ALREADY_EXISTS: 68,
      LDAP_OBJECTCLASS_MODS_PROHIBITED: 69,
      LDAP_AFFECTS_MULTIPLE_DSAS: 71,
      LDAP_CONTROL_ERROR: 76,
      LDAP_OTHER: 80,
      LDAP_PROXIED_AUTHORIZATION_DENIED: 123
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/server_side_sorting_response_control.js
var require_server_side_sorting_response_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/server_side_sorting_response_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var CODES = require_codes();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    var VALID_CODES = [
      CODES.LDAP_SUCCESS,
      CODES.LDAP_OPERATIONS_ERROR,
      CODES.LDAP_TIME_LIMIT_EXCEEDED,
      CODES.LDAP_STRONG_AUTH_REQUIRED,
      CODES.LDAP_ADMIN_LIMIT_EXCEEDED,
      CODES.LDAP_NO_SUCH_ATTRIBUTE,
      CODES.LDAP_INAPPROPRIATE_MATCHING,
      CODES.LDAP_INSUFFICIENT_ACCESS_RIGHTS,
      CODES.LDAP_BUSY,
      CODES.LDAP_UNWILLING_TO_PERFORM,
      CODES.LDAP_OTHER
    ];
    function ServerSideSortingResponseControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = ServerSideSortingResponseControl.OID;
      options.criticality = false;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          if (VALID_CODES.indexOf(options.value.result) === -1) {
            throw new Error("Invalid result code");
          }
          if (options.value.failedAttribute && typeof options.value.failedAttribute !== "string") {
            throw new Error("failedAttribute must be String");
          }
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(ServerSideSortingResponseControl, Control);
    Object.defineProperties(ServerSideSortingResponseControl.prototype, {
      value: {
        get: function() {
          return this._value || {};
        },
        configurable: false
      }
    });
    ServerSideSortingResponseControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence(48)) {
        this._value = {};
        this._value.result = ber.readEnumeration();
        if (ber.peek() === 128) {
          this._value.failedAttribute = ber.readString(128);
        }
        return true;
      }
      return false;
    };
    ServerSideSortingResponseControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value || this.value.length === 0) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence(48);
      writer.writeEnumeration(this.value.result);
      if (this.value.result !== CODES.LDAP_SUCCESS && this.value.failedAttribute) {
        writer.writeString(this.value.failedAttribute, 128);
      }
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    ServerSideSortingResponseControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    ServerSideSortingResponseControl.OID = "1.2.840.113556.1.4.474";
    module.exports = ServerSideSortingResponseControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/virtual_list_view_request_control.js
var require_virtual_list_view_request_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/virtual_list_view_request_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    function VirtualListViewControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = VirtualListViewControl.OID;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          if (Object.prototype.hasOwnProperty.call(options.value, "beforeCount") === false) {
            throw new Error("Missing required key: beforeCount");
          }
          if (Object.prototype.hasOwnProperty.call(options.value, "afterCount") === false) {
            throw new Error("Missing required key: afterCount");
          }
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(VirtualListViewControl, Control);
    Object.defineProperties(VirtualListViewControl.prototype, {
      value: {
        get: function() {
          return this._value || [];
        },
        configurable: false
      }
    });
    VirtualListViewControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence()) {
        this._value = {};
        this._value.beforeCount = ber.readInt();
        this._value.afterCount = ber.readInt();
        if (ber.peek() === 160) {
          if (ber.readSequence(160)) {
            this._value.targetOffset = ber.readInt();
            this._value.contentCount = ber.readInt();
          }
        }
        if (ber.peek() === 129) {
          this._value.greaterThanOrEqual = ber.readString(129);
        }
        return true;
      }
      return false;
    };
    VirtualListViewControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value || this.value.length === 0) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence(48);
      writer.writeInt(this.value.beforeCount);
      writer.writeInt(this.value.afterCount);
      if (this.value.targetOffset !== void 0) {
        writer.startSequence(160);
        writer.writeInt(this.value.targetOffset);
        writer.writeInt(this.value.contentCount);
        writer.endSequence();
      } else if (this.value.greaterThanOrEqual !== void 0) {
        writer.writeString(this.value.greaterThanOrEqual, 129);
      }
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    VirtualListViewControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    VirtualListViewControl.OID = "2.16.840.1.113730.3.4.9";
    module.exports = VirtualListViewControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/virtual_list_view_response_control.js
var require_virtual_list_view_response_control = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/virtual_list_view_response_control.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var Control = require_control();
    var CODES = require_codes();
    var BerReader = asn1.BerReader;
    var BerWriter = asn1.BerWriter;
    var VALID_CODES = [
      CODES.LDAP_SUCCESS,
      CODES.LDAP_OPERATIONS_ERROR,
      CODES.LDAP_UNWILLING_TO_PERFORM,
      CODES.LDAP_INSUFFICIENT_ACCESS_RIGHTS,
      CODES.LDAP_BUSY,
      CODES.LDAP_TIME_LIMIT_EXCEEDED,
      CODES.LDAP_ADMIN_LIMIT_EXCEEDED,
      CODES.LDAP_SORT_CONTROL_MISSING,
      CODES.LDAP_INDEX_RANGE_ERROR,
      CODES.LDAP_CONTROL_ERROR,
      CODES.LDAP_OTHER
    ];
    function VirtualListViewResponseControl(options) {
      assert.optionalObject(options);
      options = options || {};
      options.type = VirtualListViewResponseControl.OID;
      options.criticality = false;
      if (options.value) {
        if (Buffer.isBuffer(options.value)) {
          this.parse(options.value);
        } else if (typeof options.value === "object") {
          if (VALID_CODES.indexOf(options.value.result) === -1) {
            throw new Error("Invalid result code");
          }
          this._value = options.value;
        } else {
          throw new TypeError("options.value must be a Buffer or Object");
        }
        options.value = null;
      }
      Control.call(this, options);
    }
    util.inherits(VirtualListViewResponseControl, Control);
    Object.defineProperties(VirtualListViewResponseControl.prototype, {
      value: {
        get: function() {
          return this._value || {};
        },
        configurable: false
      }
    });
    VirtualListViewResponseControl.prototype.parse = function parse(buffer) {
      assert.ok(buffer);
      const ber = new BerReader(buffer);
      if (ber.readSequence()) {
        this._value = {};
        if (ber.peek(2)) {
          this._value.targetPosition = ber.readInt();
        }
        if (ber.peek(2)) {
          this._value.contentCount = ber.readInt();
        }
        this._value.result = ber.readEnumeration();
        this._value.cookie = ber.readString(asn1.Ber.OctetString, true);
        if (!this._value.cookie) {
          this._value.cookie = Buffer.alloc(0);
        }
        return true;
      }
      return false;
    };
    VirtualListViewResponseControl.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!this._value || this.value.length === 0) {
        return;
      }
      const writer = new BerWriter();
      writer.startSequence();
      if (this.value.targetPosition !== void 0) {
        writer.writeInt(this.value.targetPosition);
      }
      if (this.value.contentCount !== void 0) {
        writer.writeInt(this.value.contentCount);
      }
      writer.writeEnumeration(this.value.result);
      if (this.value.cookie && this.value.cookie.length > 0) {
        writer.writeBuffer(this.value.cookie, asn1.Ber.OctetString);
      } else {
        writer.writeString("");
      }
      writer.endSequence();
      ber.writeBuffer(writer.buffer, 4);
    };
    VirtualListViewResponseControl.prototype._json = function(obj) {
      obj.controlValue = this.value;
      return obj;
    };
    VirtualListViewResponseControl.OID = "2.16.840.1.113730.3.4.10";
    module.exports = VirtualListViewResponseControl;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/controls/index.js
var require_controls = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/controls/index.js"(exports, module) {
    var assert = require_assert();
    var Ber = require_lib().Ber;
    var Control = require_control();
    var EntryChangeNotificationControl = require_entry_change_notification_control();
    var PersistentSearchControl = require_persistent_search_control();
    var PagedResultsControl = require_paged_results_control();
    var ServerSideSortingRequestControl = require_server_side_sorting_request_control();
    var ServerSideSortingResponseControl = require_server_side_sorting_response_control();
    var VirtualListViewRequestControl = require_virtual_list_view_request_control();
    var VirtualListViewResponseControl = require_virtual_list_view_response_control();
    module.exports = {
      getControl: function getControl(ber) {
        assert.ok(ber);
        if (ber.readSequence() === null) {
          return null;
        }
        let type;
        const opts = {
          criticality: false,
          value: null
        };
        if (ber.length) {
          const end = ber.offset + ber.length;
          type = ber.readString();
          if (ber.offset < end) {
            if (ber.peek() === Ber.Boolean) {
              opts.criticality = ber.readBoolean();
            }
          }
          if (ber.offset < end) {
            opts.value = ber.readString(Ber.OctetString, true);
          }
        }
        let control;
        switch (type) {
          case PersistentSearchControl.OID:
            control = new PersistentSearchControl(opts);
            break;
          case EntryChangeNotificationControl.OID:
            control = new EntryChangeNotificationControl(opts);
            break;
          case PagedResultsControl.OID:
            control = new PagedResultsControl(opts);
            break;
          case ServerSideSortingRequestControl.OID:
            control = new ServerSideSortingRequestControl(opts);
            break;
          case ServerSideSortingResponseControl.OID:
            control = new ServerSideSortingResponseControl(opts);
            break;
          case VirtualListViewRequestControl.OID:
            control = new VirtualListViewRequestControl(opts);
            break;
          case VirtualListViewResponseControl.OID:
            control = new VirtualListViewResponseControl(opts);
            break;
          default:
            opts.type = type;
            control = new Control(opts);
            break;
        }
        return control;
      },
      Control,
      EntryChangeNotificationControl,
      PagedResultsControl,
      PersistentSearchControl,
      ServerSideSortingRequestControl,
      ServerSideSortingResponseControl,
      VirtualListViewRequestControl,
      VirtualListViewResponseControl
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/message.js
var require_message = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/message.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var logger = require_logger();
    var BerWriter = asn1.BerWriter;
    var getControl = require_controls().getControl;
    function LDAPMessage(options) {
      assert.object(options);
      this.messageID = options.messageID || 0;
      this.protocolOp = options.protocolOp || void 0;
      this.controls = options.controls ? options.controls.slice(0) : [];
      this.log = options.log || logger;
    }
    Object.defineProperties(LDAPMessage.prototype, {
      id: {
        get: function getId() {
          return this.messageID;
        },
        configurable: false
      },
      dn: {
        get: function getDN() {
          return this._dn || "";
        },
        configurable: false
      },
      type: {
        get: function getType() {
          return "LDAPMessage";
        },
        configurable: false
      },
      json: {
        get: function() {
          const out = this._json({
            messageID: this.messageID,
            protocolOp: this.type
          });
          out.controls = this.controls;
          return out;
        },
        configurable: false
      }
    });
    LDAPMessage.prototype.toString = function() {
      return JSON.stringify(this.json);
    };
    LDAPMessage.prototype.parse = function(ber) {
      assert.ok(ber);
      this.log.trace("parse: data=%s", util.inspect(ber.buffer));
      this._parse(ber, ber.length);
      if (ber.peek() === 160) {
        ber.readSequence();
        const end = ber.offset + ber.length;
        while (ber.offset < end) {
          const c = getControl(ber);
          if (c) {
            this.controls.push(c);
          }
        }
      }
      this.log.trace("Parsing done: %j", this.json);
      return true;
    };
    LDAPMessage.prototype.toBer = function() {
      let writer = new BerWriter();
      writer.startSequence();
      writer.writeInt(this.messageID);
      writer.startSequence(this.protocolOp);
      if (this._toBer) {
        writer = this._toBer(writer);
      }
      writer.endSequence();
      if (this.controls && this.controls.length) {
        writer.startSequence(160);
        this.controls.forEach(function(c) {
          c.toBer(writer);
        });
        writer.endSequence();
      }
      writer.endSequence();
      return writer.buffer;
    };
    module.exports = LDAPMessage;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/dtrace.js
var require_dtrace = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/dtrace.js"(exports, module) {
    var SERVER_PROVIDER;
    var DTRACE_ID = 0;
    var MAX_INT = 4294967295;
    var SERVER_PROBES = {
      // 4: attributes.length
      "server-add-start": ["int", "char *", "char *", "char *", "int"],
      "server-add-done": ["int", "char *", "char *", "char *", "int", "char *"],
      "server-bind-start": ["int", "char *", "char *", "char *"],
      "server-bind-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // 4: attribute, 5: value
      "server-compare-start": [
        "int",
        "char *",
        "char *",
        "char *",
        "char *",
        "char *"
      ],
      "server-compare-done": ["int", "char *", "char *", "char *", "int", "char *"],
      "server-delete-start": ["int", "char *", "char *", "char *"],
      "server-delete-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // 4: requestName, 5: requestValue
      "server-exop-start": [
        "int",
        "char *",
        "char *",
        "char *",
        "char *",
        "char *"
      ],
      "server-exop-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // 4: changes.length
      "server-modify-start": ["int", "char *", "char *", "char *", "int"],
      "server-modify-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // 4: newRdn, 5: newSuperior
      "server-modifydn-start": [
        "int",
        "char *",
        "char *",
        "char *",
        "char *",
        "char *"
      ],
      "server-modifydn-done": [
        "int",
        "char *",
        "char *",
        "char *",
        "int",
        "char *"
      ],
      // 4: scope, 5: filter
      "server-search-start": [
        "int",
        "char *",
        "char *",
        "char *",
        "char *",
        "char *"
      ],
      "server-search-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // Last two are searchEntry.DN and seachEntry.attributes.length
      "server-search-entry": ["int", "char *", "char *", "char *", "char *", "int"],
      "server-unbind-start": ["int", "char *", "char *", "char *"],
      "server-unbind-done": ["int", "char *", "char *", "char *", "int", "char *"],
      "server-abandon-start": ["int", "char *", "char *", "char *"],
      "server-abandon-done": ["int", "char *", "char *", "char *", "int", "char *"],
      // remote IP
      "server-connection": ["char *"]
    };
    module.exports = function() {
      if (!SERVER_PROVIDER) {
        try {
          const dtrace = __require("dtrace-provider");
          SERVER_PROVIDER = dtrace.createDTraceProvider("ldapjs");
          Object.keys(SERVER_PROBES).forEach(function(p) {
            const args = SERVER_PROBES[p].splice(0);
            args.unshift(p);
            dtrace.DTraceProvider.prototype.addProbe.apply(SERVER_PROVIDER, args);
          });
        } catch (e) {
          SERVER_PROVIDER = {
            fire: function() {
            },
            enable: function() {
            },
            addProbe: function() {
              const p = {
                fire: function() {
                }
              };
              return p;
            },
            removeProbe: function() {
            },
            disable: function() {
            }
          };
        }
        SERVER_PROVIDER.enable();
        SERVER_PROVIDER._nextId = function() {
          if (DTRACE_ID === MAX_INT) {
            DTRACE_ID = 0;
          }
          return ++DTRACE_ID;
        };
      }
      return SERVER_PROVIDER;
    }();
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/protocol.js
var require_protocol = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/protocol.js"(exports, module) {
    module.exports = {
      // Misc
      LDAP_VERSION_3: 3,
      LBER_SET: 49,
      LDAP_CONTROLS: 160,
      // Search
      SCOPE_BASE_OBJECT: 0,
      SCOPE_ONE_LEVEL: 1,
      SCOPE_SUBTREE: 2,
      NEVER_DEREF_ALIASES: 0,
      DEREF_IN_SEARCHING: 1,
      DEREF_BASE_OBJECT: 2,
      DEREF_ALWAYS: 3,
      FILTER_AND: 160,
      FILTER_OR: 161,
      FILTER_NOT: 162,
      FILTER_EQUALITY: 163,
      FILTER_SUBSTRINGS: 164,
      FILTER_GE: 165,
      FILTER_LE: 166,
      FILTER_PRESENT: 135,
      FILTER_APPROX: 168,
      FILTER_EXT: 169,
      // Protocol Operations
      LDAP_REQ_BIND: 96,
      LDAP_REQ_UNBIND: 66,
      LDAP_REQ_SEARCH: 99,
      LDAP_REQ_MODIFY: 102,
      LDAP_REQ_ADD: 104,
      LDAP_REQ_DELETE: 74,
      LDAP_REQ_MODRDN: 108,
      LDAP_REQ_COMPARE: 110,
      LDAP_REQ_ABANDON: 80,
      LDAP_REQ_EXTENSION: 119,
      LDAP_REP_BIND: 97,
      LDAP_REP_SEARCH_ENTRY: 100,
      LDAP_REP_SEARCH_REF: 115,
      LDAP_REP_SEARCH: 101,
      LDAP_REP_MODIFY: 103,
      LDAP_REP_ADD: 105,
      LDAP_REP_DELETE: 107,
      LDAP_REP_MODRDN: 109,
      LDAP_REP_COMPARE: 111,
      LDAP_REP_EXTENSION: 120
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/result.js
var require_result = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/result.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var dtrace = require_dtrace();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    function LDAPResult(options) {
      options = options || {};
      assert.object(options);
      assert.optionalNumber(options.status);
      assert.optionalString(options.matchedDN);
      assert.optionalString(options.errorMessage);
      assert.optionalArrayOfString(options.referrals);
      LDAPMessage.call(this, options);
      this.status = options.status || 0;
      this.matchedDN = options.matchedDN || "";
      this.errorMessage = options.errorMessage || "";
      this.referrals = options.referrals || [];
      this.connection = options.connection || null;
    }
    util.inherits(LDAPResult, LDAPMessage);
    Object.defineProperties(LDAPResult.prototype, {
      type: {
        get: function getType() {
          return "LDAPResult";
        },
        configurable: false
      }
    });
    LDAPResult.prototype.end = function(status) {
      assert.ok(this.connection);
      if (typeof status === "number") {
        this.status = status;
      }
      const ber = this.toBer();
      this.log.debug("%s: sending:  %j", this.connection.ldap.id, this.json);
      try {
        const self = this;
        this.connection.write(ber);
        if (self._dtraceOp && self._dtraceId) {
          dtrace.fire("server-" + self._dtraceOp + "-done", function() {
            const c = self.connection || { ldap: {} };
            return [
              self._dtraceId || 0,
              c.remoteAddress || "",
              c.ldap.bindDN ? c.ldap.bindDN.toString() : "",
              self.requestDN ? self.requestDN.toString() : "",
              status || self.status,
              self.errorMessage
            ];
          });
        }
      } catch (e) {
        this.log.warn(
          e,
          "%s failure to write message %j",
          this.connection.ldap.id,
          this.json
        );
      }
    };
    LDAPResult.prototype._parse = function(ber) {
      assert.ok(ber);
      this.status = ber.readEnumeration();
      this.matchedDN = ber.readString();
      this.errorMessage = ber.readString();
      const t = ber.peek();
      if (t === Protocol.LDAP_REP_REFERRAL) {
        const end = ber.offset + ber.length;
        while (ber.offset < end) {
          this.referrals.push(ber.readString());
        }
      }
      return true;
    };
    LDAPResult.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeEnumeration(this.status);
      ber.writeString(this.matchedDN || "");
      ber.writeString(this.errorMessage || "");
      if (this.referrals.length) {
        ber.startSequence(Protocol.LDAP_REP_REFERRAL);
        ber.writeStringArray(this.referrals);
        ber.endSequence();
      }
      return ber;
    };
    LDAPResult.prototype._json = function(j) {
      assert.ok(j);
      j.status = this.status;
      j.matchedDN = this.matchedDN;
      j.errorMessage = this.errorMessage;
      j.referrals = this.referrals;
      return j;
    };
    module.exports = LDAPResult;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/abandon_request.js
var require_abandon_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/abandon_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    function AbandonRequest(options) {
      options = options || {};
      assert.object(options);
      assert.optionalNumber(options.abandonID);
      options.protocolOp = Protocol.LDAP_REQ_ABANDON;
      LDAPMessage.call(this, options);
      this.abandonID = options.abandonID || 0;
    }
    util.inherits(AbandonRequest, LDAPMessage);
    Object.defineProperties(AbandonRequest.prototype, {
      type: {
        get: function getType() {
          return "AbandonRequest";
        },
        configurable: false
      }
    });
    AbandonRequest.prototype._parse = function(ber, length) {
      assert.ok(ber);
      assert.ok(length);
      const buf = ber.buffer;
      let offset = 0;
      let value = 0;
      const fb = buf[offset++];
      value = fb & 127;
      for (let i = 1; i < length; i++) {
        value <<= 8;
        value |= buf[offset++] & 255;
      }
      if ((fb & 128) === 128) {
        value = -value;
      }
      ber._offset += length;
      this.abandonID = value;
      return true;
    };
    AbandonRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      let i = this.abandonID;
      let sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688) && sz > 1) {
        sz--;
        i <<= 8;
      }
      assert.ok(sz <= 4);
      while (sz-- > 0) {
        ber.writeByte((i & 4278190080) >> 24);
        i <<= 8;
      }
      return ber;
    };
    AbandonRequest.prototype._json = function(j) {
      assert.ok(j);
      j.abandonID = this.abandonID;
      return j;
    };
    module.exports = AbandonRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/attribute.js
var require_attribute = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/attribute.js"(exports, module) {
    var assert = require_assert();
    var asn1 = require_lib();
    var Protocol = require_protocol();
    function Attribute(options) {
      if (options) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        if (options.type && typeof options.type !== "string") {
          throw new TypeError("options.type must be a string");
        }
      } else {
        options = {};
      }
      this.type = options.type || "";
      this._vals = [];
      if (options.vals !== void 0 && options.vals !== null) {
        this.vals = options.vals;
      }
    }
    module.exports = Attribute;
    Object.defineProperties(Attribute.prototype, {
      buffers: {
        get: function getBuffers() {
          return this._vals;
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: this.type,
            vals: this.vals
          };
        },
        configurable: false
      },
      vals: {
        get: function getVals() {
          const eType = _bufferEncoding(this.type);
          return this._vals.map(function(v) {
            return v.toString(eType);
          });
        },
        set: function setVals(vals) {
          const self = this;
          this._vals = [];
          if (Array.isArray(vals)) {
            vals.forEach(function(v) {
              self.addValue(v);
            });
          } else {
            self.addValue(vals);
          }
        },
        configurable: false
      }
    });
    Attribute.prototype.addValue = function addValue(val) {
      if (Buffer.isBuffer(val)) {
        this._vals.push(val);
      } else {
        this._vals.push(Buffer.from(val + "", _bufferEncoding(this.type)));
      }
    };
    Attribute.compare = function compare(a, b) {
      if (!Attribute.isAttribute(a) || !Attribute.isAttribute(b)) {
        throw new TypeError("can only compare Attributes");
      }
      if (a.type < b.type)
        return -1;
      if (a.type > b.type)
        return 1;
      if (a.vals.length < b.vals.length)
        return -1;
      if (a.vals.length > b.vals.length)
        return 1;
      for (let i = 0; i < a.vals.length; i++) {
        if (a.vals[i] < b.vals[i])
          return -1;
        if (a.vals[i] > b.vals[i])
          return 1;
      }
      return 0;
    };
    Attribute.prototype.parse = function parse(ber) {
      assert.ok(ber);
      ber.readSequence();
      this.type = ber.readString();
      if (ber.peek() === Protocol.LBER_SET) {
        if (ber.readSequence(Protocol.LBER_SET)) {
          const end = ber.offset + ber.length;
          while (ber.offset < end) {
            this._vals.push(ber.readString(asn1.Ber.OctetString, true));
          }
        }
      }
      return true;
    };
    Attribute.prototype.toBer = function toBer(ber) {
      assert.ok(ber);
      ber.startSequence();
      ber.writeString(this.type);
      ber.startSequence(Protocol.LBER_SET);
      if (this._vals.length) {
        this._vals.forEach(function(b) {
          ber.writeByte(asn1.Ber.OctetString);
          ber.writeLength(b.length);
          for (let i = 0; i < b.length; i++) {
            ber.writeByte(b[i]);
          }
        });
      } else {
        ber.writeStringArray([]);
      }
      ber.endSequence();
      ber.endSequence();
      return ber;
    };
    Attribute.prototype.toString = function() {
      return JSON.stringify(this.json);
    };
    Attribute.toBer = function(attr, ber) {
      return Attribute.prototype.toBer.call(attr, ber);
    };
    Attribute.isAttribute = function isAttribute(attr) {
      if (!attr || typeof attr !== "object") {
        return false;
      }
      if (attr instanceof Attribute) {
        return true;
      }
      if (typeof attr.toBer === "function" && typeof attr.type === "string" && Array.isArray(attr.vals) && attr.vals.filter(function(item) {
        return typeof item === "string" || Buffer.isBuffer(item);
      }).length === attr.vals.length) {
        return true;
      }
      return false;
    };
    function _bufferEncoding(type) {
      return /;binary$/.test(type) ? "base64" : "utf8";
    }
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/dn.js
var require_dn = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/dn.js"(exports, module) {
    var assert = require_assert2();
    function invalidDN(name) {
      const e = new Error();
      e.name = "InvalidDistinguishedNameError";
      e.message = name;
      return e;
    }
    function isAlphaNumeric(c) {
      const re = /[A-Za-z0-9]/;
      return re.test(c);
    }
    function isWhitespace(c) {
      const re = /\s/;
      return re.test(c);
    }
    function repeatChar(c, n) {
      let out = "";
      const max = n || 0;
      for (let i = 0; i < max; i++) {
        out += c;
      }
      return out;
    }
    function RDN(obj) {
      const self = this;
      this.attrs = {};
      if (obj) {
        Object.keys(obj).forEach(function(k) {
          self.set(k, obj[k]);
        });
      }
    }
    RDN.prototype.set = function rdnSet(name, value, opts) {
      assert.string(name, "name (string) required");
      assert.string(value, "value (string) required");
      const self = this;
      const lname = name.toLowerCase();
      this.attrs[lname] = {
        value,
        name
      };
      if (opts && typeof opts === "object") {
        Object.keys(opts).forEach(function(k) {
          if (k !== "value") {
            self.attrs[lname][k] = opts[k];
          }
        });
      }
    };
    RDN.prototype.equals = function rdnEquals(rdn) {
      if (typeof rdn !== "object") {
        return false;
      }
      const ourKeys = Object.keys(this.attrs);
      const theirKeys = Object.keys(rdn.attrs);
      if (ourKeys.length !== theirKeys.length) {
        return false;
      }
      ourKeys.sort();
      theirKeys.sort();
      for (let i = 0; i < ourKeys.length; i++) {
        if (ourKeys[i] !== theirKeys[i]) {
          return false;
        }
        if (this.attrs[ourKeys[i]].value !== rdn.attrs[ourKeys[i]].value) {
          return false;
        }
      }
      return true;
    };
    RDN.prototype.format = function rdnFormat(options) {
      assert.optionalObject(options, "options must be an object");
      options = options || {};
      const self = this;
      let str = "";
      function escapeValue(val, forceQuote) {
        let out = "";
        let cur = 0;
        const len = val.length;
        let quoted = false;
        const escaped = /[\\\"]/;
        const special = /[,=+<>#;]/;
        if (len > 0) {
          quoted = forceQuote || (val[0] === " " || val[len - 1] === " ");
        }
        while (cur < len) {
          if (escaped.test(val[cur]) || !quoted && special.test(val[cur])) {
            out += "\\";
          }
          out += val[cur++];
        }
        if (quoted) {
          out = '"' + out + '"';
        }
        return out;
      }
      function sortParsed(a, b) {
        return self.attrs[a].order - self.attrs[b].order;
      }
      function sortStandard(a, b) {
        const nameCompare = a.localeCompare(b);
        if (nameCompare === 0) {
          return self.attrs[a].value.localeCompare(self.attrs[b].value);
        } else {
          return nameCompare;
        }
      }
      const keys = Object.keys(this.attrs);
      if (options.keepOrder) {
        keys.sort(sortParsed);
      } else {
        keys.sort(sortStandard);
      }
      keys.forEach(function(key) {
        const attr = self.attrs[key];
        if (str.length) {
          str += "+";
        }
        if (options.keepCase) {
          str += attr.name;
        } else {
          if (options.upperName) {
            str += key.toUpperCase();
          } else {
            str += key;
          }
        }
        str += "=" + escapeValue(attr.value, options.keepQuote && attr.quoted);
      });
      return str;
    };
    RDN.prototype.toString = function rdnToString() {
      return this.format();
    };
    function parse(name) {
      if (typeof name !== "string") {
        throw new TypeError("name (string) required");
      }
      let cur = 0;
      const len = name.length;
      function parseRdn() {
        const rdn = new RDN();
        let order = 0;
        rdn.spLead = trim();
        while (cur < len) {
          const opts = {
            order
          };
          const attr = parseAttrType();
          trim();
          if (cur >= len || name[cur++] !== "=") {
            throw invalidDN(name);
          }
          trim();
          const value = parseAttrValue(opts);
          rdn.set(attr, value, opts);
          rdn.spTrail = trim();
          if (cur >= len || name[cur] !== "+") {
            break;
          }
          ++cur;
          ++order;
        }
        return rdn;
      }
      function trim() {
        let count = 0;
        while (cur < len && isWhitespace(name[cur])) {
          ++cur;
          count++;
        }
        return count;
      }
      function parseAttrType() {
        const beg = cur;
        while (cur < len) {
          const c = name[cur];
          if (isAlphaNumeric(c) || c === "." || c === "-" || c === " ") {
            ++cur;
          } else {
            break;
          }
        }
        while (cur > beg && name[cur - 1] === " ") {
          --cur;
        }
        if (beg === cur) {
          throw invalidDN(name);
        }
        return name.slice(beg, cur);
      }
      function parseAttrValue(opts) {
        if (cur < len && name[cur] === "#") {
          opts.binary = true;
          return parseBinaryAttrValue();
        } else if (cur < len && name[cur] === '"') {
          opts.quoted = true;
          return parseQuotedAttrValue();
        } else {
          return parseStringAttrValue();
        }
      }
      function parseBinaryAttrValue() {
        const beg = cur++;
        while (cur < len && isAlphaNumeric(name[cur])) {
          ++cur;
        }
        return name.slice(beg, cur);
      }
      function parseQuotedAttrValue() {
        let str = "";
        ++cur;
        while (cur < len && name[cur] !== '"') {
          if (name[cur] === "\\") {
            cur++;
          }
          str += name[cur++];
        }
        if (cur++ >= len) {
          throw invalidDN(name);
        }
        return str;
      }
      function parseStringAttrValue() {
        const beg = cur;
        let str = "";
        let esc = -1;
        while (cur < len && !atTerminator()) {
          if (name[cur] === "\\") {
            esc = cur++;
          }
          if (cur === len) {
            throw invalidDN(name);
          }
          str += name[cur++];
        }
        for (; cur > beg; cur--) {
          if (!isWhitespace(name[cur - 1]) || esc === cur - 1) {
            break;
          }
        }
        return str.slice(0, cur - beg);
      }
      function atTerminator() {
        return cur < len && (name[cur] === "," || name[cur] === ";" || name[cur] === "+");
      }
      const rdns = [];
      if (len === 0) {
        return new DN(rdns);
      }
      rdns.push(parseRdn());
      while (cur < len) {
        if (name[cur] === "," || name[cur] === ";") {
          ++cur;
          rdns.push(parseRdn());
        } else {
          throw invalidDN(name);
        }
      }
      return new DN(rdns);
    }
    function DN(rdns) {
      assert.optionalArrayOfObject(rdns, "[object] required");
      this.rdns = rdns ? rdns.slice() : [];
      this._format = {};
    }
    Object.defineProperties(DN.prototype, {
      length: {
        get: function getLength() {
          return this.rdns.length;
        },
        configurable: false
      }
    });
    DN.prototype.format = function dnFormat(options) {
      assert.optionalObject(options, "options must be an object");
      options = options || this._format;
      let str = "";
      this.rdns.forEach(function(rdn) {
        const rdnString = rdn.format(options);
        if (str.length !== 0) {
          str += ",";
        }
        if (options.keepSpace) {
          str += repeatChar(" ", rdn.spLead) + rdnString + repeatChar(" ", rdn.spTrail);
        } else if (options.skipSpace === true || str.length === 0) {
          str += rdnString;
        } else {
          str += " " + rdnString;
        }
      });
      return str;
    };
    DN.prototype.setFormat = function setFormat(options) {
      assert.object(options, "options must be an object");
      this._format = options;
    };
    DN.prototype.toString = function dnToString() {
      return this.format();
    };
    DN.prototype.parentOf = function parentOf(dn) {
      if (typeof dn !== "object") {
        dn = parse(dn);
      }
      if (this.rdns.length >= dn.rdns.length) {
        return false;
      }
      const diff = dn.rdns.length - this.rdns.length;
      for (let i = this.rdns.length - 1; i >= 0; i--) {
        const myRDN = this.rdns[i];
        const theirRDN = dn.rdns[i + diff];
        if (!myRDN.equals(theirRDN)) {
          return false;
        }
      }
      return true;
    };
    DN.prototype.childOf = function childOf(dn) {
      if (typeof dn !== "object") {
        dn = parse(dn);
      }
      return dn.parentOf(this);
    };
    DN.prototype.isEmpty = function isEmpty() {
      return this.rdns.length === 0;
    };
    DN.prototype.equals = function dnEquals(dn) {
      if (typeof dn !== "object") {
        dn = parse(dn);
      }
      if (this.rdns.length !== dn.rdns.length) {
        return false;
      }
      for (let i = 0; i < this.rdns.length; i++) {
        if (!this.rdns[i].equals(dn.rdns[i])) {
          return false;
        }
      }
      return true;
    };
    DN.prototype.parent = function dnParent() {
      if (this.rdns.length !== 0) {
        const save = this.rdns.shift();
        const dn = new DN(this.rdns);
        this.rdns.unshift(save);
        return dn;
      }
      return null;
    };
    DN.prototype.clone = function dnClone() {
      const dn = new DN(this.rdns);
      dn._format = this._format;
      return dn;
    };
    DN.prototype.reverse = function dnReverse() {
      this.rdns.reverse();
      return this;
    };
    DN.prototype.pop = function dnPop() {
      return this.rdns.pop();
    };
    DN.prototype.push = function dnPush(rdn) {
      assert.object(rdn, "rdn (RDN) required");
      return this.rdns.push(rdn);
    };
    DN.prototype.shift = function dnShift() {
      return this.rdns.shift();
    };
    DN.prototype.unshift = function dnUnshift(rdn) {
      assert.object(rdn, "rdn (RDN) required");
      return this.rdns.unshift(rdn);
    };
    DN.isDN = function isDN(dn) {
      if (!dn || typeof dn !== "object") {
        return false;
      }
      if (dn instanceof DN) {
        return true;
      }
      if (Array.isArray(dn.rdns)) {
        return true;
      }
      return false;
    };
    module.exports = {
      parse,
      DN,
      RDN
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/assert.js
var require_assert3 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/assert.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var isDN = require_dn().DN.isDN;
    var isAttribute = require_attribute().isAttribute;
    function _assert(arg, type, name) {
      name = name || type;
      throw new assert.AssertionError({
        message: util.format("%s (%s) required", name, type),
        actual: typeof arg,
        expected: type,
        operator: "===",
        stackStartFunction: _assert.caller
      });
    }
    function stringDN(input, name) {
      if (isDN(input) || typeof input === "string") {
        return;
      }
      _assert(input, "DN or string", name);
    }
    function optionalStringDN(input, name) {
      if (input === void 0 || isDN(input) || typeof input === "string") {
        return;
      }
      _assert(input, "DN or string", name);
    }
    function optionalDN(input, name) {
      if (input !== void 0 && !isDN(input)) {
        _assert(input, "DN", name);
      }
    }
    function optionalArrayOfAttribute(input, name) {
      if (input === void 0) {
        return;
      }
      if (!Array.isArray(input) || input.some(function(v) {
        return !isAttribute(v);
      })) {
        _assert(input, "array of Attribute", name);
      }
    }
    module.exports = {
      stringDN,
      optionalStringDN,
      optionalDN,
      optionalArrayOfAttribute
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/add_request.js
var require_add_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/add_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Attribute = require_attribute();
    var Protocol = require_protocol();
    var lassert = require_assert3();
    function AddRequest(options) {
      options = options || {};
      assert.object(options);
      lassert.optionalStringDN(options.entry);
      lassert.optionalArrayOfAttribute(options.attributes);
      options.protocolOp = Protocol.LDAP_REQ_ADD;
      LDAPMessage.call(this, options);
      this.entry = options.entry || null;
      this.attributes = options.attributes ? options.attributes.slice(0) : [];
    }
    util.inherits(AddRequest, LDAPMessage);
    Object.defineProperties(AddRequest.prototype, {
      type: {
        get: function getType() {
          return "AddRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.entry;
        },
        configurable: false
      }
    });
    AddRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.entry = ber.readString();
      ber.readSequence();
      const end = ber.offset + ber.length;
      while (ber.offset < end) {
        const a = new Attribute();
        a.parse(ber);
        a.type = a.type.toLowerCase();
        if (a.type === "objectclass") {
          for (let i = 0; i < a.vals.length; i++) {
            a.vals[i] = a.vals[i].toLowerCase();
          }
        }
        this.attributes.push(a);
      }
      this.attributes.sort(Attribute.compare);
      return true;
    };
    AddRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.entry.toString());
      ber.startSequence();
      this.attributes.forEach(function(a) {
        a.toBer(ber);
      });
      ber.endSequence();
      return ber;
    };
    AddRequest.prototype._json = function(j) {
      assert.ok(j);
      j.entry = this.entry.toString();
      j.attributes = [];
      this.attributes.forEach(function(a) {
        j.attributes.push(a.json);
      });
      return j;
    };
    AddRequest.prototype.indexOf = function(attr) {
      if (!attr || typeof attr !== "string") {
        throw new TypeError("attr (string) required");
      }
      for (let i = 0; i < this.attributes.length; i++) {
        if (this.attributes[i].type === attr) {
          return i;
        }
      }
      return -1;
    };
    AddRequest.prototype.attributeNames = function() {
      const attrs = [];
      for (let i = 0; i < this.attributes.length; i++) {
        attrs.push(this.attributes[i].type.toLowerCase());
      }
      return attrs;
    };
    AddRequest.prototype.getAttribute = function(name) {
      if (!name || typeof name !== "string") {
        throw new TypeError("attribute name (string) required");
      }
      name = name.toLowerCase();
      for (let i = 0; i < this.attributes.length; i++) {
        if (this.attributes[i].type === name) {
          return this.attributes[i];
        }
      }
      return null;
    };
    AddRequest.prototype.addAttribute = function(attr) {
      if (!(attr instanceof Attribute)) {
        throw new TypeError("attribute (Attribute) required");
      }
      return this.attributes.push(attr);
    };
    AddRequest.prototype.toObject = function() {
      const self = this;
      const obj = {
        dn: self.entry ? self.entry.toString() : "",
        attributes: {}
      };
      if (!this.attributes || !this.attributes.length) {
        return obj;
      }
      this.attributes.forEach(function(a) {
        if (!obj.attributes[a.type]) {
          obj.attributes[a.type] = [];
        }
        a.vals.forEach(function(v) {
          if (obj.attributes[a.type].indexOf(v) === -1) {
            obj.attributes[a.type].push(v);
          }
        });
      });
      return obj;
    };
    module.exports = AddRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/add_response.js
var require_add_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/add_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function AddResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_ADD;
      LDAPResult.call(this, options);
    }
    util.inherits(AddResponse, LDAPResult);
    module.exports = AddResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/bind_request.js
var require_bind_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/bind_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    var Ber = asn1.Ber;
    var LDAP_BIND_SIMPLE = "simple";
    function BindRequest(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REQ_BIND;
      LDAPMessage.call(this, options);
      this.version = options.version || 3;
      this.name = options.name || null;
      this.authentication = options.authentication || LDAP_BIND_SIMPLE;
      this.credentials = options.credentials || "";
    }
    util.inherits(BindRequest, LDAPMessage);
    Object.defineProperties(BindRequest.prototype, {
      type: {
        get: function getType() {
          return "BindRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.name;
        },
        configurable: false
      }
    });
    BindRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.version = ber.readInt();
      this.name = ber.readString();
      const t = ber.peek();
      if (t !== Ber.Context) {
        throw new Error("authentication 0x" + t.toString(16) + " not supported");
      }
      this.authentication = LDAP_BIND_SIMPLE;
      this.credentials = ber.readString(Ber.Context);
      return true;
    };
    BindRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeInt(this.version);
      ber.writeString((this.name || "").toString());
      ber.writeString(this.credentials || "", Ber.Context);
      return ber;
    };
    BindRequest.prototype._json = function(j) {
      assert.ok(j);
      j.version = this.version;
      j.name = this.name;
      j.authenticationType = this.authentication;
      j.credentials = this.credentials;
      return j;
    };
    module.exports = BindRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/bind_response.js
var require_bind_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/bind_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function BindResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_BIND;
      LDAPResult.call(this, options);
    }
    util.inherits(BindResponse, LDAPResult);
    module.exports = BindResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/compare_request.js
var require_compare_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/compare_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    var lassert = require_assert3();
    function CompareRequest(options) {
      options = options || {};
      assert.object(options);
      assert.optionalString(options.attribute);
      assert.optionalString(options.value);
      lassert.optionalStringDN(options.entry);
      options.protocolOp = Protocol.LDAP_REQ_COMPARE;
      LDAPMessage.call(this, options);
      this.entry = options.entry || null;
      this.attribute = options.attribute || "";
      this.value = options.value || "";
    }
    util.inherits(CompareRequest, LDAPMessage);
    Object.defineProperties(CompareRequest.prototype, {
      type: {
        get: function getType() {
          return "CompareRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.entry;
        },
        configurable: false
      }
    });
    CompareRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.entry = ber.readString();
      ber.readSequence();
      this.attribute = ber.readString().toLowerCase();
      this.value = ber.readString();
      return true;
    };
    CompareRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.entry.toString());
      ber.startSequence();
      ber.writeString(this.attribute);
      ber.writeString(this.value);
      ber.endSequence();
      return ber;
    };
    CompareRequest.prototype._json = function(j) {
      assert.ok(j);
      j.entry = this.entry.toString();
      j.attribute = this.attribute;
      j.value = this.value;
      return j;
    };
    module.exports = CompareRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/compare_response.js
var require_compare_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/compare_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function CompareResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_COMPARE;
      LDAPResult.call(this, options);
    }
    util.inherits(CompareResponse, LDAPResult);
    CompareResponse.prototype.end = function(matches) {
      let status = 6;
      if (typeof matches === "boolean") {
        if (!matches) {
          status = 5;
        }
      } else {
        status = matches;
      }
      return LDAPResult.prototype.end.call(this, status);
    };
    module.exports = CompareResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/del_request.js
var require_del_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/del_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    var lassert = require_assert3();
    function DeleteRequest(options) {
      options = options || {};
      assert.object(options);
      lassert.optionalStringDN(options.entry);
      options.protocolOp = Protocol.LDAP_REQ_DELETE;
      LDAPMessage.call(this, options);
      this.entry = options.entry || null;
    }
    util.inherits(DeleteRequest, LDAPMessage);
    Object.defineProperties(DeleteRequest.prototype, {
      type: {
        get: function getType() {
          return "DeleteRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.entry;
        },
        configurable: false
      }
    });
    DeleteRequest.prototype._parse = function(ber, length) {
      assert.ok(ber);
      this.entry = ber.buffer.slice(0, length).toString("utf8");
      ber._offset += ber.length;
      return true;
    };
    DeleteRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      const buf = Buffer.from(this.entry.toString());
      for (let i = 0; i < buf.length; i++) {
        ber.writeByte(buf[i]);
      }
      return ber;
    };
    DeleteRequest.prototype._json = function(j) {
      assert.ok(j);
      j.entry = this.entry;
      return j;
    };
    module.exports = DeleteRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/del_response.js
var require_del_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/del_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function DeleteResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_DELETE;
      LDAPResult.call(this, options);
    }
    util.inherits(DeleteResponse, LDAPResult);
    module.exports = DeleteResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/ext_request.js
var require_ext_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/ext_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    function ExtendedRequest(options) {
      options = options || {};
      assert.object(options);
      assert.optionalString(options.requestName);
      if (options.requestValue && !(Buffer.isBuffer(options.requestValue) || typeof options.requestValue === "string")) {
        throw new TypeError("options.requestValue must be a buffer or a string");
      }
      options.protocolOp = Protocol.LDAP_REQ_EXTENSION;
      LDAPMessage.call(this, options);
      this.requestName = options.requestName || "";
      this.requestValue = options.requestValue;
      if (Buffer.isBuffer(this.requestValue)) {
        this.requestValueBuffer = this.requestValue;
      } else {
        this.requestValueBuffer = Buffer.from(this.requestValue || "", "utf8");
      }
    }
    util.inherits(ExtendedRequest, LDAPMessage);
    Object.defineProperties(ExtendedRequest.prototype, {
      type: {
        get: function getType() {
          return "ExtendedRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.requestName;
        },
        configurable: false
      },
      name: {
        get: function getName() {
          return this.requestName;
        },
        set: function setName(val) {
          assert.string(val);
          this.requestName = val;
        },
        configurable: false
      },
      value: {
        get: function getValue() {
          return this.requestValue;
        },
        set: function setValue(val) {
          if (!(Buffer.isBuffer(val) || typeof val === "string")) {
            throw new TypeError("value must be a buffer or a string");
          }
          if (Buffer.isBuffer(val)) {
            this.requestValueBuffer = val;
          } else {
            this.requestValueBuffer = Buffer.from(val, "utf8");
          }
          this.requestValue = val;
        },
        configurable: false
      },
      valueBuffer: {
        get: function getValueBuffer() {
          return this.requestValueBuffer;
        },
        set: function setValueBuffer(val) {
          if (!Buffer.isBuffer(val)) {
            throw new TypeError("valueBuffer must be a buffer");
          }
          this.value = val;
        },
        configurable: false
      }
    });
    ExtendedRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.requestName = ber.readString(128);
      if (ber.peek() === 129) {
        this.requestValueBuffer = ber.readString(129, true);
        this.requestValue = this.requestValueBuffer.toString("utf8");
      }
      return true;
    };
    ExtendedRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.requestName, 128);
      if (Buffer.isBuffer(this.requestValue)) {
        ber.writeBuffer(this.requestValue, 129);
      } else if (typeof this.requestValue === "string") {
        ber.writeString(this.requestValue, 129);
      }
      return ber;
    };
    ExtendedRequest.prototype._json = function(j) {
      assert.ok(j);
      j.requestName = this.requestName;
      j.requestValue = Buffer.isBuffer(this.requestValue) ? this.requestValue.toString("hex") : this.requestValue;
      return j;
    };
    module.exports = ExtendedRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/ext_response.js
var require_ext_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/ext_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function ExtendedResponse(options) {
      options = options || {};
      assert.object(options);
      assert.optionalString(options.responseName);
      assert.optionalString(options.responsevalue);
      this.responseName = options.responseName || void 0;
      this.responseValue = options.responseValue || void 0;
      options.protocolOp = Protocol.LDAP_REP_EXTENSION;
      LDAPResult.call(this, options);
    }
    util.inherits(ExtendedResponse, LDAPResult);
    Object.defineProperties(ExtendedResponse.prototype, {
      type: {
        get: function getType() {
          return "ExtendedResponse";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.responseName;
        },
        configurable: false
      },
      name: {
        get: function getName() {
          return this.responseName;
        },
        set: function setName(val) {
          assert.string(val);
          this.responseName = val;
        },
        configurable: false
      },
      value: {
        get: function getValue() {
          return this.responseValue;
        },
        set: function(val) {
          assert.string(val);
          this.responseValue = val;
        },
        configurable: false
      }
    });
    ExtendedResponse.prototype._parse = function(ber) {
      assert.ok(ber);
      if (!LDAPResult.prototype._parse.call(this, ber)) {
        return false;
      }
      if (ber.peek() === 138) {
        this.responseName = ber.readString(138);
      }
      if (ber.peek() === 139) {
        this.responseValue = ber.readString(139);
      }
      return true;
    };
    ExtendedResponse.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (!LDAPResult.prototype._toBer.call(this, ber)) {
        return false;
      }
      if (this.responseName) {
        ber.writeString(this.responseName, 138);
      }
      if (this.responseValue) {
        ber.writeString(this.responseValue, 139);
      }
      return ber;
    };
    ExtendedResponse.prototype._json = function(j) {
      assert.ok(j);
      j = LDAPResult.prototype._json.call(this, j);
      j.responseName = this.responseName;
      j.responseValue = this.responseValue;
      return j;
    };
    module.exports = ExtendedResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/change.js
var require_change = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/change.js"(exports, module) {
    var assert = require_assert2();
    var Attribute = require_attribute();
    function Change(options) {
      if (options) {
        assert.object(options);
        assert.optionalString(options.operation);
      } else {
        options = {};
      }
      this._modification = false;
      this.operation = options.operation || options.type || "add";
      this.modification = options.modification || {};
    }
    Object.defineProperties(Change.prototype, {
      operation: {
        get: function getOperation() {
          switch (this._operation) {
            case 0:
              return "add";
            case 1:
              return "delete";
            case 2:
              return "replace";
            default:
              throw new Error("0x" + this._operation.toString(16) + " is invalid");
          }
        },
        set: function setOperation(val) {
          assert.string(val);
          switch (val.toLowerCase()) {
            case "add":
              this._operation = 0;
              break;
            case "delete":
              this._operation = 1;
              break;
            case "replace":
              this._operation = 2;
              break;
            default:
              throw new Error("Invalid operation type: 0x" + val.toString(16));
          }
        },
        configurable: false
      },
      modification: {
        get: function getModification() {
          return this._modification;
        },
        set: function setModification(val) {
          if (Attribute.isAttribute(val)) {
            this._modification = val;
            return;
          }
          if (Object.keys(val).length === 2 && typeof val.type === "string" && Array.isArray(val.vals)) {
            this._modification = new Attribute({
              type: val.type,
              vals: val.vals
            });
            return;
          }
          const keys = Object.keys(val);
          if (keys.length > 1) {
            throw new Error("Only one attribute per Change allowed");
          } else if (keys.length === 0) {
            return;
          }
          const k = keys[0];
          const _attr = new Attribute({ type: k });
          if (Array.isArray(val[k])) {
            val[k].forEach(function(v) {
              _attr.addValue(v.toString());
            });
          } else if (Buffer.isBuffer(val[k])) {
            _attr.addValue(val[k]);
          } else if (val[k] !== void 0 && val[k] !== null) {
            _attr.addValue(val[k].toString());
          }
          this._modification = _attr;
        },
        configurable: false
      },
      json: {
        get: function getJSON() {
          return {
            operation: this.operation,
            modification: this._modification ? this._modification.json : {}
          };
        },
        configurable: false
      }
    });
    Change.isChange = function isChange(change) {
      if (!change || typeof change !== "object") {
        return false;
      }
      if (change instanceof Change || typeof change.toBer === "function" && change.modification !== void 0 && change.operation !== void 0) {
        return true;
      }
      return false;
    };
    Change.compare = function(a, b) {
      if (!Change.isChange(a) || !Change.isChange(b)) {
        throw new TypeError("can only compare Changes");
      }
      if (a.operation < b.operation) {
        return -1;
      }
      if (a.operation > b.operation) {
        return 1;
      }
      return Attribute.compare(a.modification, b.modification);
    };
    Change.apply = function apply2(change, obj, scalar) {
      assert.string(change.operation);
      assert.string(change.modification.type);
      assert.ok(Array.isArray(change.modification.vals));
      assert.object(obj);
      const type = change.modification.type;
      const vals = change.modification.vals;
      let data = obj[type];
      if (data !== void 0) {
        if (!Array.isArray(data)) {
          data = [data];
        }
      } else {
        data = [];
      }
      switch (change.operation) {
        case "replace":
          if (vals.length === 0) {
            delete obj[type];
            return obj;
          } else {
            data = vals;
          }
          break;
        case "add": {
          const newValues = vals.filter(function(entry) {
            return data.indexOf(entry) === -1;
          });
          data = data.concat(newValues);
          break;
        }
        case "delete":
          data = data.filter(function(entry) {
            return vals.indexOf(entry) === -1;
          });
          if (data.length === 0) {
            delete obj[type];
            return obj;
          }
          break;
        default:
          break;
      }
      if (scalar && data.length === 1) {
        obj[type] = data[0];
      } else {
        obj[type] = data;
      }
      return obj;
    };
    Change.prototype.parse = function(ber) {
      assert.ok(ber);
      ber.readSequence();
      this._operation = ber.readEnumeration();
      this._modification = new Attribute();
      this._modification.parse(ber);
      return true;
    };
    Change.prototype.toBer = function(ber) {
      assert.ok(ber);
      ber.startSequence();
      ber.writeEnumeration(this._operation);
      ber = this._modification.toBer(ber);
      ber.endSequence();
      return ber;
    };
    module.exports = Change;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/modify_request.js
var require_modify_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/modify_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Change = require_change();
    var Protocol = require_protocol();
    var lassert = require_assert3();
    function ModifyRequest(options) {
      options = options || {};
      assert.object(options);
      lassert.optionalStringDN(options.object);
      lassert.optionalArrayOfAttribute(options.attributes);
      options.protocolOp = Protocol.LDAP_REQ_MODIFY;
      LDAPMessage.call(this, options);
      this.object = options.object || null;
      this.changes = options.changes ? options.changes.slice(0) : [];
    }
    util.inherits(ModifyRequest, LDAPMessage);
    Object.defineProperties(ModifyRequest.prototype, {
      type: {
        get: function getType() {
          return "ModifyRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.object;
        },
        configurable: false
      }
    });
    ModifyRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.object = ber.readString();
      ber.readSequence();
      const end = ber.offset + ber.length;
      while (ber.offset < end) {
        const c = new Change();
        c.parse(ber);
        c.modification.type = c.modification.type.toLowerCase();
        this.changes.push(c);
      }
      this.changes.sort(Change.compare);
      return true;
    };
    ModifyRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.object.toString());
      ber.startSequence();
      this.changes.forEach(function(c) {
        c.toBer(ber);
      });
      ber.endSequence();
      return ber;
    };
    ModifyRequest.prototype._json = function(j) {
      assert.ok(j);
      j.object = this.object;
      j.changes = [];
      this.changes.forEach(function(c) {
        j.changes.push(c.json);
      });
      return j;
    };
    module.exports = ModifyRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/modify_response.js
var require_modify_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/modify_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function ModifyResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_MODIFY;
      LDAPResult.call(this, options);
    }
    util.inherits(ModifyResponse, LDAPResult);
    module.exports = ModifyResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/moddn_request.js
var require_moddn_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/moddn_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    var dn = require_dn();
    var lassert = require_assert3();
    function ModifyDNRequest(options) {
      options = options || {};
      assert.object(options);
      assert.optionalBool(options.deleteOldRdn);
      lassert.optionalStringDN(options.entry);
      lassert.optionalDN(options.newRdn);
      lassert.optionalDN(options.newSuperior);
      options.protocolOp = Protocol.LDAP_REQ_MODRDN;
      LDAPMessage.call(this, options);
      this.entry = options.entry || null;
      this.newRdn = options.newRdn || null;
      this.deleteOldRdn = options.deleteOldRdn || true;
      this.newSuperior = options.newSuperior || null;
    }
    util.inherits(ModifyDNRequest, LDAPMessage);
    Object.defineProperties(ModifyDNRequest.prototype, {
      type: {
        get: function getType() {
          return "ModifyDNRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.entry;
        },
        configurable: false
      }
    });
    ModifyDNRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.entry = ber.readString();
      this.newRdn = dn.parse(ber.readString());
      this.deleteOldRdn = ber.readBoolean();
      if (ber.peek() === 128) {
        this.newSuperior = dn.parse(ber.readString(128));
      }
      return true;
    };
    ModifyDNRequest.prototype._toBer = function(ber) {
      ber.writeString(this.entry.toString());
      ber.writeString(this.newRdn.toString());
      ber.writeBoolean(this.deleteOldRdn);
      if (this.newSuperior) {
        const s = this.newSuperior.toString();
        const len = Buffer.byteLength(s);
        ber.writeByte(128);
        ber.writeLength(len);
        ber._ensure(len);
        ber._buf.write(s, ber._offset);
        ber._offset += len;
      }
      return ber;
    };
    ModifyDNRequest.prototype._json = function(j) {
      assert.ok(j);
      j.entry = this.entry.toString();
      j.newRdn = this.newRdn.toString();
      j.deleteOldRdn = this.deleteOldRdn;
      j.newSuperior = this.newSuperior ? this.newSuperior.toString() : "";
      return j;
    };
    module.exports = ModifyDNRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/moddn_response.js
var require_moddn_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/moddn_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    function ModifyDNResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_MODRDN;
      LDAPResult.call(this, options);
    }
    util.inherits(ModifyDNResponse, LDAPResult);
    module.exports = ModifyDNResponse;
  }
});

// node_modules/ldap-filter/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/ldap-filter/lib/helpers.js"(exports, module) {
    var assert = require_assert2();
    function _escape(inp) {
      var esc = "";
      var i;
      if (typeof inp === "string") {
        for (i = 0; i < inp.length; i++) {
          switch (inp[i]) {
            case "*":
              esc += "\\2a";
              break;
            case "(":
              esc += "\\28";
              break;
            case ")":
              esc += "\\29";
              break;
            case "\\":
              esc += "\\5c";
              break;
            case "\0":
              esc += "\\00";
              break;
            default:
              esc += inp[i];
              break;
          }
        }
        return esc;
      } else {
        assert.buffer(inp, "input must be string or Buffer");
        for (i = 0; i < inp.length; i++) {
          if (inp[i] < 16) {
            esc += "\\0" + inp[i].toString(16);
          } else {
            esc += "\\" + inp[i].toString(16);
          }
        }
        return esc;
      }
    }
    function testValues(rule, value, allMatch) {
      if (Array.isArray(value)) {
        var i;
        if (allMatch) {
          for (i = 0; i < value.length; i++) {
            if (!rule(value[i])) {
              return false;
            }
          }
          return true;
        } else {
          for (i = 0; i < value.length; i++) {
            if (rule(value[i])) {
              return true;
            }
          }
          return false;
        }
      } else {
        return rule(value);
      }
    }
    function getAttrValue(obj, attr, strictCase) {
      assert.object(obj);
      assert.string(attr);
      if (obj.hasOwnProperty(attr)) {
        return obj[attr];
      } else if (strictCase) {
        return void 0;
      }
      var lower = attr.toLowerCase();
      var result;
      Object.getOwnPropertyNames(obj).some(function(name) {
        if (name.toLowerCase() === lower) {
          result = obj[name];
          return true;
        }
        return false;
      });
      return result;
    }
    function Filter() {
    }
    Filter.prototype.forEach = function forEach(cb) {
      if (this.filter) {
        this.filter.forEach(cb);
      } else if (this.filters) {
        this.filters.forEach(function(item) {
          item.forEach(cb);
        });
      }
      cb(this);
    };
    Filter.prototype.map = function map2(cb) {
      var child;
      if (this.filter) {
        child = this.filter.map(cb);
        if (child === null) {
          return null;
        } else {
          this.filter = child;
        }
      } else if (this.filters) {
        child = this.filters.map(function(item) {
          return item.map(cb);
        }).filter(function(item) {
          return item !== null;
        });
        if (child.length === 0) {
          return null;
        } else {
          this.filters = child;
        }
      }
      return cb(this);
    };
    module.exports = {
      escape: _escape,
      testValues,
      getAttrValue,
      Filter
    };
  }
});

// node_modules/ldap-filter/lib/and_filter.js
var require_and_filter = __commonJS({
  "node_modules/ldap-filter/lib/and_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function toJSON(filter2) {
      return filter2.json;
    }
    function AndFilter(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalArrayOfObject(options.filters, "options.filters");
      this.filters = options.filters ? options.filters.slice() : [];
    }
    util.inherits(AndFilter, helpers.Filter);
    Object.defineProperties(AndFilter.prototype, {
      type: {
        get: function getType() {
          return "and";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "And",
            filters: this.filters.map(toJSON)
          };
        },
        configurable: false
      }
    });
    AndFilter.prototype.toString = function toString() {
      var str = "(&";
      this.filters.forEach(function(f) {
        str += f.toString();
      });
      str += ")";
      return str;
    };
    AndFilter.prototype.matches = function matches(target, strictAttrCase) {
      assert.object(target, "target");
      if (this.filters.length === 0) {
        return true;
      }
      for (var i = 0; i < this.filters.length; i++) {
        if (!this.filters[i].matches(target, strictAttrCase))
          return false;
      }
      return true;
    };
    AndFilter.prototype.addFilter = function addFilter(filter2) {
      assert.object(filter2, "filter");
      this.filters.push(filter2);
    };
    module.exports = AndFilter;
  }
});

// node_modules/ldap-filter/lib/approx_filter.js
var require_approx_filter = __commonJS({
  "node_modules/ldap-filter/lib/approx_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function ApproximateFilter(options) {
      assert.optionalObject(options);
      if (options) {
        assert.string(options.attribute, "options.attribute");
        assert.string(options.value, "options.value");
        this.attribute = options.attribute;
        this.value = options.value;
      }
    }
    util.inherits(ApproximateFilter, helpers.Filter);
    Object.defineProperties(ApproximateFilter.prototype, {
      type: {
        get: function getType() {
          return "approx";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "ApproximateMatch",
            attribute: this.attribute,
            value: this.value
          };
        },
        configurable: false
      }
    });
    ApproximateFilter.prototype.toString = function toString() {
      return "(" + helpers.escape(this.attribute) + "~=" + helpers.escape(this.value) + ")";
    };
    ApproximateFilter.prototype.matches = function matches() {
      throw new Error("approx match implementation missing");
    };
    module.exports = ApproximateFilter;
  }
});

// node_modules/ldap-filter/lib/equality_filter.js
var require_equality_filter = __commonJS({
  "node_modules/ldap-filter/lib/equality_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function EqualityFilter(options) {
      assert.optionalObject(options);
      if (options) {
        assert.string(options.attribute, "options.attribute");
        this.attribute = options.attribute;
        if (options.raw) {
          this.raw = options.raw;
        } else {
          this.raw = new Buffer(options.value);
        }
      } else {
        this.raw = new Buffer(0);
      }
    }
    util.inherits(EqualityFilter, helpers.Filter);
    Object.defineProperties(EqualityFilter.prototype, {
      type: {
        get: function getType() {
          return "equal";
        },
        configurable: false
      },
      value: {
        get: function getValue() {
          return Buffer.isBuffer(this.raw) ? this.raw.toString() : this.raw;
        },
        set: function setValue(val) {
          if (typeof val === "string") {
            this.raw = new Buffer(val);
          } else if (Buffer.isBuffer(val)) {
            this.raw = new Buffer(val.length);
            val.copy(this.raw);
          } else {
            this.raw = val;
          }
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "EqualityMatch",
            attribute: this.attribute,
            value: this.value
          };
        },
        configurable: false
      }
    });
    EqualityFilter.prototype.toString = function toString() {
      var value, decoded, validate;
      if (Buffer.isBuffer(this.raw)) {
        value = this.raw;
        decoded = this.raw.toString("utf8");
        validate = new Buffer(decoded, "utf8");
        if (validate.length === this.raw.length) {
          value = decoded;
        }
      } else if (typeof this.raw === "string") {
        value = this.raw;
      } else {
        throw new Error("invalid value type");
      }
      return "(" + helpers.escape(this.attribute) + "=" + helpers.escape(value) + ")";
    };
    EqualityFilter.prototype.matches = function matches(target, strictAttrCase) {
      assert.object(target, "target");
      var tv = helpers.getAttrValue(target, this.attribute, strictAttrCase);
      var value = this.value;
      return helpers.testValues(function(v) {
        return value === v;
      }, tv);
    };
    module.exports = EqualityFilter;
  }
});

// node_modules/ldap-filter/lib/ext_filter.js
var require_ext_filter = __commonJS({
  "node_modules/ldap-filter/lib/ext_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function ExtensibleFilter(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalString(options.rule, "options.rule");
      assert.optionalString(options.matchType, "options.matchType");
      assert.optionalString(options.attribute, "options.attribute");
      assert.optionalString(options.value, "options.value");
      if (options.matchType !== void 0) {
        this.matchType = options.matchType;
      } else {
        this.matchType = options.attribute;
      }
      this.dnAttributes = options.dnAttributes || false;
      this.rule = options.rule;
      this.value = options.value !== void 0 ? options.value : "";
    }
    util.inherits(ExtensibleFilter, helpers.Filter);
    Object.defineProperties(ExtensibleFilter.prototype, {
      type: {
        get: function getType() {
          return "ext";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "ExtensibleMatch",
            matchRule: this.rule,
            matchType: this.matchType,
            matchValue: this.value,
            dnAttributes: this.dnAttributes
          };
        },
        configurable: false
      },
      matchingRule: {
        get: function getRule() {
          return this.rule;
        },
        configurable: false
      },
      matchValue: {
        get: function getValue() {
          return this.value;
        },
        configurable: false
      },
      attribute: {
        get: function getAttribute() {
          return this.matchType;
        },
        set: function setAttribute(val) {
          this.matchType = val;
        },
        configurable: false
      }
    });
    ExtensibleFilter.prototype.toString = function toString() {
      var str = "(";
      if (this.matchType)
        str += this.matchType;
      str += ":";
      if (this.dnAttributes)
        str += "dn:";
      if (this.rule)
        str += this.rule + ":";
      return str + "=" + this.value + ")";
    };
    ExtensibleFilter.prototype.matches = function matches() {
      throw new Error("ext match implementation missing");
    };
    module.exports = ExtensibleFilter;
  }
});

// node_modules/ldap-filter/lib/ge_filter.js
var require_ge_filter = __commonJS({
  "node_modules/ldap-filter/lib/ge_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function GreaterThanEqualsFilter(options) {
      assert.optionalObject(options);
      if (options) {
        assert.string(options.attribute, "options.attribute");
        assert.string(options.value, "options.value");
        this.attribute = options.attribute;
        this.value = options.value;
      }
    }
    util.inherits(GreaterThanEqualsFilter, helpers.Filter);
    Object.defineProperties(GreaterThanEqualsFilter.prototype, {
      type: {
        get: function getType() {
          return "ge";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "GreaterThanEqualsMatch",
            attribute: this.attribute,
            value: this.value
          };
        },
        configurable: false
      }
    });
    GreaterThanEqualsFilter.prototype.toString = function toString() {
      return "(" + helpers.escape(this.attribute) + ">=" + helpers.escape(this.value) + ")";
    };
    GreaterThanEqualsFilter.prototype.matches = function(target, strictAttrCase) {
      assert.object(target, "target");
      var tv = helpers.getAttrValue(target, this.attribute, strictAttrCase);
      var value = this.value;
      return helpers.testValues(function(v) {
        return value <= v;
      }, tv);
    };
    module.exports = GreaterThanEqualsFilter;
  }
});

// node_modules/ldap-filter/lib/le_filter.js
var require_le_filter = __commonJS({
  "node_modules/ldap-filter/lib/le_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function LessThanEqualsFilter(options) {
      assert.optionalObject(options);
      if (options) {
        assert.string(options.attribute, "options.attribute");
        assert.string(options.value, "options.attribute");
        this.attribute = options.attribute;
        this.value = options.value;
      }
    }
    util.inherits(LessThanEqualsFilter, helpers.Filter);
    Object.defineProperties(LessThanEqualsFilter.prototype, {
      type: {
        get: function getType() {
          return "le";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "LessThanEqualsMatch",
            attribute: this.attribute,
            value: this.value
          };
        },
        configurable: false
      }
    });
    LessThanEqualsFilter.prototype.toString = function toString() {
      return "(" + helpers.escape(this.attribute) + "<=" + helpers.escape(this.value) + ")";
    };
    LessThanEqualsFilter.prototype.matches = function(target, strictAttrCase) {
      assert.object(target, "target");
      var tv = helpers.getAttrValue(target, this.attribute, strictAttrCase);
      var value = this.value;
      return helpers.testValues(function(v) {
        return value >= v;
      }, tv);
    };
    module.exports = LessThanEqualsFilter;
  }
});

// node_modules/ldap-filter/lib/not_filter.js
var require_not_filter = __commonJS({
  "node_modules/ldap-filter/lib/not_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function NotFilter(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalObject(options.filter, "options.filter");
      this.filter = options.filter || {};
    }
    util.inherits(NotFilter, helpers.Filter);
    Object.defineProperties(NotFilter.prototype, {
      type: {
        get: function getType() {
          return "not";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "Not",
            filter: this.filter.json
          };
        },
        configurable: false
      }
    });
    NotFilter.prototype.setFilter = function setFilter(filter2) {
      assert.object(filter2, "filter");
      this.filter = filter2;
    };
    NotFilter.prototype.toString = function toString() {
      return "(!" + this.filter.toString() + ")";
    };
    NotFilter.prototype.matches = function matches(target, strictAttrCase) {
      return !this.filter.matches(target, strictAttrCase);
    };
    module.exports = NotFilter;
  }
});

// node_modules/ldap-filter/lib/or_filter.js
var require_or_filter = __commonJS({
  "node_modules/ldap-filter/lib/or_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function toJSON(filter2) {
      return filter2.json;
    }
    function OrFilter(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalArrayOfObject(options.filters);
      this.filters = options.filters ? options.filters.slice() : [];
    }
    util.inherits(OrFilter, helpers.Filter);
    Object.defineProperties(OrFilter.prototype, {
      type: {
        get: function getType() {
          return "or";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "Or",
            filters: this.filters.map(toJSON)
          };
        },
        configurable: false
      }
    });
    OrFilter.prototype.toString = function toString() {
      var str = "(|";
      this.filters.forEach(function(f) {
        str += f.toString();
      });
      str += ")";
      return str;
    };
    OrFilter.prototype.matches = function matches(target, strictAttrCase) {
      assert.object(target, "target");
      for (var i = 0; i < this.filters.length; i++) {
        if (this.filters[i].matches(target, strictAttrCase))
          return true;
      }
      return false;
    };
    OrFilter.prototype.addFilter = function addFilter(filter2) {
      assert.object(filter2, "filter");
      this.filters.push(filter2);
    };
    module.exports = OrFilter;
  }
});

// node_modules/ldap-filter/lib/presence_filter.js
var require_presence_filter = __commonJS({
  "node_modules/ldap-filter/lib/presence_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function PresenceFilter(options) {
      assert.optionalObject(options);
      options = options || {};
      assert.optionalString(options.attribute);
      this.attribute = options.attribute;
    }
    util.inherits(PresenceFilter, helpers.Filter);
    Object.defineProperties(PresenceFilter.prototype, {
      type: {
        get: function getType() {
          return "present";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "PresenceMatch",
            attribute: this.attribute
          };
        },
        configurable: false
      }
    });
    PresenceFilter.prototype.toString = function toString() {
      return "(" + helpers.escape(this.attribute) + "=*)";
    };
    PresenceFilter.prototype.matches = function matches(target, strictAttrCase) {
      assert.object(target, "target");
      var value = helpers.getAttrValue(target, this.attribute, strictAttrCase);
      return value !== void 0 && value !== null;
    };
    module.exports = PresenceFilter;
  }
});

// node_modules/ldap-filter/lib/substr_filter.js
var require_substr_filter = __commonJS({
  "node_modules/ldap-filter/lib/substr_filter.js"(exports, module) {
    var util = require_util();
    var assert = require_assert2();
    var helpers = require_helpers();
    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    function SubstringFilter(options) {
      assert.optionalObject(options);
      if (options) {
        assert.string(options.attribute, "options.attribute");
        this.attribute = options.attribute;
        this.initial = options.initial;
        this.any = options.any ? options.any.slice(0) : [];
        this.final = options.final;
      } else {
        this.any = [];
      }
    }
    util.inherits(SubstringFilter, helpers.Filter);
    Object.defineProperties(SubstringFilter.prototype, {
      type: {
        get: function getType() {
          return "substring";
        },
        configurable: false
      },
      json: {
        get: function getJson() {
          return {
            type: "SubstringMatch",
            initial: this.initial,
            any: this.any,
            final: this.final
          };
        },
        configurable: false
      }
    });
    SubstringFilter.prototype.toString = function toString() {
      var str = "(" + helpers.escape(this.attribute) + "=";
      if (this.initial)
        str += helpers.escape(this.initial);
      str += "*";
      this.any.forEach(function(s) {
        str += helpers.escape(s) + "*";
      });
      if (this.final)
        str += helpers.escape(this.final);
      str += ")";
      return str;
    };
    SubstringFilter.prototype.matches = function matches(target, strictAttrCase) {
      assert.object(target, "target");
      var tv = helpers.getAttrValue(target, this.attribute, strictAttrCase);
      if (tv !== void 0 && tv !== null) {
        var re = "";
        if (this.initial)
          re += "^" + escapeRegExp(this.initial) + ".*";
        this.any.forEach(function(s) {
          re += escapeRegExp(s) + ".*";
        });
        if (this.final)
          re += escapeRegExp(this.final) + "$";
        var matcher = new RegExp(re);
        return helpers.testValues(function(v) {
          return matcher.test(v);
        }, tv);
      }
      return false;
    };
    module.exports = SubstringFilter;
  }
});

// node_modules/ldap-filter/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/ldap-filter/lib/index.js"(exports, module) {
    var assert = require_assert2();
    var helpers = require_helpers();
    var AndFilter = require_and_filter();
    var ApproximateFilter = require_approx_filter();
    var EqualityFilter = require_equality_filter();
    var ExtensibleFilter = require_ext_filter();
    var GreaterThanEqualsFilter = require_ge_filter();
    var LessThanEqualsFilter = require_le_filter();
    var NotFilter = require_not_filter();
    var OrFilter = require_or_filter();
    var PresenceFilter = require_presence_filter();
    var SubstringFilter = require_substr_filter();
    var attrRegex = /^[-_a-zA-Z0-9]+/;
    var hexRegex = /^[a-fA-F0-9]{2}$/;
    function escapeValue(str) {
      var cur = 0;
      var len = str.length;
      var out = "";
      while (cur < len) {
        var c = str[cur];
        switch (c) {
          case "(":
            throw new Error("illegal unescaped char: " + c);
          case "\\":
            var val = str.substr(cur + 1, 2);
            if (val.match(hexRegex) === null) {
              throw new Error("invalid escaped char");
            }
            out += String.fromCharCode(parseInt(val, 16));
            cur += 3;
            break;
          default:
            out += c;
            cur++;
            break;
        }
      }
      return out;
    }
    function escapeSubstr(str) {
      var fields = str.split("*");
      var out = {};
      assert.ok(fields.length > 1, "wildcard missing");
      out.initial = escapeValue(fields.shift());
      out.final = escapeValue(fields.pop());
      out.any = fields.map(escapeValue);
      return out;
    }
    function parseExt(attr, str) {
      var fields = str.split(":");
      var res = {
        attribute: attr
      };
      var out;
      assert.ok(fields.length > 1, "invalid ext filter");
      fields.shift();
      if (fields[0].toLowerCase() === "dn") {
        res.dnAttributes = true;
        fields.shift();
      }
      if (fields.length !== 0 && fields[0][0] !== "=") {
        res.rule = fields.shift();
      }
      if (fields.length === 0 || fields[0][0] !== "=") {
        throw new Error("missing := in ext filter");
      }
      str = fields.join(":").substr(1);
      res.value = escapeValue(str);
      out = new ExtensibleFilter(res);
      if (str.indexOf("*") !== -1) {
        var subres = escapeSubstr(str);
        out.initial = subres.initial;
        out.any = subres.any;
        out.final = subres.final;
      }
      return out;
    }
    function parseExpr(str) {
      var attr, match, remain;
      if (str[0] === ":") {
        attr = "";
        remain = str;
      } else if ((match = str.match(attrRegex)) !== null) {
        attr = match[0];
        remain = str.substr(attr.length);
      } else {
        throw new Error("invalid attribute name");
      }
      if (remain === "=*") {
        return new PresenceFilter({
          attribute: attr
        });
      } else if (remain[0] === "=") {
        remain = remain.substr(1);
        if (remain.indexOf("*") !== -1) {
          var val = escapeSubstr(remain);
          return new SubstringFilter({
            attribute: attr,
            initial: val.initial,
            any: val.any,
            final: val.final
          });
        } else {
          return new EqualityFilter({
            attribute: attr,
            value: escapeValue(remain)
          });
        }
      } else if (remain[0] === ">" && remain[1] === "=") {
        return new GreaterThanEqualsFilter({
          attribute: attr,
          value: escapeValue(remain.substr(2))
        });
      } else if (remain[0] === "<" && remain[1] === "=") {
        return new LessThanEqualsFilter({
          attribute: attr,
          value: escapeValue(remain.substr(2))
        });
      } else if (remain[0] === "~" && remain[1] === "=") {
        return new ApproximateFilter({
          attribute: attr,
          value: escapeValue(remain.substr(2))
        });
      } else if (remain[0] === ":") {
        return parseExt(attr, remain);
      }
      throw new Error("invalid expression");
    }
    function parseFilter(str, start) {
      var cur = start;
      var len = str.length;
      var res, end, output, children = [];
      if (str[cur++] !== "(") {
        throw new Error("missing paren");
      }
      if (str[cur] === "&") {
        cur++;
        do {
          res = parseFilter(str, cur);
          children.push(res.filter);
          cur = res.end + 1;
        } while (cur < len && str[cur] !== ")");
        output = new AndFilter({ filters: children });
      } else if (str[cur] === "|") {
        cur++;
        do {
          res = parseFilter(str, cur);
          children.push(res.filter);
          cur = res.end + 1;
        } while (cur < len && str[cur] !== ")");
        output = new OrFilter({ filters: children });
      } else if (str[cur] === "!") {
        res = parseFilter(str, cur + 1);
        output = new NotFilter({ filter: res.filter });
        cur = res.end + 1;
        assert.equal(str[cur], ")", "unbalanced parens");
      } else {
        end = str.indexOf(")", cur);
        assert.notEqual(end, -1, "unbalanced parens");
        output = parseExpr(str.substr(cur, end - cur));
        cur = end;
      }
      if (cur >= len) {
        throw new Error("unbalanced parens");
      }
      return {
        end: cur,
        filter: output
      };
    }
    module.exports = {
      parse: function(str) {
        assert.string(str, "input must be string");
        assert.ok(str.length > 0, "input string cannot be empty");
        if (str.charAt(0) !== "(") {
          str = "(" + str + ")";
        }
        var parsed = parseFilter(str, 0);
        var lastIdx = str.length - 1;
        if (parsed.end < lastIdx) {
          throw new Error("unbalanced parens");
        }
        return parsed.filter;
      },
      // Helper utilties for writing custom matchers
      testValues: helpers.testValues,
      getAttrValue: helpers.getAttrValue,
      // Filter definitions
      AndFilter,
      ApproximateFilter,
      EqualityFilter,
      ExtensibleFilter,
      GreaterThanEqualsFilter,
      LessThanEqualsFilter,
      NotFilter,
      OrFilter,
      PresenceFilter,
      SubstringFilter
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/filter.js
var require_filter = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/filter.js"(exports, module) {
    var Protocol = require_protocol();
    var TYPES = {
      and: Protocol.FILTER_AND,
      or: Protocol.FILTER_OR,
      not: Protocol.FILTER_NOT,
      equal: Protocol.FILTER_EQUALITY,
      substring: Protocol.FILTER_SUBSTRINGS,
      ge: Protocol.FILTER_GE,
      le: Protocol.FILTER_LE,
      present: Protocol.FILTER_PRESENT,
      approx: Protocol.FILTER_APPROX,
      ext: Protocol.FILTER_EXT
    };
    function isFilter(filter2) {
      if (!filter2 || typeof filter2 !== "object") {
        return false;
      }
      if (typeof filter2.toBer === "function" && typeof filter2.matches === "function" && TYPES[filter2.type] !== void 0) {
        return true;
      }
      return false;
    }
    function isBerWriter(ber) {
      return Boolean(
        ber && typeof ber === "object" && typeof ber.startSequence === "function" && typeof ber.endSequence === "function"
      );
    }
    function mixin(target) {
      target.prototype.toBer = function toBer(ber) {
        if (isBerWriter(ber) === false) {
          throw new TypeError("ber (BerWriter) required");
        }
        ber.startSequence(TYPES[this.type]);
        ber = this._toBer(ber);
        ber.endSequence();
        return ber;
      };
    }
    module.exports = {
      isFilter,
      mixin
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/and_filter.js
var require_and_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/and_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function AndFilter(options) {
      parents.AndFilter.call(this, options);
    }
    util.inherits(AndFilter, parents.AndFilter);
    Filter.mixin(AndFilter);
    module.exports = AndFilter;
    AndFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      this.filters.forEach(function(f) {
        ber = f.toBer(ber);
      });
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/approx_filter.js
var require_approx_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/approx_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function ApproximateFilter(options) {
      parents.ApproximateFilter.call(this, options);
    }
    util.inherits(ApproximateFilter, parents.ApproximateFilter);
    Filter.mixin(ApproximateFilter);
    module.exports = ApproximateFilter;
    ApproximateFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.readString().toLowerCase();
      this.value = ber.readString();
      return true;
    };
    ApproximateFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.attribute);
      ber.writeString(this.value);
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/equality_filter.js
var require_equality_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/equality_filter.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var ASN1 = require_lib().Ber;
    var parents = require_lib2();
    var Filter = require_filter();
    function EqualityFilter(options) {
      parents.EqualityFilter.call(this, options);
    }
    util.inherits(EqualityFilter, parents.EqualityFilter);
    Filter.mixin(EqualityFilter);
    module.exports = EqualityFilter;
    EqualityFilter.prototype.matches = function(target, strictAttrCase) {
      assert.object(target, "target");
      const tv = parents.getAttrValue(target, this.attribute, strictAttrCase);
      let value = this.value;
      if (this.attribute.toLowerCase() === "objectclass") {
        value = value.toLowerCase();
        return parents.testValues(function(v) {
          return value === v.toLowerCase();
        }, tv);
      } else {
        return parents.testValues(function(v) {
          return value === v;
        }, tv);
      }
    };
    EqualityFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.readString().toLowerCase();
      this.value = ber.readString(ASN1.OctetString, true);
      if (this.attribute === "objectclass") {
        this.value = this.value.toLowerCase();
      }
      return true;
    };
    EqualityFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.attribute);
      ber.writeBuffer(this.raw, ASN1.OctetString);
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/ext_filter.js
var require_ext_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/ext_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function ExtensibleFilter(options) {
      parents.ExtensibleFilter.call(this, options);
    }
    util.inherits(ExtensibleFilter, parents.ExtensibleFilter);
    Filter.mixin(ExtensibleFilter);
    module.exports = ExtensibleFilter;
    ExtensibleFilter.prototype.parse = function(ber) {
      const end = ber.offset + ber.length;
      while (ber.offset < end) {
        const tag = ber.peek();
        switch (tag) {
          case 129:
            this.rule = ber.readString(tag);
            break;
          case 130:
            this.matchType = ber.readString(tag);
            break;
          case 131:
            this.value = ber.readString(tag);
            break;
          case 132:
            this.dnAttributes = ber.readBoolean(tag);
            break;
          default:
            throw new Error("Invalid ext_match filter type: 0x" + tag.toString(16));
        }
      }
      return true;
    };
    ExtensibleFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      if (this.rule) {
        ber.writeString(this.rule, 129);
      }
      if (this.matchType) {
        ber.writeString(this.matchType, 130);
      }
      ber.writeString(this.value, 131);
      if (this.dnAttributes) {
        ber.writeBoolean(this.dnAttributes, 132);
      }
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/ge_filter.js
var require_ge_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/ge_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function GreaterThanEqualsFilter(options) {
      parents.GreaterThanEqualsFilter.call(this, options);
    }
    util.inherits(GreaterThanEqualsFilter, parents.GreaterThanEqualsFilter);
    Filter.mixin(GreaterThanEqualsFilter);
    module.exports = GreaterThanEqualsFilter;
    GreaterThanEqualsFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.readString().toLowerCase();
      this.value = ber.readString();
      return true;
    };
    GreaterThanEqualsFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.attribute);
      ber.writeString(this.value);
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/le_filter.js
var require_le_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/le_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function LessThanEqualsFilter(options) {
      parents.LessThanEqualsFilter.call(this, options);
    }
    util.inherits(LessThanEqualsFilter, parents.LessThanEqualsFilter);
    Filter.mixin(LessThanEqualsFilter);
    module.exports = LessThanEqualsFilter;
    LessThanEqualsFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.readString().toLowerCase();
      this.value = ber.readString();
      return true;
    };
    LessThanEqualsFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.attribute);
      ber.writeString(this.value);
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/not_filter.js
var require_not_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/not_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function NotFilter(options) {
      parents.NotFilter.call(this, options);
    }
    util.inherits(NotFilter, parents.NotFilter);
    Filter.mixin(NotFilter);
    module.exports = NotFilter;
    NotFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      return this.filter.toBer(ber);
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/or_filter.js
var require_or_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/or_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function OrFilter(options) {
      parents.OrFilter.call(this, options);
    }
    util.inherits(OrFilter, parents.OrFilter);
    Filter.mixin(OrFilter);
    module.exports = OrFilter;
    OrFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      this.filters.forEach(function(f) {
        ber = f.toBer(ber);
      });
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/presence_filter.js
var require_presence_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/presence_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function PresenceFilter(options) {
      parents.PresenceFilter.call(this, options);
    }
    util.inherits(PresenceFilter, parents.PresenceFilter);
    Filter.mixin(PresenceFilter);
    module.exports = PresenceFilter;
    PresenceFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.buffer.slice(0, ber.length).toString("utf8").toLowerCase();
      ber._offset += ber.length;
      return true;
    };
    PresenceFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      for (let i = 0; i < this.attribute.length; i++) {
        ber.writeByte(this.attribute.charCodeAt(i));
      }
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/substr_filter.js
var require_substr_filter2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/substr_filter.js"(exports, module) {
    var assert = require_assert();
    var util = require_util();
    var parents = require_lib2();
    var Filter = require_filter();
    function SubstringFilter(options) {
      parents.SubstringFilter.call(this, options);
    }
    util.inherits(SubstringFilter, parents.SubstringFilter);
    Filter.mixin(SubstringFilter);
    module.exports = SubstringFilter;
    SubstringFilter.prototype.parse = function(ber) {
      assert.ok(ber);
      this.attribute = ber.readString().toLowerCase();
      ber.readSequence();
      const end = ber.offset + ber.length;
      while (ber.offset < end) {
        const tag = ber.peek();
        switch (tag) {
          case 128:
            this.initial = ber.readString(tag);
            if (this.attribute === "objectclass") {
              this.initial = this.initial.toLowerCase();
            }
            break;
          case 129: {
            let anyVal = ber.readString(tag);
            if (this.attribute === "objectclass") {
              anyVal = anyVal.toLowerCase();
            }
            this.any.push(anyVal);
            break;
          }
          case 130:
            this.final = ber.readString(tag);
            if (this.attribute === "objectclass") {
              this.final = this.final.toLowerCase();
            }
            break;
          default:
            throw new Error("Invalid substrings filter type: 0x" + tag.toString(16));
        }
      }
      return true;
    };
    SubstringFilter.prototype._toBer = function(ber) {
      assert.ok(ber);
      ber.writeString(this.attribute);
      ber.startSequence();
      if (this.initial) {
        ber.writeString(this.initial, 128);
      }
      if (this.any && this.any.length) {
        this.any.forEach(function(s) {
          ber.writeString(s, 129);
        });
      }
      if (this.final) {
        ber.writeString(this.final, 130);
      }
      ber.endSequence();
      return ber;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/filters/index.js
var require_filters = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/filters/index.js"(exports, module) {
    var assert = require_assert();
    var asn1 = require_lib();
    var parents = require_lib2();
    var Protocol = require_protocol();
    var Filter = require_filter();
    var AndFilter = require_and_filter2();
    var ApproximateFilter = require_approx_filter2();
    var EqualityFilter = require_equality_filter2();
    var ExtensibleFilter = require_ext_filter2();
    var GreaterThanEqualsFilter = require_ge_filter2();
    var LessThanEqualsFilter = require_le_filter2();
    var NotFilter = require_not_filter2();
    var OrFilter = require_or_filter2();
    var PresenceFilter = require_presence_filter2();
    var SubstringFilter = require_substr_filter2();
    var BerReader = asn1.BerReader;
    function _parse(ber) {
      assert.ok(ber);
      function parseSet(f2) {
        const end = ber.offset + ber.length;
        while (ber.offset < end) {
          f2.addFilter(_parse(ber));
        }
      }
      let f;
      const type = ber.readSequence();
      switch (type) {
        case Protocol.FILTER_AND:
          f = new AndFilter();
          parseSet(f);
          break;
        case Protocol.FILTER_APPROX:
          f = new ApproximateFilter();
          f.parse(ber);
          break;
        case Protocol.FILTER_EQUALITY:
          f = new EqualityFilter();
          f.parse(ber);
          return f;
        case Protocol.FILTER_EXT:
          f = new ExtensibleFilter();
          f.parse(ber);
          return f;
        case Protocol.FILTER_GE:
          f = new GreaterThanEqualsFilter();
          f.parse(ber);
          return f;
        case Protocol.FILTER_LE:
          f = new LessThanEqualsFilter();
          f.parse(ber);
          return f;
        case Protocol.FILTER_NOT:
          f = new NotFilter({
            filter: _parse(ber)
          });
          break;
        case Protocol.FILTER_OR:
          f = new OrFilter();
          parseSet(f);
          break;
        case Protocol.FILTER_PRESENT:
          f = new PresenceFilter();
          f.parse(ber);
          break;
        case Protocol.FILTER_SUBSTRINGS:
          f = new SubstringFilter();
          f.parse(ber);
          break;
        default:
          throw new Error("Invalid search filter type: 0x" + type.toString(16));
      }
      assert.ok(f);
      return f;
    }
    function cloneFilter(input) {
      let child;
      if (input.type === "and" || input.type === "or") {
        child = input.filters.map(cloneFilter);
      } else if (input.type === "not") {
        child = cloneFilter(input.filter);
      }
      switch (input.type) {
        case "and":
          return new AndFilter({ filters: child });
        case "or":
          return new OrFilter({ filters: child });
        case "not":
          return new NotFilter({ filter: child });
        case "equal":
          return new EqualityFilter(input);
        case "substring":
          return new SubstringFilter(input);
        case "ge":
          return new GreaterThanEqualsFilter(input);
        case "le":
          return new LessThanEqualsFilter(input);
        case "present":
          return new PresenceFilter(input);
        case "approx":
          return new ApproximateFilter(input);
        case "ext":
          return new ExtensibleFilter(input);
        default:
          throw new Error("invalid filter type:" + input.type);
      }
    }
    function escapedToHex(str) {
      return str.replace(/\\([0-9a-f](?![0-9a-f])|[^0-9a-f]|$)/gi, function(match, p1) {
        if (!p1) {
          return "\\5c";
        }
        const hexCode = p1.charCodeAt(0).toString(16);
        return "\\" + hexCode;
      });
    }
    function parseString(str) {
      const hexStr = escapedToHex(str);
      const generic = parents.parse(hexStr);
      return cloneFilter(generic);
    }
    module.exports = {
      parse: function(ber) {
        if (!ber || !(ber instanceof BerReader)) {
          throw new TypeError("ber (BerReader) required");
        }
        return _parse(ber);
      },
      parseString,
      isFilter: Filter.isFilter,
      AndFilter,
      ApproximateFilter,
      EqualityFilter,
      ExtensibleFilter,
      GreaterThanEqualsFilter,
      LessThanEqualsFilter,
      NotFilter,
      OrFilter,
      PresenceFilter,
      SubstringFilter
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_request.js
var require_search_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var asn1 = require_lib();
    var LDAPMessage = require_message();
    var dn = require_dn();
    var filters = require_filters();
    var Protocol = require_protocol();
    var Ber = asn1.Ber;
    function SearchRequest(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REQ_SEARCH;
      LDAPMessage.call(this, options);
      if (options.baseObject !== void 0) {
        this.baseObject = options.baseObject;
      } else {
        this.baseObject = dn.parse("");
      }
      this.scope = options.scope || "base";
      this.derefAliases = options.derefAliases || Protocol.NEVER_DEREF_ALIASES;
      this.sizeLimit = options.sizeLimit || 0;
      this.timeLimit = options.timeLimit || 0;
      this.typesOnly = options.typesOnly || false;
      this.filter = options.filter || null;
      this.attributes = options.attributes ? options.attributes.slice(0) : [];
    }
    util.inherits(SearchRequest, LDAPMessage);
    Object.defineProperties(SearchRequest.prototype, {
      type: {
        get: function getType() {
          return "SearchRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.baseObject;
        },
        configurable: false
      },
      scope: {
        get: function getScope() {
          switch (this._scope) {
            case Protocol.SCOPE_BASE_OBJECT:
              return "base";
            case Protocol.SCOPE_ONE_LEVEL:
              return "one";
            case Protocol.SCOPE_SUBTREE:
              return "sub";
            default:
              throw new Error(this._scope + " is an invalid search scope");
          }
        },
        set: function setScope(val) {
          if (typeof val === "string") {
            switch (val) {
              case "base":
                this._scope = Protocol.SCOPE_BASE_OBJECT;
                break;
              case "one":
                this._scope = Protocol.SCOPE_ONE_LEVEL;
                break;
              case "sub":
                this._scope = Protocol.SCOPE_SUBTREE;
                break;
              default:
                throw new Error(val + " is an invalid search scope");
            }
          } else {
            this._scope = val;
          }
        },
        configurable: false
      }
    });
    SearchRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      this.baseObject = ber.readString();
      this.scope = ber.readEnumeration();
      this.derefAliases = ber.readEnumeration();
      this.sizeLimit = ber.readInt();
      this.timeLimit = ber.readInt();
      this.typesOnly = ber.readBoolean();
      this.filter = filters.parse(ber);
      if (ber.peek() === 48) {
        ber.readSequence();
        const end = ber.offset + ber.length;
        while (ber.offset < end) {
          this.attributes.push(ber.readString().toLowerCase());
        }
      }
      return true;
    };
    SearchRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      const formattedDN = dn.DN.isDN(this.baseObject) ? this.baseObject.format({ skipSpace: true }) : this.baseObject.toString();
      ber.writeString(formattedDN);
      ber.writeEnumeration(this._scope);
      ber.writeEnumeration(this.derefAliases);
      ber.writeInt(this.sizeLimit);
      ber.writeInt(this.timeLimit);
      ber.writeBoolean(this.typesOnly);
      const f = this.filter || new filters.PresenceFilter({ attribute: "objectclass" });
      ber = f.toBer(ber);
      ber.startSequence(Ber.Sequence | Ber.Constructor);
      if (this.attributes && this.attributes.length) {
        this.attributes.forEach(function(a) {
          ber.writeString(a);
        });
      }
      ber.endSequence();
      return ber;
    };
    SearchRequest.prototype._json = function(j) {
      assert.ok(j);
      j.baseObject = this.baseObject;
      j.scope = this.scope;
      j.derefAliases = this.derefAliases;
      j.sizeLimit = this.sizeLimit;
      j.timeLimit = this.timeLimit;
      j.typesOnly = this.typesOnly;
      j.filter = this.filter.toString();
      j.attributes = this.attributes;
      return j;
    };
    module.exports = SearchRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_entry.js
var require_search_entry = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_entry.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Attribute = require_attribute();
    var Protocol = require_protocol();
    var lassert = require_assert3();
    function SearchEntry(options) {
      options = options || {};
      assert.object(options);
      lassert.optionalStringDN(options.objectName);
      options.protocolOp = Protocol.LDAP_REP_SEARCH_ENTRY;
      LDAPMessage.call(this, options);
      this.objectName = options.objectName || null;
      this.setAttributes(options.attributes || []);
    }
    util.inherits(SearchEntry, LDAPMessage);
    Object.defineProperties(SearchEntry.prototype, {
      type: {
        get: function getType() {
          return "SearchEntry";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return this.objectName;
        },
        configurable: false
      },
      object: {
        get: function getObject() {
          const obj = {
            dn: this.dn.toString(),
            controls: []
          };
          this.attributes.forEach(function(a) {
            if (a.vals && a.vals.length) {
              if (a.vals.length > 1) {
                obj[a.type] = a.vals.slice();
              } else {
                obj[a.type] = a.vals[0];
              }
            } else {
              obj[a.type] = [];
            }
          });
          this.controls.forEach(function(element) {
            obj.controls.push(element.json);
          });
          return obj;
        },
        configurable: false
      },
      raw: {
        get: function getRaw() {
          const obj = {
            dn: this.dn.toString(),
            controls: []
          };
          this.attributes.forEach(function(a) {
            if (a.buffers && a.buffers.length) {
              if (a.buffers.length > 1) {
                obj[a.type] = a.buffers.slice();
              } else {
                obj[a.type] = a.buffers[0];
              }
            } else {
              obj[a.type] = [];
            }
          });
          this.controls.forEach(function(element) {
            obj.controls.push(element.json);
          });
          return obj;
        },
        configurable: false
      }
    });
    SearchEntry.prototype.addAttribute = function(attr) {
      if (!attr || typeof attr !== "object") {
        throw new TypeError("attr (attribute) required");
      }
      this.attributes.push(attr);
    };
    SearchEntry.prototype.toObject = function() {
      return this.object;
    };
    SearchEntry.prototype.fromObject = function(obj) {
      if (typeof obj !== "object") {
        throw new TypeError("object required");
      }
      const self = this;
      if (obj.controls) {
        this.controls = obj.controls;
      }
      if (obj.attributes) {
        obj = obj.attributes;
      }
      this.attributes = [];
      Object.keys(obj).forEach(function(k) {
        self.attributes.push(new Attribute({ type: k, vals: obj[k] }));
      });
      return true;
    };
    SearchEntry.prototype.setAttributes = function(obj) {
      if (typeof obj !== "object") {
        throw new TypeError("object required");
      }
      if (Array.isArray(obj)) {
        obj.forEach(function(a) {
          if (!Attribute.isAttribute(a)) {
            throw new TypeError("entry must be an Array of Attributes");
          }
        });
        this.attributes = obj;
      } else {
        const self = this;
        self.attributes = [];
        Object.keys(obj).forEach(function(k) {
          const attr = new Attribute({ type: k });
          if (Array.isArray(obj[k])) {
            obj[k].forEach(function(v) {
              attr.addValue(v.toString());
            });
          } else {
            attr.addValue(obj[k].toString());
          }
          self.attributes.push(attr);
        });
      }
    };
    SearchEntry.prototype._json = function(j) {
      assert.ok(j);
      j.objectName = this.objectName.toString();
      j.attributes = [];
      this.attributes.forEach(function(a) {
        j.attributes.push(a.json || a);
      });
      return j;
    };
    SearchEntry.prototype._parse = function(ber) {
      assert.ok(ber);
      this.objectName = ber.readString();
      assert.ok(ber.readSequence());
      const end = ber.offset + ber.length;
      while (ber.offset < end) {
        const a = new Attribute();
        a.parse(ber);
        this.attributes.push(a);
      }
      return true;
    };
    SearchEntry.prototype._toBer = function(ber) {
      assert.ok(ber);
      const formattedObjectName = this.objectName.format({ skipSpace: true });
      ber.writeString(formattedObjectName);
      ber.startSequence();
      this.attributes.forEach(function(a) {
        ber = Attribute.toBer(a, ber);
      });
      ber.endSequence();
      return ber;
    };
    module.exports = SearchEntry;
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/url.js
var require_url2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/url.js"(exports, module) {
    "use strict";
    var querystring = require_querystring();
    var url = require_url();
    var dn = require_dn();
    var filter2 = require_filters();
    module.exports = {
      parse: function(urlStr, parseDN) {
        let parsedURL;
        try {
          parsedURL = new url.URL(urlStr);
        } catch (error) {
          throw new TypeError(urlStr + " is an invalid LDAP url (scope)");
        }
        if (!parsedURL.protocol || !(parsedURL.protocol === "ldap:" || parsedURL.protocol === "ldaps:")) {
          throw new TypeError(urlStr + " is an invalid LDAP url (protocol)");
        }
        const u = {
          protocol: parsedURL.protocol,
          hostname: parsedURL.hostname,
          port: parsedURL.port,
          pathname: parsedURL.pathname,
          search: parsedURL.search,
          href: parsedURL.href
        };
        u.secure = u.protocol === "ldaps:";
        if (!u.hostname) {
          u.hostname = "localhost";
        }
        if (!u.port) {
          u.port = u.secure ? 636 : 389;
        } else {
          u.port = parseInt(u.port, 10);
        }
        if (u.pathname) {
          u.pathname = querystring.unescape(u.pathname.substr(1));
          u.DN = parseDN ? dn.parse(u.pathname) : u.pathname;
        }
        if (u.search) {
          u.attributes = [];
          const tmp = u.search.substr(1).split("?");
          if (tmp && tmp.length) {
            if (tmp[0]) {
              tmp[0].split(",").forEach(function(a) {
                u.attributes.push(querystring.unescape(a.trim()));
              });
            }
          }
          if (tmp[1]) {
            if (tmp[1] !== "base" && tmp[1] !== "one" && tmp[1] !== "sub") {
              throw new TypeError(urlStr + " is an invalid LDAP url (scope)");
            }
            u.scope = tmp[1];
          }
          if (tmp[2]) {
            u.filter = querystring.unescape(tmp[2]);
          }
          if (tmp[3]) {
            u.extensions = querystring.unescape(tmp[3]);
          }
          if (!u.scope) {
            u.scope = "base";
          }
          if (!u.filter) {
            u.filter = filter2.parseString("(objectclass=*)");
          } else {
            u.filter = filter2.parseString(u.filter);
          }
        }
        return u;
      }
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_reference.js
var require_search_reference = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_reference.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var Protocol = require_protocol();
    var dn = require_dn();
    var url = require_url2();
    var parseURL = url.parse;
    function SearchReference(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_SEARCH_REF;
      LDAPMessage.call(this, options);
      this.uris = options.uris || [];
    }
    util.inherits(SearchReference, LDAPMessage);
    Object.defineProperties(SearchReference.prototype, {
      type: {
        get: function getType() {
          return "SearchReference";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          return new dn.DN("");
        },
        configurable: false
      },
      object: {
        get: function getObject() {
          return {
            dn: this.dn.toString(),
            uris: this.uris.slice()
          };
        },
        configurable: false
      },
      urls: {
        get: function getUrls() {
          return this.uris;
        },
        set: function setUrls(val) {
          assert.ok(val);
          assert.ok(Array.isArray(val));
          this.uris = val.slice();
        },
        configurable: false
      }
    });
    SearchReference.prototype.toObject = function() {
      return this.object;
    };
    SearchReference.prototype.fromObject = function(obj) {
      if (typeof obj !== "object") {
        throw new TypeError("object required");
      }
      this.uris = obj.uris ? obj.uris.slice() : [];
      return true;
    };
    SearchReference.prototype._json = function(j) {
      assert.ok(j);
      j.uris = this.uris.slice();
      return j;
    };
    SearchReference.prototype._parse = function(ber, length) {
      assert.ok(ber);
      while (ber.offset < length) {
        const _url = ber.readString();
        parseURL(_url);
        this.uris.push(_url);
      }
      return true;
    };
    SearchReference.prototype._toBer = function(ber) {
      assert.ok(ber);
      this.uris.forEach(function(u) {
        ber.writeString(u.href || u);
      });
      return ber;
    };
    module.exports = SearchReference;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_response.js
var require_search_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/search_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPResult = require_result();
    var SearchEntry = require_search_entry();
    var SearchReference = require_search_reference();
    var dtrace = require_dtrace();
    var parseDN = require_dn().parse;
    var parseURL = require_url2().parse;
    var Protocol = require_protocol();
    function SearchResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REP_SEARCH;
      LDAPResult.call(this, options);
      this.attributes = options.attributes ? options.attributes.slice() : [];
      this.notAttributes = [];
      this.sentEntries = 0;
    }
    util.inherits(SearchResponse, LDAPResult);
    SearchResponse.prototype.send = function(entry, nofiltering) {
      if (!entry || typeof entry !== "object") {
        throw new TypeError("entry (SearchEntry) required");
      }
      if (nofiltering === void 0) {
        nofiltering = false;
      }
      if (typeof nofiltering !== "boolean") {
        throw new TypeError("noFiltering must be a boolean");
      }
      const self = this;
      const savedAttrs = {};
      let save = null;
      if (entry instanceof SearchEntry || entry instanceof SearchReference) {
        if (!entry.messageID) {
          entry.messageID = this.messageID;
        }
        if (entry.messageID !== this.messageID) {
          throw new Error("SearchEntry messageID mismatch");
        }
      } else {
        if (!entry.attributes) {
          throw new Error("entry.attributes required");
        }
        const all = self.attributes.indexOf("*") !== -1;
        Object.keys(entry.attributes).forEach(function(a) {
          const _a = a.toLowerCase();
          if (!nofiltering && _a.length && _a[0] === "_") {
            savedAttrs[a] = entry.attributes[a];
            delete entry.attributes[a];
          } else if (!nofiltering && self.notAttributes.indexOf(_a) !== -1) {
            savedAttrs[a] = entry.attributes[a];
            delete entry.attributes[a];
          } else if (all) {
          } else if (self.attributes.length && self.attributes.indexOf(_a) === -1) {
            savedAttrs[a] = entry.attributes[a];
            delete entry.attributes[a];
          }
        });
        save = entry;
        entry = new SearchEntry({
          objectName: typeof save.dn === "string" ? parseDN(save.dn) : save.dn,
          messageID: self.messageID,
          log: self.log
        });
        entry.fromObject(save);
      }
      try {
        this.log.debug("%s: sending:  %j", this.connection.ldap.id, entry.json);
        this.connection.write(entry.toBer());
        this.sentEntries++;
        if (self._dtraceOp && self._dtraceId) {
          dtrace.fire("server-search-entry", function() {
            const c = self.connection || { ldap: {} };
            return [
              self._dtraceId || 0,
              c.remoteAddress || "",
              c.ldap.bindDN ? c.ldap.bindDN.toString() : "",
              self.requestDN ? self.requestDN.toString() : "",
              entry.objectName.toString(),
              entry.attributes.length
            ];
          });
        }
        Object.keys(savedAttrs).forEach(function(k) {
          save.attributes[k] = savedAttrs[k];
        });
      } catch (e) {
        this.log.warn(
          e,
          "%s failure to write message %j",
          this.connection.ldap.id,
          this.json
        );
      }
    };
    SearchResponse.prototype.createSearchEntry = function(object) {
      assert.object(object);
      const entry = new SearchEntry({
        messageID: this.messageID,
        log: this.log,
        objectName: object.objectName || object.dn
      });
      entry.fromObject(object.attributes || object);
      return entry;
    };
    SearchResponse.prototype.createSearchReference = function(uris) {
      if (!uris) {
        throw new TypeError("uris ([string]) required");
      }
      if (!Array.isArray(uris)) {
        uris = [uris];
      }
      for (let i = 0; i < uris.length; i++) {
        if (typeof uris[i] === "string") {
          uris[i] = parseURL(uris[i]);
        }
      }
      const self = this;
      return new SearchReference({
        messageID: self.messageID,
        log: self.log,
        uris
      });
    };
    module.exports = SearchResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/unbind_request.js
var require_unbind_request = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/unbind_request.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_message();
    var dn = require_dn();
    var Protocol = require_protocol();
    var DN = dn.DN;
    var RDN = dn.RDN;
    function UnbindRequest(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = Protocol.LDAP_REQ_UNBIND;
      LDAPMessage.call(this, options);
    }
    util.inherits(UnbindRequest, LDAPMessage);
    Object.defineProperties(UnbindRequest.prototype, {
      type: {
        get: function getType() {
          return "UnbindRequest";
        },
        configurable: false
      },
      _dn: {
        get: function getDN() {
          if (this.connection) {
            return this.connection.ldap.bindDN;
          } else {
            return new DN([new RDN({ cn: "anonymous" })]);
          }
        },
        configurable: false
      }
    });
    UnbindRequest.prototype._parse = function(ber) {
      assert.ok(ber);
      return true;
    };
    UnbindRequest.prototype._toBer = function(ber) {
      assert.ok(ber);
      return ber;
    };
    UnbindRequest.prototype._json = function(j) {
      assert.ok(j);
      return j;
    };
    module.exports = UnbindRequest;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/parser.js
var require_parser = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/parser.js"(exports, module) {
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var assert = require_assert2();
    var asn1 = require_lib();
    var logger = require_logger();
    var AbandonRequest = require_abandon_request();
    var AddRequest = require_add_request();
    var AddResponse = require_add_response();
    var BindRequest = require_bind_request();
    var BindResponse = require_bind_response();
    var CompareRequest = require_compare_request();
    var CompareResponse = require_compare_response();
    var DeleteRequest = require_del_request();
    var DeleteResponse = require_del_response();
    var ExtendedRequest = require_ext_request();
    var ExtendedResponse = require_ext_response();
    var ModifyRequest = require_modify_request();
    var ModifyResponse = require_modify_response();
    var ModifyDNRequest = require_moddn_request();
    var ModifyDNResponse = require_moddn_response();
    var SearchRequest = require_search_request();
    var SearchEntry = require_search_entry();
    var SearchReference = require_search_reference();
    var SearchResponse = require_search_response();
    var UnbindRequest = require_unbind_request();
    var LDAPResult = require_result();
    var Protocol = require_protocol();
    var BerReader = asn1.BerReader;
    function Parser(options = {}) {
      assert.object(options);
      EventEmitter.call(this);
      this.buffer = null;
      this.log = options.log || logger;
    }
    util.inherits(Parser, EventEmitter);
    Parser.prototype.write = function(data) {
      if (!data || !Buffer.isBuffer(data)) {
        throw new TypeError("data (buffer) required");
      }
      let nextMessage = null;
      const self = this;
      function end() {
        if (nextMessage) {
          return self.write(nextMessage);
        }
        return true;
      }
      self.buffer = self.buffer ? Buffer.concat([self.buffer, data]) : data;
      const ber = new BerReader(self.buffer);
      let foundSeq = false;
      try {
        foundSeq = ber.readSequence();
      } catch (e) {
        this.emit("error", e);
      }
      if (!foundSeq || ber.remain < ber.length) {
        return false;
      } else if (ber.remain > ber.length) {
        nextMessage = self.buffer.slice(ber.offset + ber.length);
        ber._size = ber.offset + ber.length;
        assert.equal(ber.remain, ber.length);
      }
      self.buffer = null;
      let message;
      try {
        message = this.getMessage(ber);
        if (!message) {
          return end();
        }
        message.parse(ber);
      } catch (e) {
        this.emit("error", e, message);
        return false;
      }
      this.emit("message", message);
      return end();
    };
    Parser.prototype.getMessage = function(ber) {
      assert.ok(ber);
      const self = this;
      const messageID = ber.readInt();
      const type = ber.readSequence();
      let Message;
      switch (type) {
        case Protocol.LDAP_REQ_ABANDON:
          Message = AbandonRequest;
          break;
        case Protocol.LDAP_REQ_ADD:
          Message = AddRequest;
          break;
        case Protocol.LDAP_REP_ADD:
          Message = AddResponse;
          break;
        case Protocol.LDAP_REQ_BIND:
          Message = BindRequest;
          break;
        case Protocol.LDAP_REP_BIND:
          Message = BindResponse;
          break;
        case Protocol.LDAP_REQ_COMPARE:
          Message = CompareRequest;
          break;
        case Protocol.LDAP_REP_COMPARE:
          Message = CompareResponse;
          break;
        case Protocol.LDAP_REQ_DELETE:
          Message = DeleteRequest;
          break;
        case Protocol.LDAP_REP_DELETE:
          Message = DeleteResponse;
          break;
        case Protocol.LDAP_REQ_EXTENSION:
          Message = ExtendedRequest;
          break;
        case Protocol.LDAP_REP_EXTENSION:
          Message = ExtendedResponse;
          break;
        case Protocol.LDAP_REQ_MODIFY:
          Message = ModifyRequest;
          break;
        case Protocol.LDAP_REP_MODIFY:
          Message = ModifyResponse;
          break;
        case Protocol.LDAP_REQ_MODRDN:
          Message = ModifyDNRequest;
          break;
        case Protocol.LDAP_REP_MODRDN:
          Message = ModifyDNResponse;
          break;
        case Protocol.LDAP_REQ_SEARCH:
          Message = SearchRequest;
          break;
        case Protocol.LDAP_REP_SEARCH_ENTRY:
          Message = SearchEntry;
          break;
        case Protocol.LDAP_REP_SEARCH_REF:
          Message = SearchReference;
          break;
        case Protocol.LDAP_REP_SEARCH:
          Message = SearchResponse;
          break;
        case Protocol.LDAP_REQ_UNBIND:
          Message = UnbindRequest;
          break;
        default:
          this.emit(
            "error",
            new Error("Op 0x" + (type ? type.toString(16) : "??") + " not supported"),
            new LDAPResult({
              messageID,
              protocolOp: type || Protocol.LDAP_REP_EXTENSION
            })
          );
          return false;
      }
      return new Message({
        messageID,
        log: self.log
      });
    };
    module.exports = Parser;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/abandon_response.js
var require_abandon_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/abandon_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var LDAPMessage = require_result();
    function AbandonResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = 0;
      LDAPMessage.call(this, options);
    }
    util.inherits(AbandonResponse, LDAPMessage);
    Object.defineProperties(AbandonResponse.prototype, {
      type: {
        get: function getType() {
          return "AbandonResponse";
        },
        configurable: false
      }
    });
    AbandonResponse.prototype.end = function(_status) {
    };
    AbandonResponse.prototype._json = function(j) {
      return j;
    };
    module.exports = AbandonResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/unbind_response.js
var require_unbind_response = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/unbind_response.js"(exports, module) {
    var assert = require_assert2();
    var util = require_util();
    var dtrace = require_dtrace();
    var LDAPMessage = require_result();
    function UnbindResponse(options) {
      options = options || {};
      assert.object(options);
      options.protocolOp = 0;
      LDAPMessage.call(this, options);
    }
    util.inherits(UnbindResponse, LDAPMessage);
    Object.defineProperties(UnbindResponse.prototype, {
      type: {
        get: function getType() {
          return "UnbindResponse";
        },
        configurable: false
      }
    });
    UnbindResponse.prototype.end = function(_status) {
      assert.ok(this.connection);
      this.log.trace("%s: unbinding!", this.connection.ldap.id);
      this.connection.end();
      const self = this;
      if (self._dtraceOp && self._dtraceId) {
        dtrace.fire("server-" + self._dtraceOp + "-done", function() {
          const c = self.connection || { ldap: {} };
          return [
            self._dtraceId || 0,
            c.remoteAddress || "",
            c.ldap.bindDN ? c.ldap.bindDN.toString() : "",
            self.requestDN ? self.requestDN.toString() : "",
            0,
            ""
          ];
        });
      }
    };
    UnbindResponse.prototype._json = function(j) {
      return j;
    };
    module.exports = UnbindResponse;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/messages/index.js
var require_messages = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/messages/index.js"(exports, module) {
    var LDAPMessage = require_message();
    var LDAPResult = require_result();
    var Parser = require_parser();
    var AbandonRequest = require_abandon_request();
    var AbandonResponse = require_abandon_response();
    var AddRequest = require_add_request();
    var AddResponse = require_add_response();
    var BindRequest = require_bind_request();
    var BindResponse = require_bind_response();
    var CompareRequest = require_compare_request();
    var CompareResponse = require_compare_response();
    var DeleteRequest = require_del_request();
    var DeleteResponse = require_del_response();
    var ExtendedRequest = require_ext_request();
    var ExtendedResponse = require_ext_response();
    var ModifyRequest = require_modify_request();
    var ModifyResponse = require_modify_response();
    var ModifyDNRequest = require_moddn_request();
    var ModifyDNResponse = require_moddn_response();
    var SearchRequest = require_search_request();
    var SearchEntry = require_search_entry();
    var SearchReference = require_search_reference();
    var SearchResponse = require_search_response();
    var UnbindRequest = require_unbind_request();
    var UnbindResponse = require_unbind_response();
    module.exports = {
      LDAPMessage,
      LDAPResult,
      Parser,
      AbandonRequest,
      AbandonResponse,
      AddRequest,
      AddResponse,
      BindRequest,
      BindResponse,
      CompareRequest,
      CompareResponse,
      DeleteRequest,
      DeleteResponse,
      ExtendedRequest,
      ExtendedResponse,
      ModifyRequest,
      ModifyResponse,
      ModifyDNRequest,
      ModifyDNResponse,
      SearchRequest,
      SearchEntry,
      SearchReference,
      SearchResponse,
      UnbindRequest,
      UnbindResponse
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/errors/index.js
var require_errors2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/errors/index.js"(exports, module) {
    "use strict";
    var util = require_util();
    var assert = require_assert2();
    var LDAPResult = require_messages().LDAPResult;
    var CODES = require_codes();
    var ERRORS = [];
    function LDAPError(message, dn, caller) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, caller || LDAPError);
      }
      this.lde_message = message;
      this.lde_dn = dn;
    }
    util.inherits(LDAPError, Error);
    Object.defineProperties(LDAPError.prototype, {
      name: {
        get: function getName() {
          return "LDAPError";
        },
        configurable: false
      },
      code: {
        get: function getCode() {
          return CODES.LDAP_OTHER;
        },
        configurable: false
      },
      message: {
        get: function getMessage() {
          return this.lde_message || this.name;
        },
        set: function setMessage(message) {
          this.lde_message = message;
        },
        configurable: false
      },
      dn: {
        get: function getDN() {
          return this.lde_dn ? this.lde_dn.toString() : "";
        },
        configurable: false
      }
    });
    module.exports = {};
    module.exports.LDAPError = LDAPError;
    Object.keys(CODES).forEach(function(code) {
      module.exports[code] = CODES[code];
      if (code === "LDAP_SUCCESS") {
        return;
      }
      let err = "";
      let msg = "";
      const pieces = code.split("_").slice(1);
      for (let i = 0; i < pieces.length; i++) {
        const lc = pieces[i].toLowerCase();
        const key = lc.charAt(0).toUpperCase() + lc.slice(1);
        err += key;
        msg += key + (i + 1 < pieces.length ? " " : "");
      }
      if (!/\w+Error$/.test(err)) {
        err += "Error";
      }
      module.exports[err] = function(message, dn, caller) {
        LDAPError.call(this, message, dn, caller || module.exports[err]);
      };
      module.exports[err].constructor = module.exports[err];
      util.inherits(module.exports[err], LDAPError);
      Object.defineProperties(module.exports[err].prototype, {
        name: {
          get: function getName() {
            return err;
          },
          configurable: false
        },
        code: {
          get: function getCode() {
            return CODES[code];
          },
          configurable: false
        }
      });
      ERRORS[CODES[code]] = {
        err,
        message: msg
      };
    });
    module.exports.getError = function(res) {
      assert.ok(res instanceof LDAPResult, "res (LDAPResult) required");
      const errObj = ERRORS[res.status];
      const E = module.exports[errObj.err];
      return new E(
        res.errorMessage || errObj.message,
        res.matchedDN || null,
        module.exports.getError
      );
    };
    module.exports.getMessage = function(code) {
      assert.number(code, "code (number) required");
      const errObj = ERRORS[code];
      return errObj && errObj.message ? errObj.message : "";
    };
    function ConnectionError(message) {
      LDAPError.call(this, message, null, ConnectionError);
    }
    util.inherits(ConnectionError, LDAPError);
    module.exports.ConnectionError = ConnectionError;
    Object.defineProperties(ConnectionError.prototype, {
      name: {
        get: function() {
          return "ConnectionError";
        },
        configurable: false
      }
    });
    function AbandonedError(message) {
      LDAPError.call(this, message, null, AbandonedError);
    }
    util.inherits(AbandonedError, LDAPError);
    module.exports.AbandonedError = AbandonedError;
    Object.defineProperties(AbandonedError.prototype, {
      name: {
        get: function() {
          return "AbandonedError";
        },
        configurable: false
      }
    });
    function TimeoutError(message) {
      LDAPError.call(this, message, null, TimeoutError);
    }
    util.inherits(TimeoutError, LDAPError);
    module.exports.TimeoutError = TimeoutError;
    Object.defineProperties(TimeoutError.prototype, {
      name: {
        get: function() {
          return "TimeoutError";
        },
        configurable: false
      }
    });
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/purge.js
var require_purge = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/purge.js"(exports, module) {
    "use strict";
    var { TimeoutError } = require_errors2();
    module.exports = function purge() {
      this.flush(function flushCB(a, b, c, cb) {
        cb(new TimeoutError("request queue timeout"));
      });
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/index.js
var require_request_queue = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/request-queue/index.js"(exports, module) {
    "use strict";
    var enqueue = require_enqueue();
    var flush = require_flush();
    var purge = require_purge();
    module.exports = function requestQueueFactory(options) {
      const opts = Object.assign({}, options);
      const q = {
        size: opts.size > 0 ? opts.size : Infinity,
        timeout: opts.timeout > 0 ? opts.timeout : 0,
        _queue: /* @__PURE__ */ new Set(),
        _timer: null,
        _frozen: false
      };
      q.enqueue = enqueue.bind(q);
      q.flush = flush.bind(q);
      q.purge = purge.bind(q);
      q.freeze = function freeze() {
        this._frozen = true;
      };
      q.thaw = function thaw() {
        this._frozen = false;
      };
      return q;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/constants.js
var require_constants = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      // https://tools.ietf.org/html/rfc4511#section-4.1.1
      // Message identifiers are an integer between (0, maxint).
      MAX_MSGID: Math.pow(2, 31) - 1
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/id-generator.js
var require_id_generator = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/id-generator.js"(exports, module) {
    "use strict";
    var { MAX_MSGID } = require_constants();
    module.exports = function idGeneratorFactory(start = 0) {
      let currentID = start;
      return function nextID() {
        const id = currentID + 1;
        currentID = id >= MAX_MSGID ? 1 : id;
        return currentID;
      };
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/ge-window.js
var require_ge_window = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/ge-window.js"(exports, module) {
    "use strict";
    var { MAX_MSGID } = require_constants();
    module.exports = function geWindow(ref, comp) {
      let max = ref + Math.floor(MAX_MSGID / 2);
      const min = ref;
      if (max >= MAX_MSGID) {
        max = max - MAX_MSGID - 1;
        return comp <= max || comp >= min;
      } else {
        return comp <= max && comp >= min;
      }
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/purge-abandoned.js
var require_purge_abandoned = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/purge-abandoned.js"(exports, module) {
    "use strict";
    var { AbandonedError } = require_errors2();
    var geWindow = require_ge_window();
    module.exports = function purgeAbandoned(msgID, abandoned) {
      abandoned.forEach((val, key) => {
        if (geWindow(val.age, msgID) === false)
          return;
        val.cb(new AbandonedError("client request abandoned"));
        abandoned.delete(key);
      });
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/index.js
var require_message_tracker = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/message-tracker/index.js"(exports, module) {
    "use strict";
    var idGeneratorFactory = require_id_generator();
    var purgeAbandoned = require_purge_abandoned();
    module.exports = function messageTrackerFactory(options) {
      if (Object.prototype.toString.call(options) !== "[object Object]") {
        throw Error("options object is required");
      }
      if (!options.id || typeof options.id !== "string") {
        throw Error("options.id string is required");
      }
      if (!options.parser || Object.prototype.toString.call(options.parser) !== "[object Object]") {
        throw Error("options.parser object is required");
      }
      let currentID = 0;
      const nextID = idGeneratorFactory();
      const messages = /* @__PURE__ */ new Map();
      const abandoned = /* @__PURE__ */ new Map();
      const tracker = {
        id: options.id,
        parser: options.parser
      };
      Object.defineProperty(tracker, "pending", {
        get() {
          return messages.size;
        }
      });
      tracker.abandon = function abandonMessage(msgID) {
        if (messages.has(msgID) === false)
          return false;
        abandoned.set(msgID, {
          age: currentID,
          cb: messages.get(msgID)
        });
        return messages.delete(msgID);
      };
      tracker.fetch = function fetchMessage(msgID) {
        const messageCB = messages.get(msgID);
        if (messageCB) {
          purgeAbandoned(msgID, abandoned);
          return messageCB;
        }
        const abandonedMsg = abandoned.get(msgID);
        if (abandonedMsg) {
          return abandonedMsg.cb;
        }
        return null;
      };
      tracker.purge = function purgeMessages(cb) {
        messages.forEach((val, key) => {
          purgeAbandoned(key, abandoned);
          tracker.remove(key);
          cb(key, val);
        });
      };
      tracker.remove = function removeMessage(msgID) {
        if (messages.delete(msgID) === false) {
          abandoned.delete(msgID);
        }
      };
      tracker.track = function trackMessage(message, callback) {
        currentID = nextID();
        message.messageID = currentID;
        messages.set(currentID, callback);
      };
      return tracker;
    };
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once2);
    module.exports.strict = wrappy(onceStrict);
    once2.proto = once2(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once2(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once2(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/precond/lib/errors.js
var require_errors3 = __commonJS({
  "node_modules/precond/lib/errors.js"(exports, module) {
    var util = require_util();
    function IllegalArgumentError(message) {
      Error.call(this, message);
      this.message = message;
    }
    util.inherits(IllegalArgumentError, Error);
    IllegalArgumentError.prototype.name = "IllegalArgumentError";
    function IllegalStateError(message) {
      Error.call(this, message);
      this.message = message;
    }
    util.inherits(IllegalStateError, Error);
    IllegalStateError.prototype.name = "IllegalStateError";
    module.exports.IllegalStateError = IllegalStateError;
    module.exports.IllegalArgumentError = IllegalArgumentError;
  }
});

// node_modules/precond/lib/checks.js
var require_checks = __commonJS({
  "node_modules/precond/lib/checks.js"(exports, module) {
    var util = require_util();
    var errors = module.exports = require_errors3();
    function failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {
      messageFormat = messageFormat || "";
      var message = util.format.apply(this, [messageFormat].concat(formatArgs));
      var error = new ExceptionConstructor(message);
      Error.captureStackTrace(error, callee);
      throw error;
    }
    function failArgumentCheck(callee, message, formatArgs) {
      failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
    }
    function failStateCheck(callee, message, formatArgs) {
      failCheck(errors.IllegalStateError, callee, message, formatArgs);
    }
    module.exports.checkArgument = function(value, message) {
      if (!value) {
        failArgumentCheck(
          arguments.callee,
          message,
          Array.prototype.slice.call(arguments, 2)
        );
      }
    };
    module.exports.checkState = function(value, message) {
      if (!value) {
        failStateCheck(
          arguments.callee,
          message,
          Array.prototype.slice.call(arguments, 2)
        );
      }
    };
    module.exports.checkIsDef = function(value, message) {
      if (value !== void 0) {
        return value;
      }
      failArgumentCheck(
        arguments.callee,
        message || "Expected value to be defined but was undefined.",
        Array.prototype.slice.call(arguments, 2)
      );
    };
    module.exports.checkIsDefAndNotNull = function(value, message) {
      if (value != null) {
        return value;
      }
      failArgumentCheck(arguments.callee, message || 'Expected value to be defined and not null but got "' + typeOf(value) + '".', Array.prototype.slice.call(arguments, 2));
    };
    function typeOf(value) {
      var s = typeof value;
      if (s == "object") {
        if (!value) {
          return "null";
        } else if (value instanceof Array) {
          return "array";
        }
      }
      return s;
    }
    function typeCheck(expect) {
      return function(value, message) {
        var type = typeOf(value);
        if (type == expect) {
          return value;
        }
        failArgumentCheck(
          arguments.callee,
          message || 'Expected "' + expect + '" but got "' + type + '".',
          Array.prototype.slice.call(arguments, 2)
        );
      };
    }
    module.exports.checkIsString = typeCheck("string");
    module.exports.checkIsArray = typeCheck("array");
    module.exports.checkIsNumber = typeCheck("number");
    module.exports.checkIsBoolean = typeCheck("boolean");
    module.exports.checkIsFunction = typeCheck("function");
    module.exports.checkIsObject = typeCheck("object");
  }
});

// node_modules/precond/index.js
var require_precond = __commonJS({
  "node_modules/precond/index.js"(exports, module) {
    module.exports = require_checks();
  }
});

// node_modules/backoff/lib/backoff.js
var require_backoff = __commonJS({
  "node_modules/backoff/lib/backoff.js"(exports, module) {
    var events = require_events();
    var precond = require_precond();
    var util = require_util();
    function Backoff(backoffStrategy) {
      events.EventEmitter.call(this);
      this.backoffStrategy_ = backoffStrategy;
      this.maxNumberOfRetry_ = -1;
      this.backoffNumber_ = 0;
      this.backoffDelay_ = 0;
      this.timeoutID_ = -1;
      this.handlers = {
        backoff: this.onBackoff_.bind(this)
      };
    }
    util.inherits(Backoff, events.EventEmitter);
    Backoff.prototype.failAfter = function(maxNumberOfRetry) {
      precond.checkArgument(
        maxNumberOfRetry > 0,
        "Expected a maximum number of retry greater than 0 but got %s.",
        maxNumberOfRetry
      );
      this.maxNumberOfRetry_ = maxNumberOfRetry;
    };
    Backoff.prototype.backoff = function(err) {
      precond.checkState(this.timeoutID_ === -1, "Backoff in progress.");
      if (this.backoffNumber_ === this.maxNumberOfRetry_) {
        this.emit("fail", err);
        this.reset();
      } else {
        this.backoffDelay_ = this.backoffStrategy_.next();
        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);
        this.emit("backoff", this.backoffNumber_, this.backoffDelay_, err);
      }
    };
    Backoff.prototype.onBackoff_ = function() {
      this.timeoutID_ = -1;
      this.emit("ready", this.backoffNumber_, this.backoffDelay_);
      this.backoffNumber_++;
    };
    Backoff.prototype.reset = function() {
      this.backoffNumber_ = 0;
      this.backoffStrategy_.reset();
      clearTimeout(this.timeoutID_);
      this.timeoutID_ = -1;
    };
    module.exports = Backoff;
  }
});

// node_modules/backoff/lib/strategy/strategy.js
var require_strategy = __commonJS({
  "node_modules/backoff/lib/strategy/strategy.js"(exports, module) {
    var events = require_events();
    var util = require_util();
    function isDef(value) {
      return value !== void 0 && value !== null;
    }
    function BackoffStrategy(options) {
      options = options || {};
      if (isDef(options.initialDelay) && options.initialDelay < 1) {
        throw new Error("The initial timeout must be greater than 0.");
      } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
        throw new Error("The maximal timeout must be greater than 0.");
      }
      this.initialDelay_ = options.initialDelay || 100;
      this.maxDelay_ = options.maxDelay || 1e4;
      if (this.maxDelay_ <= this.initialDelay_) {
        throw new Error("The maximal backoff delay must be greater than the initial backoff delay.");
      }
      if (isDef(options.randomisationFactor) && (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {
        throw new Error("The randomisation factor must be between 0 and 1.");
      }
      this.randomisationFactor_ = options.randomisationFactor || 0;
    }
    BackoffStrategy.prototype.getMaxDelay = function() {
      return this.maxDelay_;
    };
    BackoffStrategy.prototype.getInitialDelay = function() {
      return this.initialDelay_;
    };
    BackoffStrategy.prototype.next = function() {
      var backoffDelay = this.next_();
      var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;
      var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);
      return randomizedDelay;
    };
    BackoffStrategy.prototype.next_ = function() {
      throw new Error("BackoffStrategy.next_() unimplemented.");
    };
    BackoffStrategy.prototype.reset = function() {
      this.reset_();
    };
    BackoffStrategy.prototype.reset_ = function() {
      throw new Error("BackoffStrategy.reset_() unimplemented.");
    };
    module.exports = BackoffStrategy;
  }
});

// node_modules/backoff/lib/strategy/exponential.js
var require_exponential = __commonJS({
  "node_modules/backoff/lib/strategy/exponential.js"(exports, module) {
    var util = require_util();
    var precond = require_precond();
    var BackoffStrategy = require_strategy();
    function ExponentialBackoffStrategy(options) {
      BackoffStrategy.call(this, options);
      this.backoffDelay_ = 0;
      this.nextBackoffDelay_ = this.getInitialDelay();
      this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;
      if (options && options.factor !== void 0) {
        precond.checkArgument(
          options.factor > 1,
          "Exponential factor should be greater than 1 but got %s.",
          options.factor
        );
        this.factor_ = options.factor;
      }
    }
    util.inherits(ExponentialBackoffStrategy, BackoffStrategy);
    ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;
    ExponentialBackoffStrategy.prototype.next_ = function() {
      this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
      this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
      return this.backoffDelay_;
    };
    ExponentialBackoffStrategy.prototype.reset_ = function() {
      this.backoffDelay_ = 0;
      this.nextBackoffDelay_ = this.getInitialDelay();
    };
    module.exports = ExponentialBackoffStrategy;
  }
});

// node_modules/backoff/lib/strategy/fibonacci.js
var require_fibonacci = __commonJS({
  "node_modules/backoff/lib/strategy/fibonacci.js"(exports, module) {
    var util = require_util();
    var BackoffStrategy = require_strategy();
    function FibonacciBackoffStrategy(options) {
      BackoffStrategy.call(this, options);
      this.backoffDelay_ = 0;
      this.nextBackoffDelay_ = this.getInitialDelay();
    }
    util.inherits(FibonacciBackoffStrategy, BackoffStrategy);
    FibonacciBackoffStrategy.prototype.next_ = function() {
      var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());
      this.nextBackoffDelay_ += this.backoffDelay_;
      this.backoffDelay_ = backoffDelay;
      return backoffDelay;
    };
    FibonacciBackoffStrategy.prototype.reset_ = function() {
      this.nextBackoffDelay_ = this.getInitialDelay();
      this.backoffDelay_ = 0;
    };
    module.exports = FibonacciBackoffStrategy;
  }
});

// node_modules/backoff/lib/function_call.js
var require_function_call = __commonJS({
  "node_modules/backoff/lib/function_call.js"(exports, module) {
    var events = require_events();
    var precond = require_precond();
    var util = require_util();
    var Backoff = require_backoff();
    var FibonacciBackoffStrategy = require_fibonacci();
    function FunctionCall(fn, args, callback) {
      events.EventEmitter.call(this);
      precond.checkIsFunction(fn, "Expected fn to be a function.");
      precond.checkIsArray(args, "Expected args to be an array.");
      precond.checkIsFunction(callback, "Expected callback to be a function.");
      this.function_ = fn;
      this.arguments_ = args;
      this.callback_ = callback;
      this.lastResult_ = [];
      this.numRetries_ = 0;
      this.backoff_ = null;
      this.strategy_ = null;
      this.failAfter_ = -1;
      this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;
      this.state_ = FunctionCall.State_.PENDING;
    }
    util.inherits(FunctionCall, events.EventEmitter);
    FunctionCall.State_ = {
      // Call isn't started yet.
      PENDING: 0,
      // Call is in progress.
      RUNNING: 1,
      // Call completed successfully which means that either the wrapped function
      // returned successfully or the maximal number of backoffs was reached.
      COMPLETED: 2,
      // The call was aborted.
      ABORTED: 3
    };
    FunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {
      return true;
    };
    FunctionCall.prototype.isPending = function() {
      return this.state_ == FunctionCall.State_.PENDING;
    };
    FunctionCall.prototype.isRunning = function() {
      return this.state_ == FunctionCall.State_.RUNNING;
    };
    FunctionCall.prototype.isCompleted = function() {
      return this.state_ == FunctionCall.State_.COMPLETED;
    };
    FunctionCall.prototype.isAborted = function() {
      return this.state_ == FunctionCall.State_.ABORTED;
    };
    FunctionCall.prototype.setStrategy = function(strategy) {
      precond.checkState(this.isPending(), "FunctionCall in progress.");
      this.strategy_ = strategy;
      return this;
    };
    FunctionCall.prototype.retryIf = function(retryPredicate) {
      precond.checkState(this.isPending(), "FunctionCall in progress.");
      this.retryPredicate_ = retryPredicate;
      return this;
    };
    FunctionCall.prototype.getLastResult = function() {
      return this.lastResult_.concat();
    };
    FunctionCall.prototype.getNumRetries = function() {
      return this.numRetries_;
    };
    FunctionCall.prototype.failAfter = function(maxNumberOfRetry) {
      precond.checkState(this.isPending(), "FunctionCall in progress.");
      this.failAfter_ = maxNumberOfRetry;
      return this;
    };
    FunctionCall.prototype.abort = function() {
      if (this.isCompleted() || this.isAborted()) {
        return;
      }
      if (this.isRunning()) {
        this.backoff_.reset();
      }
      this.state_ = FunctionCall.State_.ABORTED;
      this.lastResult_ = [new Error("Backoff aborted.")];
      this.emit("abort");
      this.doCallback_();
    };
    FunctionCall.prototype.start = function(backoffFactory) {
      precond.checkState(!this.isAborted(), "FunctionCall is aborted.");
      precond.checkState(this.isPending(), "FunctionCall already started.");
      var strategy = this.strategy_ || new FibonacciBackoffStrategy();
      this.backoff_ = backoffFactory ? backoffFactory(strategy) : new Backoff(strategy);
      this.backoff_.on("ready", this.doCall_.bind(
        this,
        true
        /* isRetry */
      ));
      this.backoff_.on("fail", this.doCallback_.bind(this));
      this.backoff_.on("backoff", this.handleBackoff_.bind(this));
      if (this.failAfter_ > 0) {
        this.backoff_.failAfter(this.failAfter_);
      }
      this.state_ = FunctionCall.State_.RUNNING;
      this.doCall_(
        false
        /* isRetry */
      );
    };
    FunctionCall.prototype.doCall_ = function(isRetry) {
      if (isRetry) {
        this.numRetries_++;
      }
      var eventArgs = ["call"].concat(this.arguments_);
      events.EventEmitter.prototype.emit.apply(this, eventArgs);
      var callback = this.handleFunctionCallback_.bind(this);
      this.function_.apply(null, this.arguments_.concat(callback));
    };
    FunctionCall.prototype.doCallback_ = function() {
      this.callback_.apply(null, this.lastResult_);
    };
    FunctionCall.prototype.handleFunctionCallback_ = function() {
      if (this.isAborted()) {
        return;
      }
      var args = Array.prototype.slice.call(arguments);
      this.lastResult_ = args;
      events.EventEmitter.prototype.emit.apply(this, ["callback"].concat(args));
      var err = args[0];
      if (err && this.retryPredicate_(err)) {
        this.backoff_.backoff(err);
      } else {
        this.state_ = FunctionCall.State_.COMPLETED;
        this.doCallback_();
      }
    };
    FunctionCall.prototype.handleBackoff_ = function(number, delay, err) {
      this.emit("backoff", number, delay, err);
    };
    module.exports = FunctionCall;
  }
});

// node_modules/backoff/index.js
var require_backoff2 = __commonJS({
  "node_modules/backoff/index.js"(exports, module) {
    var Backoff = require_backoff();
    var ExponentialBackoffStrategy = require_exponential();
    var FibonacciBackoffStrategy = require_fibonacci();
    var FunctionCall = require_function_call();
    module.exports.Backoff = Backoff;
    module.exports.FunctionCall = FunctionCall;
    module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
    module.exports.ExponentialStrategy = ExponentialBackoffStrategy;
    module.exports.fibonacci = function(options) {
      return new Backoff(new FibonacciBackoffStrategy(options));
    };
    module.exports.exponential = function(options) {
      return new Backoff(new ExponentialBackoffStrategy(options));
    };
    module.exports.call = function(fn, vargs, callback) {
      var args = Array.prototype.slice.call(arguments);
      fn = args[0];
      vargs = args.slice(1, args.length - 1);
      callback = args[args.length - 1];
      return new FunctionCall(fn, vargs, callback);
    };
  }
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS({
  "node_modules/extsprintf/lib/extsprintf.js"(exports) {
    var mod_assert = require_assert();
    var mod_util = require_util();
    exports.sprintf = jsSprintf;
    exports.printf = jsPrintf;
    exports.fprintf = jsFprintf;
    function jsSprintf(ofmt) {
      var regex = [
        "([^%]*)",
        /* normal text */
        "%",
        /* start of format */
        "(['\\-+ #0]*?)",
        /* flags (optional) */
        "([1-9]\\d*)?",
        /* width (optional) */
        "(\\.([1-9]\\d*))?",
        /* precision (optional) */
        "[lhjztL]*?",
        /* length mods (ignored) */
        "([diouxXfFeEgGaAcCsSp%jr])"
        /* conversion */
      ].join("");
      var re = new RegExp(regex);
      var args = Array.prototype.slice.call(arguments, 1);
      var fmt = ofmt;
      var flags, width, precision, conversion;
      var left, pad, sign, arg, match;
      var ret = "";
      var argn = 1;
      var posn = 0;
      var convposn;
      var curconv;
      mod_assert.equal(
        "string",
        typeof fmt,
        "first argument must be a format string"
      );
      while ((match = re.exec(fmt)) !== null) {
        ret += match[1];
        fmt = fmt.substring(match[0].length);
        curconv = match[0].substring(match[1].length);
        convposn = posn + match[1].length + 1;
        posn += match[0].length;
        flags = match[2] || "";
        width = match[3] || 0;
        precision = match[4] || "";
        conversion = match[6];
        left = false;
        sign = false;
        pad = " ";
        if (conversion == "%") {
          ret += "%";
          continue;
        }
        if (args.length === 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "has no matching argument (too few arguments passed)"
          );
        }
        arg = args.shift();
        argn++;
        if (flags.match(/[\' #]/)) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses unsupported flags"
          );
        }
        if (precision.length > 0) {
          throw jsError(
            ofmt,
            convposn,
            curconv,
            "uses non-zero precision (not supported)"
          );
        }
        if (flags.match(/-/))
          left = true;
        if (flags.match(/0/))
          pad = "0";
        if (flags.match(/\+/))
          sign = true;
        switch (conversion) {
          case "s":
            if (arg === void 0 || arg === null) {
              throw jsError(
                ofmt,
                convposn,
                curconv,
                "attempted to print undefined or null as a string (argument " + argn + " to sprintf)"
              );
            }
            ret += doPad(pad, width, left, arg.toString());
            break;
          case "d":
            arg = Math.floor(arg);
          case "f":
            sign = sign && arg > 0 ? "+" : "";
            ret += sign + doPad(
              pad,
              width,
              left,
              arg.toString()
            );
            break;
          case "x":
            ret += doPad(pad, width, left, arg.toString(16));
            break;
          case "j":
            if (width === 0)
              width = 10;
            ret += mod_util.inspect(arg, false, width);
            break;
          case "r":
            ret += dumpException(arg);
            break;
          default:
            throw jsError(
              ofmt,
              convposn,
              curconv,
              "is not supported"
            );
        }
      }
      ret += fmt;
      return ret;
    }
    function jsError(fmtstr, convposn, curconv, reason) {
      mod_assert.equal(typeof fmtstr, "string");
      mod_assert.equal(typeof curconv, "string");
      mod_assert.equal(typeof convposn, "number");
      mod_assert.equal(typeof reason, "string");
      return new Error('format string "' + fmtstr + '": conversion specifier "' + curconv + '" at character ' + convposn + " " + reason);
    }
    function jsPrintf() {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(process.stdout);
      jsFprintf.apply(null, args);
    }
    function jsFprintf(stream) {
      var args = Array.prototype.slice.call(arguments, 1);
      return stream.write(jsSprintf.apply(this, args));
    }
    function doPad(chr, width, left, str) {
      var ret = str;
      while (ret.length < width) {
        if (left)
          ret += chr;
        else
          ret = chr + ret;
      }
      return ret;
    }
    function dumpException(ex) {
      var ret;
      if (!(ex instanceof Error))
        throw new Error(jsSprintf("invalid type for %%r: %j", ex));
      ret = "EXCEPTION: " + ex.constructor.name + ": " + ex.stack;
      if (ex.cause && typeof ex.cause === "function") {
        var cex = ex.cause();
        if (cex) {
          ret += "\nCaused by: " + dumpException(cex);
        }
      }
      return ret;
    }
  }
});

// node_modules/vasync/node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/vasync/node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/vasync/node_modules/verror/lib/verror.js
var require_verror = __commonJS({
  "node_modules/vasync/node_modules/verror/lib/verror.js"(exports, module) {
    var mod_assertplus = require_assert2();
    var mod_util = require_util();
    var mod_extsprintf = require_extsprintf();
    var mod_isError = require_util2().isError;
    var sprintf = mod_extsprintf.sprintf;
    module.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(
          argv[0],
          "first argument to VError, SError, or WError constructor must be a string, object, or Error"
        );
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(
          parsed.options.name,
          `error's "name" must be a string`
        );
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// node_modules/vasync/lib/vasync.js
var require_vasync = __commonJS({
  "node_modules/vasync/lib/vasync.js"(exports) {
    var mod_assert = require_assert();
    var mod_events = require_events();
    var mod_util = require_util();
    var mod_verror = require_verror();
    exports.parallel = parallel2;
    exports.forEachParallel = forEachParallel;
    exports.pipeline = pipeline;
    exports.tryEach = tryEach2;
    exports.forEachPipeline = forEachPipeline;
    exports.filter = filter2;
    exports.filterLimit = filterLimit2;
    exports.filterSeries = filterSeries2;
    exports.whilst = whilst2;
    exports.queue = queue2;
    exports.queuev = queuev;
    exports.barrier = barrier;
    exports.waterfall = waterfall2;
    if (!global.setImmediate) {
      global.setImmediate = function(func) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(0);
        args.unshift(func);
        setTimeout.apply(this, args);
      };
    }
    function isEmpty(obj) {
      var key;
      for (key in obj)
        return false;
      return true;
    }
    function parallel2(args, callback) {
      var funcs, rv, doneOne, i;
      mod_assert.equal(typeof args, "object", '"args" must be an object');
      mod_assert.ok(
        Array.isArray(args["funcs"]),
        '"args.funcs" must be specified and must be an array'
      );
      mod_assert.equal(
        typeof callback,
        "function",
        "callback argument must be specified and must be a function"
      );
      funcs = args["funcs"].slice(0);
      rv = {
        "operations": new Array(funcs.length),
        "successes": [],
        "ndone": 0,
        "nerrors": 0
      };
      if (funcs.length === 0) {
        setImmediate(function() {
          callback(null, rv);
        });
        return rv;
      }
      doneOne = function(entry) {
        return function(err, result) {
          mod_assert.equal(entry["status"], "pending");
          entry["err"] = err;
          entry["result"] = result;
          entry["status"] = err ? "fail" : "ok";
          if (err)
            rv["nerrors"]++;
          else
            rv["successes"].push(result);
          if (++rv["ndone"] < funcs.length)
            return;
          var errors = rv["operations"].filter(function(ent) {
            return ent["status"] == "fail";
          }).map(function(ent) {
            return ent["err"];
          });
          if (errors.length > 0)
            callback(new mod_verror.MultiError(errors), rv);
          else
            callback(null, rv);
        };
      };
      for (i = 0; i < funcs.length; i++) {
        rv["operations"][i] = {
          "func": funcs[i],
          "funcname": funcs[i].name || "(anon)",
          "status": "pending"
        };
        funcs[i](doneOne(rv["operations"][i]));
      }
      return rv;
    }
    function forEachParallel(args, callback) {
      var func, funcs;
      mod_assert.equal(typeof args, "object", '"args" must be an object');
      mod_assert.equal(
        typeof args["func"],
        "function",
        '"args.func" must be specified and must be a function'
      );
      mod_assert.ok(
        Array.isArray(args["inputs"]),
        '"args.inputs" must be specified and must be an array'
      );
      func = args["func"];
      funcs = args["inputs"].map(function(input) {
        return function(subcallback) {
          return func(input, subcallback);
        };
      });
      return parallel2({ "funcs": funcs }, callback);
    }
    function pipeline(args, callback) {
      mod_assert.equal(typeof args, "object", '"args" must be an object');
      mod_assert.ok(
        Array.isArray(args["funcs"]),
        '"args.funcs" must be specified and must be an array'
      );
      var opts = {
        "funcs": args["funcs"].slice(0),
        "callback": callback,
        "args": { impl: "pipeline", uarg: args["arg"] },
        "stop_when": "error",
        "res_type": "rv"
      };
      return waterfall_impl(opts);
    }
    function tryEach2(funcs, callback) {
      mod_assert.ok(
        Array.isArray(funcs),
        '"funcs" must be specified and must be an array'
      );
      mod_assert.ok(
        arguments.length == 1 || typeof callback == "function",
        '"callback" must be a function'
      );
      var opts = {
        "funcs": funcs.slice(0),
        "callback": callback,
        "args": { impl: "tryEach" },
        "stop_when": "success",
        "res_type": "array"
      };
      return waterfall_impl(opts);
    }
    function forEachPipeline(args, callback) {
      mod_assert.equal(typeof args, "object", '"args" must be an object');
      mod_assert.equal(
        typeof args["func"],
        "function",
        '"args.func" must be specified and must be a function'
      );
      mod_assert.ok(
        Array.isArray(args["inputs"]),
        '"args.inputs" must be specified and must be an array'
      );
      mod_assert.equal(
        typeof callback,
        "function",
        "callback argument must be specified and must be a function"
      );
      var func = args["func"];
      var funcs = args["inputs"].map(function(input) {
        return function(_, subcallback) {
          return func(input, subcallback);
        };
      });
      return pipeline({ "funcs": funcs }, callback);
    }
    function filter2(inputs, filterFunc, callback) {
      return filterLimit2(inputs, Infinity, filterFunc, callback);
    }
    function filterSeries2(inputs, filterFunc, callback) {
      return filterLimit2(inputs, 1, filterFunc, callback);
    }
    function filterLimit2(inputs, limit, filterFunc, callback) {
      mod_assert.ok(
        Array.isArray(inputs),
        '"inputs" must be specified and must be an array'
      );
      mod_assert.equal(
        typeof limit,
        "number",
        '"limit" must be a number'
      );
      mod_assert.equal(
        isNaN(limit),
        false,
        '"limit" must be a number'
      );
      mod_assert.equal(
        typeof filterFunc,
        "function",
        '"filterFunc" must be specified and must be a function'
      );
      mod_assert.equal(
        typeof callback,
        "function",
        '"callback" argument must be specified as a function'
      );
      var errors = [];
      var q = queue2(processInput, limit);
      var results = [];
      function processInput(input, cb) {
        if (errors.length > 0) {
          cb();
          return;
        }
        filterFunc(input.elem, function inputFiltered(err, ans) {
          if (results.hasOwnProperty(input.idx)) {
            throw new mod_verror.VError(
              "vasync.filter*: filterFunc idx %d invoked its callback twice",
              input.idx
            );
          }
          results[input.idx] = {
            elem: input.elem,
            ans: !!ans
          };
          if (err) {
            errors.push(err);
            cb();
            return;
          }
          cb();
        });
      }
      q.once("end", function queueDrained() {
        if (errors.length > 0) {
          callback(mod_verror.errorFromList(errors));
          return;
        }
        results = results.filter(function filterFalseInputs(input) {
          return input.ans;
        }).map(function mapInputElements(input) {
          return input.elem;
        });
        callback(null, results);
      });
      inputs.forEach(function iterateInput(elem, idx) {
        q.push({
          elem,
          idx
        });
      });
      q.close();
      return q;
    }
    function whilst2(testFunc, iterateFunc, callback) {
      mod_assert.equal(
        typeof testFunc,
        "function",
        '"testFunc" must be specified and must be a function'
      );
      mod_assert.equal(
        typeof iterateFunc,
        "function",
        '"iterateFunc" must be specified and must be a function'
      );
      mod_assert.equal(
        typeof callback,
        "function",
        '"callback" argument must be specified as a function'
      );
      var o = {
        "finished": false,
        "iterations": 0
      };
      var args = [];
      function iterate() {
        var shouldContinue = testFunc();
        if (!shouldContinue) {
          done();
          return;
        }
        o.iterations++;
        iterateFunc(function whilstIteration(err) {
          args = Array.prototype.slice.call(arguments);
          if (err) {
            done();
            return;
          }
          setImmediate(iterate);
        });
      }
      function done() {
        mod_assert.ok(!o.finished, "whilst already finished");
        o.finished = true;
        callback.apply(this, args);
      }
      setImmediate(iterate);
      return o;
    }
    function queue2(worker, concurrency) {
      return new WorkQueue({
        "worker": worker,
        "concurrency": concurrency
      });
    }
    function queuev(args) {
      return new WorkQueue(args);
    }
    function WorkQueue(args) {
      mod_assert.ok(args.hasOwnProperty("worker"));
      mod_assert.equal(typeof args["worker"], "function");
      mod_assert.ok(args.hasOwnProperty("concurrency"));
      mod_assert.equal(typeof args["concurrency"], "number");
      mod_assert.equal(Math.floor(args["concurrency"]), args["concurrency"]);
      mod_assert.ok(args["concurrency"] > 0);
      mod_events.EventEmitter.call(this);
      this.nextid = 0;
      this.worker = args["worker"];
      this.worker_name = args["worker"].name || "anon";
      this.npending = 0;
      this.pending = {};
      this.queued = [];
      this.closed = false;
      this.ended = false;
      this.concurrency = args["concurrency"];
      this.saturated = void 0;
      this.empty = void 0;
      this.drain = void 0;
    }
    mod_util.inherits(WorkQueue, mod_events.EventEmitter);
    WorkQueue.prototype.push = function(tasks, callback) {
      if (!Array.isArray(tasks))
        return this.pushOne(tasks, callback);
      var wq = this;
      return tasks.map(function(task) {
        return wq.pushOne(task, callback);
      });
    };
    WorkQueue.prototype.updateConcurrency = function(concurrency) {
      if (this.closed)
        throw new mod_verror.VError(
          "update concurrency invoked after queue closed"
        );
      this.concurrency = concurrency;
      this.dispatchNext();
    };
    WorkQueue.prototype.close = function() {
      var wq = this;
      if (wq.closed)
        return;
      wq.closed = true;
      if (wq.npending === 0 && wq.queued.length === 0) {
        setImmediate(function() {
          if (!wq.ended) {
            wq.ended = true;
            wq.emit("end");
          }
        });
      }
    };
    WorkQueue.prototype.pushOne = function(task, callback) {
      if (this.closed)
        throw new mod_verror.VError("push invoked after queue closed");
      var id = ++this.nextid;
      var entry = { "id": id, "task": task, "callback": callback };
      this.queued.push(entry);
      this.dispatchNext();
      return id;
    };
    WorkQueue.prototype.dispatchNext = function() {
      var wq = this;
      if (wq.npending === 0 && wq.queued.length === 0) {
        if (wq.drain)
          wq.drain();
        wq.emit("drain");
        if (wq.closed) {
          wq.ended = true;
          wq.emit("end");
        }
      } else if (wq.queued.length > 0) {
        while (wq.queued.length > 0 && wq.npending < wq.concurrency) {
          var next = wq.queued.shift();
          wq.dispatch(next);
          if (wq.queued.length === 0) {
            if (wq.empty)
              wq.empty();
            wq.emit("empty");
          }
        }
      }
    };
    WorkQueue.prototype.dispatch = function(entry) {
      var wq = this;
      mod_assert.ok(!this.pending.hasOwnProperty(entry["id"]));
      mod_assert.ok(this.npending < this.concurrency);
      mod_assert.ok(!this.ended);
      this.npending++;
      this.pending[entry["id"]] = entry;
      if (this.npending === this.concurrency) {
        if (this.saturated)
          this.saturated();
        this.emit("saturated");
      }
      setImmediate(function() {
        wq.worker(entry["task"], function(err) {
          --wq.npending;
          delete wq.pending[entry["id"]];
          if (entry["callback"])
            entry["callback"].apply(null, arguments);
          wq.dispatchNext();
        });
      });
    };
    WorkQueue.prototype.length = function() {
      return this.queued.length;
    };
    WorkQueue.prototype.kill = function() {
      this.killed = true;
      this.queued = [];
      this.drain = void 0;
      this.close();
    };
    function barrier(args) {
      return new Barrier(args);
    }
    function Barrier(args) {
      mod_assert.ok(
        !args || !args["nrecent"] || typeof args["nrecent"] == "number",
        '"nrecent" must have type "number"'
      );
      mod_events.EventEmitter.call(this);
      var nrecent = args && args["nrecent"] ? args["nrecent"] : 10;
      if (nrecent > 0) {
        this.nrecent = nrecent;
        this.recent = [];
      }
      this.pending = {};
      this.scheduled = false;
    }
    mod_util.inherits(Barrier, mod_events.EventEmitter);
    Barrier.prototype.start = function(name) {
      mod_assert.ok(
        !this.pending.hasOwnProperty(name),
        'operation "' + name + '" is already pending'
      );
      this.pending[name] = Date.now();
    };
    Barrier.prototype.done = function(name) {
      mod_assert.ok(
        this.pending.hasOwnProperty(name),
        'operation "' + name + '" is not pending'
      );
      if (this.recent) {
        this.recent.push({
          "name": name,
          "start": this.pending[name],
          "done": Date.now()
        });
        if (this.recent.length > this.nrecent)
          this.recent.shift();
      }
      delete this.pending[name];
      if (!isEmpty(this.pending) || this.scheduled)
        return;
      this.scheduled = true;
      var self = this;
      setImmediate(function() {
        self.scheduled = false;
        if (isEmpty(self.pending))
          self.emit("drain");
      });
    };
    function waterfall2(funcs, callback) {
      mod_assert.ok(
        Array.isArray(funcs),
        '"funcs" must be specified and must be an array'
      );
      mod_assert.ok(
        arguments.length == 1 || typeof callback == "function",
        '"callback" must be a function'
      );
      var opts = {
        "funcs": funcs.slice(0),
        "callback": callback,
        "args": { impl: "waterfall" },
        "stop_when": "error",
        "res_type": "values"
      };
      return waterfall_impl(opts);
    }
    function waterfall_impl(opts) {
      mod_assert.ok(typeof opts === "object");
      var rv, current, next;
      var funcs = opts.funcs;
      var callback = opts.callback;
      mod_assert.ok(
        Array.isArray(funcs),
        '"opts.funcs" must be specified and must be an array'
      );
      mod_assert.ok(
        arguments.length == 1,
        'Function "waterfall_impl" must take only 1 arg'
      );
      mod_assert.ok(
        opts.res_type === "values" || opts.res_type === "array" || opts.res_type == "rv",
        '"opts.res_type" must either be "values", "array", or "rv"'
      );
      mod_assert.ok(
        opts.stop_when === "error" || opts.stop_when === "success",
        '"opts.stop_when" must either be "error" or "success"'
      );
      mod_assert.ok(
        opts.args.impl === "pipeline" || opts.args.impl === "waterfall" || opts.args.impl === "tryEach",
        '"opts.args.impl" must be "pipeline", "waterfall", or "tryEach"'
      );
      if (opts.args.impl === "pipeline") {
        mod_assert.ok(
          typeof opts.args.uarg !== void 0,
          '"opts.args.uarg" should be defined when pipeline is used'
        );
      }
      rv = {
        "operations": funcs.map(function(func) {
          return {
            "func": func,
            "funcname": func.name || "(anon)",
            "status": "waiting"
          };
        }),
        "successes": [],
        "ndone": 0,
        "nerrors": 0
      };
      if (funcs.length === 0) {
        if (callback)
          setImmediate(function() {
            var res = opts.args.impl === "pipeline" ? rv : void 0;
            callback(null, res);
          });
        return rv;
      }
      next = function(idx, err) {
        var res_key, nfunc_args, entry, nextentry;
        if (err === void 0)
          err = null;
        if (idx != current) {
          throw new mod_verror.VError(
            'vasync.waterfall: function %d ("%s") invoked its callback twice',
            idx,
            rv["operations"][idx].funcname
          );
        }
        mod_assert.equal(
          idx,
          rv["ndone"],
          "idx should be equal to ndone"
        );
        entry = rv["operations"][rv["ndone"]++];
        if (opts.args.impl === "tryEach" || opts.args.impl === "waterfall") {
          nfunc_args = Array.prototype.slice.call(arguments, 2);
          res_key = "results";
          entry["results"] = nfunc_args;
        } else if (opts.args.impl === "pipeline") {
          nfunc_args = [opts.args.uarg];
          res_key = "result";
          entry["result"] = arguments[2];
        }
        mod_assert.equal(
          entry["status"],
          "pending",
          "status should be pending"
        );
        entry["status"] = err ? "fail" : "ok";
        entry["err"] = err;
        if (err) {
          rv["nerrors"]++;
        } else {
          rv["successes"].push(entry[res_key]);
        }
        if (opts.stop_when === "error" && err || opts.stop_when === "success" && rv["successes"].length > 0 || rv["ndone"] == funcs.length) {
          if (callback) {
            if (opts.res_type === "values" || opts.res_type === "array" && nfunc_args.length <= 1) {
              nfunc_args.unshift(err);
              callback.apply(null, nfunc_args);
            } else if (opts.res_type === "array") {
              callback(err, nfunc_args);
            } else if (opts.res_type === "rv") {
              callback(err, rv);
            }
          }
        } else {
          nextentry = rv["operations"][rv["ndone"]];
          nextentry["status"] = "pending";
          current++;
          nfunc_args.push(next.bind(null, current));
          setImmediate(function() {
            var nfunc = nextentry["func"];
            if (opts.args.impl !== "tryEach") {
              nfunc.apply(null, nfunc_args);
            } else {
              nfunc(next.bind(null, current));
            }
          });
        }
      };
      rv["operations"][0]["status"] = "pending";
      current = 0;
      if (opts.args.impl !== "pipeline") {
        funcs[0](next.bind(null, current));
      } else {
        funcs[0](opts.args.uarg, next.bind(null, current));
      }
      return rv;
    }
  }
});

// node_modules/verror/node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "node_modules/verror/node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/verror/lib/verror.js
var require_verror2 = __commonJS({
  "node_modules/verror/lib/verror.js"(exports, module) {
    var mod_assertplus = require_assert2();
    var mod_util = require_util();
    var mod_extsprintf = require_extsprintf();
    var mod_isError = require_util3().isError;
    var sprintf = mod_extsprintf.sprintf;
    module.exports = VError;
    VError.VError = VError;
    VError.SError = SError;
    VError.WError = WError;
    VError.MultiError = MultiError;
    function parseConstructorArguments(args) {
      var argv, options, sprintf_args, shortmessage, k;
      mod_assertplus.object(args, "args");
      mod_assertplus.bool(args.strict, "args.strict");
      mod_assertplus.array(args.argv, "args.argv");
      argv = args.argv;
      if (argv.length === 0) {
        options = {};
        sprintf_args = [];
      } else if (mod_isError(argv[0])) {
        options = { "cause": argv[0] };
        sprintf_args = argv.slice(1);
      } else if (typeof argv[0] === "object") {
        options = {};
        for (k in argv[0]) {
          options[k] = argv[0][k];
        }
        sprintf_args = argv.slice(1);
      } else {
        mod_assertplus.string(
          argv[0],
          "first argument to VError, SError, or WError constructor must be a string, object, or Error"
        );
        options = {};
        sprintf_args = argv;
      }
      mod_assertplus.object(options);
      if (!options.strict && !args.strict) {
        sprintf_args = sprintf_args.map(function(a) {
          return a === null ? "null" : a === void 0 ? "undefined" : a;
        });
      }
      if (sprintf_args.length === 0) {
        shortmessage = "";
      } else {
        shortmessage = sprintf.apply(null, sprintf_args);
      }
      return {
        "options": options,
        "shortmessage": shortmessage
      };
    }
    function VError() {
      var args, obj, parsed, cause, ctor, message, k;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof VError)) {
        obj = Object.create(VError.prototype);
        VError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      if (parsed.options.name) {
        mod_assertplus.string(
          parsed.options.name,
          `error's "name" must be a string`
        );
        this.name = parsed.options.name;
      }
      this.jse_shortmsg = parsed.shortmessage;
      message = parsed.shortmessage;
      cause = parsed.options.cause;
      if (cause) {
        mod_assertplus.ok(mod_isError(cause), "cause is not an Error");
        this.jse_cause = cause;
        if (!parsed.options.skipCauseMessage) {
          message += ": " + cause.message;
        }
      }
      this.jse_info = {};
      if (parsed.options.info) {
        for (k in parsed.options.info) {
          this.jse_info[k] = parsed.options.info[k];
        }
      }
      this.message = message;
      Error.call(this, message);
      if (Error.captureStackTrace) {
        ctor = parsed.options.constructorOpt || this.constructor;
        Error.captureStackTrace(this, ctor);
      }
      return this;
    }
    mod_util.inherits(VError, Error);
    VError.prototype.name = "VError";
    VError.prototype.toString = function ve_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      return str;
    };
    VError.prototype.cause = function ve_cause() {
      var cause = VError.cause(this);
      return cause === null ? void 0 : cause;
    };
    VError.cause = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      return mod_isError(err.jse_cause) ? err.jse_cause : null;
    };
    VError.info = function(err) {
      var rv, cause, k;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      cause = VError.cause(err);
      if (cause !== null) {
        rv = VError.info(cause);
      } else {
        rv = {};
      }
      if (typeof err.jse_info == "object" && err.jse_info !== null) {
        for (k in err.jse_info) {
          rv[k] = err.jse_info[k];
        }
      }
      return rv;
    };
    VError.findCauseByName = function(err, name) {
      var cause;
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.string(name, "name");
      mod_assertplus.ok(name.length > 0, "name cannot be empty");
      for (cause = err; cause !== null; cause = VError.cause(cause)) {
        mod_assertplus.ok(mod_isError(cause));
        if (cause.name == name) {
          return cause;
        }
      }
      return null;
    };
    VError.hasCauseWithName = function(err, name) {
      return VError.findCauseByName(err, name) !== null;
    };
    VError.fullStack = function(err) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      var cause = VError.cause(err);
      if (cause) {
        return err.stack + "\ncaused by: " + VError.fullStack(cause);
      }
      return err.stack;
    };
    VError.errorFromList = function(errors) {
      mod_assertplus.arrayOfObject(errors, "errors");
      if (errors.length === 0) {
        return null;
      }
      errors.forEach(function(e) {
        mod_assertplus.ok(mod_isError(e));
      });
      if (errors.length == 1) {
        return errors[0];
      }
      return new MultiError(errors);
    };
    VError.errorForEach = function(err, func) {
      mod_assertplus.ok(mod_isError(err), "err must be an Error");
      mod_assertplus.func(func, "func");
      if (err instanceof MultiError) {
        err.errors().forEach(function iterError(e) {
          func(e);
        });
      } else {
        func(err);
      }
    };
    function SError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof SError)) {
        obj = Object.create(SError.prototype);
        SError.apply(obj, arguments);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": true
      });
      options = parsed.options;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(SError, VError);
    function MultiError(errors) {
      mod_assertplus.array(errors, "list of errors");
      mod_assertplus.ok(errors.length > 0, "must be at least one error");
      this.ase_errors = errors;
      VError.call(this, {
        "cause": errors[0]
      }, "first of %d error%s", errors.length, errors.length == 1 ? "" : "s");
    }
    mod_util.inherits(MultiError, VError);
    MultiError.prototype.name = "MultiError";
    MultiError.prototype.errors = function me_errors() {
      return this.ase_errors.slice(0);
    };
    function WError() {
      var args, obj, parsed, options;
      args = Array.prototype.slice.call(arguments, 0);
      if (!(this instanceof WError)) {
        obj = Object.create(WError.prototype);
        WError.apply(obj, args);
        return obj;
      }
      parsed = parseConstructorArguments({
        "argv": args,
        "strict": false
      });
      options = parsed.options;
      options["skipCauseMessage"] = true;
      VError.call(this, options, "%s", parsed.shortmessage);
      return this;
    }
    mod_util.inherits(WError, VError);
    WError.prototype.name = "WError";
    WError.prototype.toString = function we_toString() {
      var str = this.hasOwnProperty("name") && this.name || this.constructor.name || this.constructor.prototype.name;
      if (this.message)
        str += ": " + this.message;
      if (this.jse_cause && this.jse_cause.message)
        str += "; caused by " + this.jse_cause.toString();
      return str;
    };
    WError.prototype.cause = function we_cause(c) {
      if (mod_isError(c))
        this.jse_cause = c;
      return this.jse_cause;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/corked_emitter.js
var require_corked_emitter = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/corked_emitter.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    function CorkedEmitter() {
      const self = this;
      EventEmitter.call(self);
      self._outstandingEmits = [];
      self._opened = false;
      self.once("newListener", function() {
        setImmediate(function releaseStoredEvents() {
          self._opened = true;
          self._outstandingEmits.forEach(function(args) {
            self.emit.apply(self, args);
          });
        });
      });
    }
    CorkedEmitter.prototype = Object.create(EventEmitter.prototype);
    CorkedEmitter.prototype.emit = function emit(eventName) {
      if (this._opened || eventName === "newListener") {
        EventEmitter.prototype.emit.apply(this, arguments);
      } else {
        this._outstandingEmits.push(arguments);
      }
    };
    module.exports = CorkedEmitter;
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/search_pager.js
var require_search_pager = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/search_pager.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events().EventEmitter;
    var util = require_util();
    var assert = require_assert2();
    var PagedControl = require_paged_results_control();
    var CorkedEmitter = require_corked_emitter();
    function SearchPager(opts) {
      assert.object(opts);
      assert.func(opts.callback);
      assert.number(opts.pageSize);
      assert.func(opts.sendRequest);
      CorkedEmitter.call(this, {});
      this.callback = opts.callback;
      this.controls = opts.controls;
      this.pageSize = opts.pageSize;
      this.pagePause = opts.pagePause;
      this.sendRequest = opts.sendRequest;
      this.controls.forEach(function(control) {
        if (control.type === PagedControl.OID) {
          throw new Error("redundant pagedResultControl");
        }
      });
      this.finished = false;
      this.started = false;
      const emitter = new EventEmitter();
      emitter.on("searchRequest", this.emit.bind(this, "searchRequest"));
      emitter.on("searchEntry", this.emit.bind(this, "searchEntry"));
      emitter.on("end", this._onEnd.bind(this));
      emitter.on("error", this._onError.bind(this));
      this.childEmitter = emitter;
    }
    util.inherits(SearchPager, CorkedEmitter);
    module.exports = SearchPager;
    SearchPager.prototype.begin = function begin() {
      this._nextPage(null);
    };
    SearchPager.prototype._onEnd = function _onEnd(res) {
      const self = this;
      let cookie = null;
      res.controls.forEach(function(control) {
        if (control.type === PagedControl.OID) {
          cookie = control.value.cookie;
        }
      });
      const nullCb = function() {
      };
      if (cookie === null) {
        this.finished = true;
        this.emit("page", res, nullCb);
        const err = new Error("missing paged control");
        err.name = "PagedError";
        if (this.listeners("pageError").length > 0) {
          this.emit("pageError", err);
          this.emit("end", res);
        } else {
          this.emit("error", err);
        }
        return;
      }
      if (cookie.length === 0) {
        this.finished = true;
        this.emit("page", nullCb);
        this.emit("end", res);
      } else {
        if (this.pagePause) {
          this.emit("page", res, function(err) {
            if (!err) {
              self._nextPage(cookie);
            } else {
              self.emit("end", res);
            }
          });
        } else {
          this.emit("page", res, nullCb);
          this._nextPage(cookie);
        }
      }
    };
    SearchPager.prototype._onError = function _onError(err) {
      this.finished = true;
      this.emit("error", err);
    };
    SearchPager.prototype._nextPage = function _nextPage(cookie) {
      const controls = this.controls.slice(0);
      controls.push(new PagedControl({
        value: {
          size: this.pageSize,
          cookie
        }
      }));
      this.sendRequest(controls, this.childEmitter, this._sendCallback.bind(this));
    };
    SearchPager.prototype._sendCallback = function _sendCallback(err) {
      if (err) {
        this.finished = true;
        if (!this.started) {
          this.callback(err, null);
        } else {
          this.emit("error", err);
        }
      } else {
        if (!this.started) {
          this.started = true;
          this.callback(null, this);
        }
      }
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/client.js
var require_client = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/client.js"(exports, module) {
    "use strict";
    var requestQueueFactory = require_request_queue();
    var messageTrackerFactory = require_message_tracker();
    var { MAX_MSGID } = require_constants();
    var EventEmitter = require_events().EventEmitter;
    var net = require_net();
    var tls = require_tls();
    var util = require_util();
    var once2 = require_once();
    var backoff = require_backoff2();
    var vasync = require_vasync();
    var assert = require_assert2();
    var VError = require_verror2().VError;
    var Attribute = require_attribute();
    var Change = require_change();
    var Control = require_controls().Control;
    var SearchPager = require_search_pager();
    var Protocol = require_protocol();
    var dn = require_dn();
    var errors = require_errors2();
    var filters = require_filters();
    var messages = require_messages();
    var url = require_url2();
    var CorkedEmitter = require_corked_emitter();
    var AbandonRequest = messages.AbandonRequest;
    var AddRequest = messages.AddRequest;
    var BindRequest = messages.BindRequest;
    var CompareRequest = messages.CompareRequest;
    var DeleteRequest = messages.DeleteRequest;
    var ExtendedRequest = messages.ExtendedRequest;
    var ModifyRequest = messages.ModifyRequest;
    var ModifyDNRequest = messages.ModifyDNRequest;
    var SearchRequest = messages.SearchRequest;
    var UnbindRequest = messages.UnbindRequest;
    var UnbindResponse = messages.UnbindResponse;
    var LDAPResult = messages.LDAPResult;
    var SearchEntry = messages.SearchEntry;
    var SearchReference = messages.SearchReference;
    var Parser = messages.Parser;
    var PresenceFilter = filters.PresenceFilter;
    var ConnectionError = errors.ConnectionError;
    var CMP_EXPECT = [errors.LDAP_COMPARE_TRUE, errors.LDAP_COMPARE_FALSE];
    var CLIENT_ID = 0;
    function nextClientId() {
      if (++CLIENT_ID === MAX_MSGID) {
        return 1;
      }
      return CLIENT_ID;
    }
    function validateControls(controls) {
      if (Array.isArray(controls)) {
        controls.forEach(function(c) {
          if (!(c instanceof Control)) {
            throw new TypeError("controls must be [Control]");
          }
        });
      } else if (controls instanceof Control) {
        controls = [controls];
      } else {
        throw new TypeError("controls must be [Control]");
      }
      return controls;
    }
    function ensureDN(input, strict) {
      if (dn.DN.isDN(input)) {
        return dn;
      } else if (strict) {
        return dn.parse(input);
      } else if (typeof input === "string") {
        return input;
      } else {
        throw new Error("invalid DN");
      }
    }
    function Client(options) {
      assert.ok(options);
      EventEmitter.call(this, options);
      const self = this;
      this.urls = options.url ? [].concat(options.url).map(url.parse) : [];
      this._nextServer = 0;
      this.host = void 0;
      this.port = void 0;
      this.secure = void 0;
      this.url = void 0;
      this.tlsOptions = options.tlsOptions;
      this.socketPath = options.socketPath || false;
      this.log = options.log.child({ clazz: "Client" }, true);
      this.timeout = parseInt(options.timeout || 0, 10);
      this.connectTimeout = parseInt(options.connectTimeout || 0, 10);
      this.idleTimeout = parseInt(options.idleTimeout || 0, 10);
      if (options.reconnect) {
        const rOpts = typeof options.reconnect === "object" ? options.reconnect : {};
        this.reconnect = {
          initialDelay: parseInt(rOpts.initialDelay || 100, 10),
          maxDelay: parseInt(rOpts.maxDelay || 1e4, 10),
          failAfter: parseInt(rOpts.failAfter, 10) || Infinity
        };
      }
      this.strictDN = options.strictDN !== void 0 ? options.strictDN : true;
      this.queue = requestQueueFactory({
        size: parseInt(options.queueSize || 0, 10),
        timeout: parseInt(options.queueTimeout || 0, 10)
      });
      if (options.queueDisable) {
        this.queue.freeze();
      }
      if (options.bindDN !== void 0 && options.bindCredentials !== void 0) {
        this.on("setup", function(clt, cb) {
          clt.bind(options.bindDN, options.bindCredentials, function(err) {
            if (err) {
              if (self._socket) {
                self._socket.destroy();
              }
              self.emit("error", err);
            }
            cb(err);
          });
        });
      }
      this._socket = null;
      this.connected = false;
      this.connect();
    }
    util.inherits(Client, EventEmitter);
    module.exports = Client;
    Client.prototype.abandon = function abandon(messageID, controls, callback) {
      assert.number(messageID, "messageID");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new AbandonRequest({
        abandonID: messageID,
        controls
      });
      return this._send(req, "abandon", null, callback);
    };
    Client.prototype.add = function add(name, entry, controls, callback) {
      assert.ok(name !== void 0, "name");
      assert.object(entry, "entry");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      if (Array.isArray(entry)) {
        entry.forEach(function(a) {
          if (!Attribute.isAttribute(a)) {
            throw new TypeError("entry must be an Array of Attributes");
          }
        });
      } else {
        const save = entry;
        entry = [];
        Object.keys(save).forEach(function(k) {
          const attr = new Attribute({ type: k });
          if (Array.isArray(save[k])) {
            save[k].forEach(function(v) {
              attr.addValue(v.toString());
            });
          } else if (Buffer.isBuffer(save[k])) {
            attr.addValue(save[k]);
          } else {
            attr.addValue(save[k].toString());
          }
          entry.push(attr);
        });
      }
      const req = new AddRequest({
        entry: ensureDN(name, this.strictDN),
        attributes: entry,
        controls
      });
      return this._send(req, [errors.LDAP_SUCCESS], null, callback);
    };
    Client.prototype.bind = function bind(name, credentials, controls, callback, _bypass) {
      if (typeof name !== "string" && !(name instanceof dn.DN)) {
        throw new TypeError("name (string) required");
      }
      assert.optionalString(credentials, "credentials");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new BindRequest({
        name: name || "",
        authentication: "Simple",
        credentials: credentials || "",
        controls
      });
      const self = this;
      function callbackWrapper(err, ret) {
        self.removeListener("connectError", callbackWrapper);
        callback(err, ret);
      }
      this.addListener("connectError", callbackWrapper);
      return this._send(req, [errors.LDAP_SUCCESS], null, callbackWrapper, _bypass);
    };
    Client.prototype.compare = function compare(name, attr, value, controls, callback) {
      assert.ok(name !== void 0, "name");
      assert.string(attr, "attr");
      assert.string(value, "value");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new CompareRequest({
        entry: ensureDN(name, this.strictDN),
        attribute: attr,
        value,
        controls
      });
      return this._send(req, CMP_EXPECT, null, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.status === errors.LDAP_COMPARE_TRUE, res);
      });
    };
    Client.prototype.del = function del(name, controls, callback) {
      assert.ok(name !== void 0, "name");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new DeleteRequest({
        entry: ensureDN(name, this.strictDN),
        controls
      });
      return this._send(req, [errors.LDAP_SUCCESS], null, callback);
    };
    Client.prototype.exop = function exop(name, value, controls, callback) {
      assert.string(name, "name");
      if (typeof value === "function") {
        callback = value;
        controls = [];
        value = void 0;
      }
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new ExtendedRequest({
        requestName: name,
        requestValue: value,
        controls
      });
      return this._send(req, [errors.LDAP_SUCCESS], null, function(err, res) {
        if (err) {
          return callback(err);
        }
        return callback(null, res.responseValue || "", res);
      });
    };
    Client.prototype.modify = function modify(name, change, controls, callback) {
      assert.ok(name !== void 0, "name");
      assert.object(change, "change");
      const changes = [];
      function changeFromObject(obj) {
        if (!obj.operation && !obj.type) {
          throw new Error("change.operation required");
        }
        if (typeof obj.modification !== "object") {
          throw new Error("change.modification (object) required");
        }
        if (Object.keys(obj.modification).length === 2 && typeof obj.modification.type === "string" && Array.isArray(obj.modification.vals)) {
          changes.push(new Change({
            operation: obj.operation || obj.type,
            modification: obj.modification
          }));
        } else {
          Object.keys(obj.modification).forEach(function(k) {
            const mod = {};
            mod[k] = obj.modification[k];
            changes.push(new Change({
              operation: obj.operation || obj.type,
              modification: mod
            }));
          });
        }
      }
      if (Change.isChange(change)) {
        changes.push(change);
      } else if (Array.isArray(change)) {
        change.forEach(function(c) {
          if (Change.isChange(c)) {
            changes.push(c);
          } else {
            changeFromObject(c);
          }
        });
      } else {
        changeFromObject(change);
      }
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      const req = new ModifyRequest({
        object: ensureDN(name, this.strictDN),
        changes,
        controls
      });
      return this._send(req, [errors.LDAP_SUCCESS], null, callback);
    };
    Client.prototype.modifyDN = function modifyDN(name, newName, controls, callback) {
      assert.ok(name !== void 0, "name");
      assert.string(newName, "newName");
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback);
      const DN = ensureDN(name);
      const newDN = dn.parse(newName);
      const req = new ModifyDNRequest({
        entry: DN,
        deleteOldRdn: true,
        controls
      });
      if (newDN.length !== 1) {
        req.newRdn = dn.parse(newDN.rdns.shift().toString());
        req.newSuperior = newDN;
      } else {
        req.newRdn = newDN;
      }
      return this._send(req, [errors.LDAP_SUCCESS], null, callback);
    };
    Client.prototype.search = function search(base, options, controls, callback, _bypass) {
      assert.ok(base !== void 0, "search base");
      if (Array.isArray(options) || options instanceof Control) {
        controls = options;
        options = {};
      } else if (typeof options === "function") {
        callback = options;
        controls = [];
        options = {
          filter: new PresenceFilter({ attribute: "objectclass" })
        };
      } else if (typeof options === "string") {
        options = { filter: filters.parseString(options) };
      } else if (typeof options !== "object") {
        throw new TypeError("options (object) required");
      }
      if (typeof options.filter === "string") {
        options.filter = filters.parseString(options.filter);
      } else if (!options.filter) {
        options.filter = new PresenceFilter({ attribute: "objectclass" });
      } else if (!filters.isFilter(options.filter)) {
        throw new TypeError("options.filter (Filter) required");
      }
      if (typeof controls === "function") {
        callback = controls;
        controls = [];
      } else {
        controls = validateControls(controls);
      }
      assert.func(callback, "callback");
      if (options.attributes) {
        if (!Array.isArray(options.attributes)) {
          if (typeof options.attributes === "string") {
            options.attributes = [options.attributes];
          } else {
            throw new TypeError("options.attributes must be an Array of Strings");
          }
        }
      }
      const self = this;
      const baseDN = ensureDN(base, this.strictDN);
      function sendRequest(ctrls, emitter, cb) {
        const req = new SearchRequest({
          baseObject: baseDN,
          scope: options.scope || "base",
          filter: options.filter,
          derefAliases: options.derefAliases || Protocol.NEVER_DEREF_ALIASES,
          sizeLimit: options.sizeLimit || 0,
          timeLimit: options.timeLimit || 10,
          typesOnly: options.typesOnly || false,
          attributes: options.attributes || [],
          controls: ctrls
        });
        return self._send(
          req,
          [errors.LDAP_SUCCESS],
          emitter,
          cb,
          _bypass
        );
      }
      if (options.paged) {
        const pageOpts = typeof options.paged === "object" ? options.paged : {};
        let size = 100;
        if (pageOpts.pageSize > 0) {
          size = pageOpts.pageSize;
        } else if (options.sizeLimit > 1) {
          size = options.sizeLimit - 1;
        }
        const pager = new SearchPager({
          callback,
          controls,
          pageSize: size,
          pagePause: pageOpts.pagePause,
          sendRequest
        });
        pager.begin();
      } else {
        sendRequest(controls, new CorkedEmitter(), callback);
      }
    };
    Client.prototype.unbind = function unbind(callback) {
      if (!callback) {
        callback = function() {
        };
      }
      if (typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      this.unbound = true;
      if (!this._socket) {
        return callback();
      }
      const req = new UnbindRequest();
      return this._send(req, "unbind", null, callback);
    };
    Client.prototype.starttls = function starttls(options, controls, callback, _bypass) {
      assert.optionalObject(options);
      options = options || {};
      callback = once2(callback);
      const self = this;
      if (this._starttls) {
        return callback(new Error("STARTTLS already in progress or active"));
      }
      function onSend(sendErr, emitter) {
        if (sendErr) {
          callback(sendErr);
          return;
        }
        self._starttls = {
          started: true
        };
        emitter.on("error", function(err) {
          self._starttls = null;
          callback(err);
        });
        emitter.on("end", function(_res) {
          const sock = self._socket;
          sock.removeAllListeners("data");
          options.socket = sock;
          const secure = tls.connect(options);
          secure.once("secureConnect", function() {
            secure.removeAllListeners("error");
            secure.on("data", function onData(data) {
              self.log.trace("data event: %s", util.inspect(data));
              self._tracker.parser.write(data);
            });
            secure.on("error", function(err) {
              self.log.trace({ err }, "error event: %s", new Error().stack);
              self.emit("error", err);
              sock.destroy();
            });
            callback(null);
          });
          secure.once("error", function(err) {
            self._starttls = null;
            secure.removeAllListeners();
            callback(err);
          });
          self._starttls.success = true;
          self._socket = secure;
        });
      }
      const req = new ExtendedRequest({
        requestName: "1.3.6.1.4.1.1466.20037",
        requestValue: null,
        controls
      });
      return this._send(
        req,
        [errors.LDAP_SUCCESS],
        new EventEmitter(),
        onSend,
        _bypass
      );
    };
    Client.prototype.destroy = function destroy(err) {
      this.destroyed = true;
      this.queue.freeze();
      this.queue.flush(function(msg, expect, emitter, cb) {
        if (typeof cb === "function") {
          cb(new Error("client destroyed"));
        }
      });
      if (this.connected) {
        this.unbind();
      }
      if (this._socket) {
        this._socket.destroy();
      }
      this.emit("destroy", err);
    };
    Client.prototype.connect = function connect() {
      if (this.connecting || this.connected) {
        return;
      }
      const self = this;
      const log2 = this.log;
      let socket;
      let tracker;
      function connectSocket(cb) {
        const server = self.urls[self._nextServer];
        self._nextServer = (self._nextServer + 1) % self.urls.length;
        cb = once2(cb);
        function onResult(err, res) {
          if (err) {
            if (self.connectTimer) {
              clearTimeout(self.connectTimer);
              self.connectTimer = null;
            }
            self.emit("connectError", err);
          }
          cb(err, res);
        }
        function onConnect() {
          if (self.connectTimer) {
            clearTimeout(self.connectTimer);
            self.connectTimer = null;
          }
          socket.removeAllListeners("error").removeAllListeners("connect").removeAllListeners("secureConnect");
          tracker.id = nextClientId() + "__" + tracker.id;
          self.log = self.log.child({ ldap_id: tracker.id }, true);
          setupClient(cb);
        }
        const port = server && server.port || self.socketPath;
        const host = server && server.hostname;
        if (server && server.secure) {
          socket = tls.connect(port, host, self.tlsOptions);
          socket.once("secureConnect", onConnect);
        } else {
          socket = net.connect(port, host);
          socket.once("connect", onConnect);
        }
        socket.once("error", onResult);
        initSocket(server);
        if (self.connectTimeout) {
          self.connectTimer = setTimeout(function onConnectTimeout() {
            if (!socket || !socket.readable || !socket.writeable) {
              socket.destroy();
              self._socket = null;
              onResult(new ConnectionError("connection timeout"));
            }
          }, self.connectTimeout);
        }
      }
      function initSocket(server) {
        tracker = messageTrackerFactory({
          id: server ? server.href : self.socketPath,
          parser: new Parser({ log: log2 })
        });
        if (typeof socket.setKeepAlive !== "function") {
          socket.setKeepAlive = function setKeepAlive(enable, delay) {
            return socket.socket ? socket.socket.setKeepAlive(enable, delay) : false;
          };
        }
        socket.on("data", function onData(data) {
          log2.trace("data event: %s", util.inspect(data));
          tracker.parser.write(data);
        });
        tracker.parser.on("message", function onMessage(message) {
          message.connection = self._socket;
          const callback = tracker.fetch(message.messageID);
          if (!callback) {
            log2.error({ message: message.json }, "unsolicited message");
            return false;
          }
          return callback(message);
        });
        tracker.parser.on("error", function onParseError(err) {
          self.emit("error", new VError(
            err,
            "Parser error for %s",
            tracker.id
          ));
          self.connected = false;
          socket.end();
        });
      }
      function setupClient(cb) {
        cb = once2(cb);
        function bail(err) {
          socket.destroy();
          cb(err || new Error("client error during setup"));
        }
        (socket.socket ? socket.socket : socket).once("close", bail);
        socket.once("error", bail);
        socket.once("end", bail);
        socket.once("timeout", bail);
        socket.once("cleanupSetupListeners", function onCleanup() {
          socket.removeListener("error", bail).removeListener("close", bail).removeListener("end", bail).removeListener("timeout", bail);
        });
        self._socket = socket;
        self._tracker = tracker;
        const basicClient = {
          bind: function bindBypass(name, credentials, controls, callback) {
            return self.bind(name, credentials, controls, callback, true);
          },
          search: function searchBypass(base, options, controls, callback) {
            return self.search(base, options, controls, callback, true);
          },
          starttls: function starttlsBypass(options, controls, callback) {
            return self.starttls(options, controls, callback, true);
          },
          unbind: self.unbind.bind(self)
        };
        vasync.forEachPipeline({
          func: function(f, callback) {
            f(basicClient, callback);
          },
          inputs: self.listeners("setup")
        }, function(err, _res) {
          if (err) {
            self.emit("setupError", err);
          }
          cb(err);
        });
      }
      function postSetup() {
        socket.emit("cleanupSetupListeners");
        (socket.socket ? socket.socket : socket).once(
          "close",
          self._onClose.bind(self)
        );
        socket.on("end", function onEnd() {
          log2.trace("end event");
          self.emit("end");
          socket.end();
        });
        socket.on("error", function onSocketError(err) {
          log2.trace({ err }, "error event: %s", new Error().stack);
          self.emit("error", err);
          socket.destroy();
        });
        socket.on("timeout", function onTimeout() {
          log2.trace("timeout event");
          self.emit("socketTimeout");
          socket.end();
        });
        const server = self.urls[self._nextServer];
        if (server) {
          self.host = server.hostname;
          self.port = server.port;
          self.secure = server.secure;
        }
      }
      let retry2;
      let failAfter;
      if (this.reconnect) {
        retry2 = backoff.exponential({
          initialDelay: this.reconnect.initialDelay,
          maxDelay: this.reconnect.maxDelay
        });
        failAfter = this.reconnect.failAfter;
        if (this.urls.length > 1 && failAfter) {
          failAfter *= this.urls.length;
        }
      } else {
        retry2 = backoff.exponential({
          initialDelay: 1,
          maxDelay: 2
        });
        failAfter = this.urls.length || 1;
      }
      retry2.failAfter(failAfter);
      retry2.on("ready", function(num, _delay) {
        if (self.destroyed) {
          return;
        }
        connectSocket(function(err) {
          if (!err) {
            postSetup();
            self.connecting = false;
            self.connected = true;
            self.emit("connect", socket);
            self.log.debug("connected after %d attempt(s)", num + 1);
            self._flushQueue();
            self._connectRetry = null;
          } else {
            retry2.backoff(err);
          }
        });
      });
      retry2.on("fail", function(err) {
        if (self.destroyed) {
          return;
        }
        self.log.debug("failed to connect after %d attempts", failAfter);
        if (err instanceof ConnectionError) {
          self.emitError("connectTimeout", err);
        } else if (err.code === "ECONNREFUSED") {
          self.emitError("connectRefused", err);
        } else {
          self.emit("error", err);
        }
      });
      this._connectRetry = retry2;
      this.connecting = true;
      retry2.backoff();
    };
    Client.prototype._flushQueue = function _flushQueue() {
      this.queue.flush(this._send.bind(this));
    };
    Client.prototype._onClose = function _onClose(closeError) {
      const socket = this._socket;
      const tracker = this._tracker;
      socket.removeAllListeners("connect").removeAllListeners("data").removeAllListeners("drain").removeAllListeners("end").removeAllListeners("error").removeAllListeners("timeout");
      this._socket = null;
      this.connected = false;
      (socket.socket ? socket.socket : socket).removeAllListeners("close");
      this.log.trace("close event had_err=%s", closeError ? "yes" : "no");
      this.emit("close", closeError);
      tracker.purge(function(msgid, cb) {
        if (socket.unbindMessageID !== msgid) {
          return cb(new ConnectionError(tracker.id + " closed"));
        } else {
          const unbind = new UnbindResponse({ messageID: msgid });
          unbind.status = "unbind";
          return cb(unbind);
        }
      });
      this._tracker = null;
      delete this._starttls;
      if (this.reconnect && !this.unbound) {
        this.connect();
      }
      this.unbound = false;
      return false;
    };
    Client.prototype._updateIdle = function _updateIdle(override) {
      if (this.idleTimeout === 0) {
        return;
      }
      const self = this;
      function isIdle(disable) {
        return disable !== true && (self._socket && self.connected) && self._tracker.pending === 0;
      }
      if (isIdle(override)) {
        if (!this._idleTimer) {
          this._idleTimer = setTimeout(function() {
            if (isIdle()) {
              self.emit("idle");
            }
          }, this.idleTimeout);
        }
      } else {
        if (this._idleTimer) {
          clearTimeout(this._idleTimer);
          this._idleTimer = null;
        }
      }
    };
    Client.prototype._send = function _send(message, expect, emitter, callback, _bypass) {
      assert.ok(message);
      assert.ok(expect);
      assert.optionalObject(emitter);
      assert.ok(callback);
      if (_bypass && this._socket && this._socket.writable) {
        return this._sendSocket(message, expect, emitter, callback);
      }
      if (!this._socket || !this.connected) {
        if (!this.queue.enqueue(message, expect, emitter, callback)) {
          callback(new ConnectionError("connection unavailable"));
        }
        if (this.reconnect) {
          this.connect();
        }
        return false;
      } else {
        this._flushQueue();
        return this._sendSocket(message, expect, emitter, callback);
      }
    };
    Client.prototype._sendSocket = function _sendSocket(message, expect, emitter, callback) {
      const conn = this._socket;
      const tracker = this._tracker;
      const log2 = this.log;
      const self = this;
      let timer = false;
      let sentEmitter = false;
      function sendResult(event, obj) {
        if (event === "error") {
          self.emit("resultError", obj);
        }
        if (emitter) {
          if (event === "error") {
            if (!sentEmitter) {
              return callback(obj);
            }
          }
          return emitter.emit(event, obj);
        }
        if (event === "error") {
          return callback(obj);
        }
        return callback(null, obj);
      }
      function messageCallback(msg) {
        if (timer) {
          clearTimeout(timer);
        }
        log2.trace({ msg: msg ? msg.json : null }, "response received");
        if (expect === "abandon") {
          return sendResult("end", null);
        }
        if (msg instanceof SearchEntry || msg instanceof SearchReference) {
          let event = msg.constructor.name;
          event = event[0].toLowerCase() + event.slice(1);
          return sendResult(event, msg);
        } else {
          tracker.remove(message.messageID);
          self._updateIdle();
          if (msg instanceof LDAPResult) {
            if (expect.indexOf(msg.status) === -1) {
              return sendResult("error", errors.getError(msg));
            }
            return sendResult("end", msg);
          } else if (msg instanceof Error) {
            return sendResult("error", msg);
          } else {
            return sendResult("error", new errors.ProtocolError(msg.type));
          }
        }
      }
      function onRequestTimeout() {
        self.emit("timeout", message);
        const cb = tracker.fetch(message.messageID);
        if (cb) {
          cb(new errors.TimeoutError("request timeout (client interrupt)"));
        }
      }
      function writeCallback() {
        if (expect === "abandon") {
          tracker.abandon(message.abandonID);
          tracker.remove(message.id);
          return callback(null);
        } else if (expect === "unbind") {
          conn.unbindMessageID = message.id;
          self.connected = false;
          conn.removeAllListeners("error");
          conn.on("error", function() {
          });
          conn.end();
        } else if (emitter) {
          sentEmitter = true;
          callback(null, emitter);
          emitter.emit("searchRequest", message);
          return;
        }
        return false;
      }
      tracker.track(message, messageCallback);
      this._updateIdle(true);
      if (self.timeout) {
        log2.trace("Setting timeout to %d", self.timeout);
        timer = setTimeout(onRequestTimeout, self.timeout);
      }
      log2.trace("sending request %j", message.json);
      try {
        return conn.write(message.toBer(), writeCallback);
      } catch (e) {
        if (timer) {
          clearTimeout(timer);
        }
        log2.trace({ err: e }, "Error writing message to socket");
        return callback(e);
      }
    };
    Client.prototype.emitError = function emitError(event, err) {
      if (event !== "error" && err && this.listenerCount(event) === 0) {
        if (typeof err === "string") {
          err = event + ": " + err;
        } else if (err.message) {
          err.message = event + ": " + err.message;
        }
        this.emit("error", err);
      }
      this.emit(event, err);
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/client/index.js
var require_client2 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/client/index.js"(exports, module) {
    "use strict";
    var logger = require_logger();
    var Client = require_client();
    module.exports = {
      Client,
      createClient: function createClient(options) {
        if (isObject(options) === false)
          throw TypeError("options (object) required");
        if (options.url && typeof options.url !== "string" && !Array.isArray(options.url))
          throw TypeError("options.url (string|array) required");
        if (options.socketPath && typeof options.socketPath !== "string")
          throw TypeError("options.socketPath must be a string");
        if (options.url && options.socketPath || !(options.url || options.socketPath))
          throw TypeError("options.url ^ options.socketPath (String) required");
        if (!options.log)
          options.log = logger;
        if (isObject(options.log) !== true)
          throw TypeError("options.log must be an object");
        if (!options.log.child)
          options.log.child = function() {
            return options.log;
          };
        return new Client(options);
      }
    };
    function isObject(input) {
      return Object.prototype.toString.apply(input) === "[object Object]";
    }
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/server.js
var require_server = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/server.js"(exports, module) {
    var assert = require_assert();
    var EventEmitter = require_events().EventEmitter;
    var net = require_net();
    var tls = require_tls();
    var util = require_util();
    var VError = require_verror2().VError;
    var dn = require_dn();
    var dtrace = require_dtrace();
    var errors = require_errors2();
    var Protocol = require_protocol();
    var Parser = require_messages().Parser;
    var AbandonResponse = require_abandon_response();
    var AddResponse = require_add_response();
    var BindResponse = require_bind_response();
    var CompareResponse = require_compare_response();
    var DeleteResponse = require_del_response();
    var ExtendedResponse = require_ext_response();
    var ModifyResponse = require_modify_response();
    var ModifyDNResponse = require_moddn_response();
    var SearchRequest = require_search_request();
    var SearchResponse = require_search_response();
    var UnbindResponse = require_unbind_response();
    var DN = dn.DN;
    function mergeFunctionArgs(argv, start, end) {
      assert.ok(argv);
      if (!start) {
        start = 0;
      }
      if (!end) {
        end = argv.length;
      }
      const handlers = [];
      for (let i = start; i < end; i++) {
        if (argv[i] instanceof Array) {
          const arr = argv[i];
          for (let j = 0; j < arr.length; j++) {
            if (!(arr[j] instanceof Function)) {
              throw new TypeError("Invalid argument type: " + typeof arr[j]);
            }
            handlers.push(arr[j]);
          }
        } else if (argv[i] instanceof Function) {
          handlers.push(argv[i]);
        } else {
          throw new TypeError("Invalid argument type: " + typeof argv[i]);
        }
      }
      return handlers;
    }
    function getResponse(req) {
      assert.ok(req);
      let Response;
      switch (req.protocolOp) {
        case Protocol.LDAP_REQ_BIND:
          Response = BindResponse;
          break;
        case Protocol.LDAP_REQ_ABANDON:
          Response = AbandonResponse;
          break;
        case Protocol.LDAP_REQ_ADD:
          Response = AddResponse;
          break;
        case Protocol.LDAP_REQ_COMPARE:
          Response = CompareResponse;
          break;
        case Protocol.LDAP_REQ_DELETE:
          Response = DeleteResponse;
          break;
        case Protocol.LDAP_REQ_EXTENSION:
          Response = ExtendedResponse;
          break;
        case Protocol.LDAP_REQ_MODIFY:
          Response = ModifyResponse;
          break;
        case Protocol.LDAP_REQ_MODRDN:
          Response = ModifyDNResponse;
          break;
        case Protocol.LDAP_REQ_SEARCH:
          Response = SearchResponse;
          break;
        case Protocol.LDAP_REQ_UNBIND:
          Response = UnbindResponse;
          break;
        default:
          return null;
      }
      assert.ok(Response);
      const res = new Response({
        messageID: req.messageID,
        log: req.log,
        attributes: req instanceof SearchRequest ? req.attributes : void 0
      });
      res.connection = req.connection;
      res.logId = req.logId;
      return res;
    }
    function defaultHandler(req, res, next) {
      assert.ok(req);
      assert.ok(res);
      assert.ok(next);
      res.matchedDN = req.dn.toString();
      res.errorMessage = "Server method not implemented";
      res.end(errors.LDAP_OTHER);
      return next();
    }
    function defaultNoOpHandler(req, res, next) {
      assert.ok(req);
      assert.ok(res);
      assert.ok(next);
      res.end();
      return next();
    }
    function noSuffixHandler(req, res, next) {
      assert.ok(req);
      assert.ok(res);
      assert.ok(next);
      res.errorMessage = "No tree found for: " + req.dn.toString();
      res.end(errors.LDAP_NO_SUCH_OBJECT);
      return next();
    }
    function noExOpHandler(req, res, next) {
      assert.ok(req);
      assert.ok(res);
      assert.ok(next);
      res.errorMessage = req.requestName + " not supported";
      res.end(errors.LDAP_PROTOCOL_ERROR);
      return next();
    }
    function fireDTraceProbe(req, res) {
      assert.ok(req);
      req._dtraceId = res._dtraceId = dtrace._nextId();
      const probeArgs = [
        req._dtraceId,
        req.connection.remoteAddress || "localhost",
        req.connection.ldap.bindDN.toString(),
        req.dn.toString()
      ];
      let op;
      switch (req.protocolOp) {
        case Protocol.LDAP_REQ_ABANDON:
          op = "abandon";
          break;
        case Protocol.LDAP_REQ_ADD:
          op = "add";
          probeArgs.push(req.attributes.length);
          break;
        case Protocol.LDAP_REQ_BIND:
          op = "bind";
          break;
        case Protocol.LDAP_REQ_COMPARE:
          op = "compare";
          probeArgs.push(req.attribute);
          probeArgs.push(req.value);
          break;
        case Protocol.LDAP_REQ_DELETE:
          op = "delete";
          break;
        case Protocol.LDAP_REQ_EXTENSION:
          op = "exop";
          probeArgs.push(req.name);
          probeArgs.push(req.value);
          break;
        case Protocol.LDAP_REQ_MODIFY:
          op = "modify";
          probeArgs.push(req.changes.length);
          break;
        case Protocol.LDAP_REQ_MODRDN:
          op = "modifydn";
          probeArgs.push(req.newRdn.toString());
          probeArgs.push(req.newSuperior ? req.newSuperior.toString() : "");
          break;
        case Protocol.LDAP_REQ_SEARCH:
          op = "search";
          probeArgs.push(req.scope);
          probeArgs.push(req.filter.toString());
          break;
        case Protocol.LDAP_REQ_UNBIND:
          op = "unbind";
          break;
        default:
          break;
      }
      res._dtraceOp = op;
      dtrace.fire("server-" + op + "-start", function() {
        return probeArgs;
      });
    }
    function Server(options) {
      if (options) {
        if (typeof options !== "object") {
          throw new TypeError("options (object) required");
        }
        if (typeof options.log !== "object") {
          throw new TypeError("options.log must be an object");
        }
        if (options.certificate || options.key) {
          if (!(options.certificate && options.key) || typeof options.certificate !== "string" && !Buffer.isBuffer(options.certificate) || typeof options.key !== "string" && !Buffer.isBuffer(options.key)) {
            throw new TypeError("options.certificate and options.key (string or buffer) are both required for TLS");
          }
        }
      } else {
        options = {};
      }
      const self = this;
      EventEmitter.call(this, options);
      this._chain = [];
      this.log = options.log;
      this.strictDN = options.strictDN !== void 0 ? options.strictDN : true;
      const log2 = this.log;
      function setupConnection(c) {
        assert.ok(c);
        if (c.type === "unix") {
          c.remoteAddress = self.server.path;
          c.remotePort = c.fd;
        } else if (c.socket) {
          c.remoteAddress = c.socket.remoteAddress;
          c.remotePort = c.socket.remotePort;
        }
        const rdn = new dn.RDN({ cn: "anonymous" });
        c.ldap = {
          id: c.remoteAddress + ":" + c.remotePort,
          config: options,
          _bindDN: new DN([rdn])
        };
        c.addListener("timeout", function() {
          log2.trace("%s timed out", c.ldap.id);
          c.destroy();
        });
        c.addListener("end", function() {
          log2.trace("%s shutdown", c.ldap.id);
        });
        c.addListener("error", function(err) {
          log2.warn("%s unexpected connection error", c.ldap.id, err);
          self.emit("clientError", err);
          c.destroy();
        });
        c.addListener("close", function(closeError) {
          log2.trace("%s close; had_err=%j", c.ldap.id, closeError);
          c.end();
        });
        c.ldap.__defineGetter__("bindDN", function() {
          return c.ldap._bindDN;
        });
        c.ldap.__defineSetter__("bindDN", function(val) {
          if (!(val instanceof DN)) {
            throw new TypeError("DN required");
          }
          c.ldap._bindDN = val;
          return val;
        });
        return c;
      }
      self.newConnection = function(conn) {
        setupConnection(conn);
        log2.trace("new connection from %s", conn.ldap.id);
        dtrace.fire("server-connection", function() {
          return [conn.remoteAddress];
        });
        conn.parser = new Parser({
          log: options.log
        });
        conn.parser.on("message", function(req) {
          req.connection = conn;
          req.logId = conn.ldap.id + "::" + req.messageID;
          req.startTime = (/* @__PURE__ */ new Date()).getTime();
          log2.debug("%s: message received: req=%j", conn.ldap.id, req.json);
          const res = getResponse(req);
          if (!res) {
            log2.warn("Unimplemented server method: %s", req.type);
            conn.destroy();
            return false;
          }
          try {
            switch (req.protocolOp) {
              case Protocol.LDAP_REQ_BIND:
                req.name = dn.parse(req.name);
                break;
              case Protocol.LDAP_REQ_ADD:
              case Protocol.LDAP_REQ_COMPARE:
              case Protocol.LDAP_REQ_DELETE:
                req.entry = dn.parse(req.entry);
                break;
              case Protocol.LDAP_REQ_MODIFY:
                req.object = dn.parse(req.object);
                break;
              case Protocol.LDAP_REQ_MODRDN:
                req.entry = dn.parse(req.entry);
                break;
              case Protocol.LDAP_REQ_SEARCH:
                req.baseObject = dn.parse(req.baseObject);
                break;
              default:
                break;
            }
          } catch (e) {
            if (self.strictDN) {
              return res.end(errors.LDAP_INVALID_DN_SYNTAX);
            }
          }
          res.connection = conn;
          res.logId = req.logId;
          res.requestDN = req.dn;
          const chain = self._getHandlerChain(req, res);
          let i = 0;
          return function messageIIFE(err) {
            function sendError(sendErr) {
              res.status = sendErr.code || errors.LDAP_OPERATIONS_ERROR;
              res.matchedDN = req.suffix ? req.suffix.toString() : "";
              res.errorMessage = sendErr.message || "";
              return res.end();
            }
            function after() {
              if (!self._postChain || !self._postChain.length) {
                return;
              }
              function next() {
              }
              self._postChain.forEach(function(cb) {
                cb.call(self, req, res, next);
              });
            }
            if (err) {
              log2.trace("%s sending error: %s", req.logId, err.stack || err);
              self.emit("clientError", err);
              sendError(err);
              return after();
            }
            try {
              const next = messageIIFE;
              if (chain.handlers[i]) {
                return chain.handlers[i++].call(chain.backend, req, res, next);
              }
              if (req.protocolOp === Protocol.LDAP_REQ_BIND && res.status === 0) {
                if (req.dn.length === 0 && req.credentials === "") {
                  conn.ldap.bindDN = new DN([new dn.RDN({ cn: "anonymous" })]);
                } else {
                  conn.ldap.bindDN = req.dn;
                }
              }
              if (req.protocolOp === Protocol.LDAP_REQ_UNBIND && res.status === 0) {
                conn.ldap.bindDN = new DN([new dn.RDN({ cn: "anonymous" })]);
              }
              return after();
            } catch (e) {
              if (!e.stack) {
                e.stack = e.toString();
              }
              log2.error("%s uncaught exception: %s", req.logId, e.stack);
              return sendError(new errors.OperationsError(e.message));
            }
          }();
        });
        conn.parser.on("error", function(err, message) {
          self.emit("error", new VError(err, "Parser error for %s", conn.ldap.id));
          if (!message) {
            return conn.destroy();
          }
          const res = getResponse(message);
          if (!res) {
            return conn.destroy();
          }
          res.status = 2;
          res.errorMessage = err.toString();
          return conn.end(res.toBer());
        });
        conn.on("data", function(data) {
          log2.trace("data on %s: %s", conn.ldap.id, util.inspect(data));
          conn.parser.write(data);
        });
      };
      this.routes = {};
      if ((options.cert || options.certificate) && options.key) {
        options.cert = options.cert || options.certificate;
        this.server = tls.createServer(options, options.connectionRouter ? options.connectionRouter : self.newConnection);
      } else {
        this.server = net.createServer(options.connectionRouter ? options.connectionRouter : self.newConnection);
      }
      this.server.log = options.log;
      this.server.ldap = {
        config: options
      };
      this.server.on("close", function() {
        self.emit("close");
      });
      this.server.on("error", function(err) {
        self.emit("error", err);
      });
    }
    util.inherits(Server, EventEmitter);
    Object.defineProperties(Server.prototype, {
      maxConnections: {
        get: function getMaxConnections() {
          return this.server.maxConnections;
        },
        set: function setMaxConnections(val) {
          this.server.maxConnections = val;
        },
        configurable: false
      },
      connections: {
        get: function getConnections() {
          return this.server.connections;
        },
        configurable: false
      },
      name: {
        get: function getName() {
          return "LDAPServer";
        },
        configurable: false
      },
      url: {
        get: function getURL() {
          let str;
          const addr = this.server.address();
          if (!addr) {
            return null;
          }
          if (!addr.family) {
            str = "ldapi://";
            str += this.host.replace(/\//g, "%2f");
            return str;
          }
          if (this.server instanceof tls.Server) {
            str = "ldaps://";
          } else {
            str = "ldap://";
          }
          let host = this.host;
          if (addr.family === "IPv6" || addr.family === 6) {
            host = "[" + this.host + "]";
          }
          str += host + ":" + this.port;
          return str;
        },
        configurable: false
      }
    });
    module.exports = Server;
    Server.prototype.add = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_ADD, name, args);
    };
    Server.prototype.bind = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_BIND, name, args);
    };
    Server.prototype.compare = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_COMPARE, name, args);
    };
    Server.prototype.del = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_DELETE, name, args);
    };
    Server.prototype.exop = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_EXTENSION, name, args, true);
    };
    Server.prototype.modify = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_MODIFY, name, args);
    };
    Server.prototype.modifyDN = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_MODRDN, name, args);
    };
    Server.prototype.search = function(name) {
      const args = Array.prototype.slice.call(arguments, 1);
      return this._mount(Protocol.LDAP_REQ_SEARCH, name, args);
    };
    Server.prototype.unbind = function() {
      const args = Array.prototype.slice.call(arguments, 0);
      return this._mount(Protocol.LDAP_REQ_UNBIND, "unbind", args, true);
    };
    Server.prototype.use = function use() {
      const args = Array.prototype.slice.call(arguments);
      const chain = mergeFunctionArgs(args, 0, args.length);
      const self = this;
      chain.forEach(function(c) {
        self._chain.push(c);
      });
    };
    Server.prototype.after = function() {
      if (!this._postChain) {
        this._postChain = [];
      }
      const self = this;
      mergeFunctionArgs(arguments).forEach(function(h) {
        self._postChain.push(h);
      });
    };
    Server.prototype.listen = function(port, host, callback) {
      if (typeof port !== "number" && typeof port !== "string") {
        throw new TypeError("port (number or path) required");
      }
      if (typeof host === "function") {
        callback = host;
        host = "0.0.0.0";
      }
      if (typeof port === "string" && /^[0-9]+$/.test(port)) {
        port = parseInt(port, 10);
      }
      const self = this;
      function cbListen() {
        if (typeof port === "number") {
          self.host = self.address().address;
          self.port = self.address().port;
        } else {
          self.host = port;
          self.port = self.server.fd;
        }
        if (typeof callback === "function") {
          callback();
        }
      }
      if (typeof port === "number") {
        return this.server.listen(port, host, cbListen);
      } else {
        return this.server.listen(port, cbListen);
      }
    };
    Server.prototype.listenFD = function(fd) {
      this.host = "unix-domain-socket";
      this.port = fd;
      return this.server.listenFD(fd);
    };
    Server.prototype.close = function(callback) {
      return this.server.close(callback);
    };
    Server.prototype.address = function() {
      return this.server.address();
    };
    Server.prototype.getConnections = function(callback) {
      return this.server.getConnections(callback);
    };
    Server.prototype._getRoute = function(_dn, backend) {
      assert.ok(dn);
      if (!backend) {
        backend = this;
      }
      let name;
      if (_dn instanceof dn.DN) {
        name = _dn.toString();
      } else {
        name = _dn;
      }
      if (!this.routes[name]) {
        this.routes[name] = {};
        this.routes[name].backend = backend;
        this.routes[name].dn = _dn;
        this._routeKeyCache = null;
      }
      return this.routes[name];
    };
    Server.prototype._sortedRouteKeys = function _sortedRouteKeys() {
      if (!this._routeKeyCache) {
        const self = this;
        const reversedRDNsToKeys = {};
        Object.keys(this.routes).forEach(function(key) {
          const _dn = self.routes[key].dn;
          if (_dn instanceof dn.DN) {
            const reversed = _dn.clone();
            reversed.rdns.reverse();
            reversedRDNsToKeys[reversed.format()] = key;
          }
        });
        const output = [];
        Object.keys(reversedRDNsToKeys).sort().reverse().forEach(function(_dn) {
          output.push(reversedRDNsToKeys[_dn]);
        });
        this._routeKeyCache = output;
      }
      return this._routeKeyCache;
    };
    Server.prototype._getHandlerChain = function _getHandlerChain(req, res) {
      assert.ok(req);
      fireDTraceProbe(req, res);
      const self = this;
      const routes = this.routes;
      let route;
      if (req.protocolOp === Protocol.LDAP_REQ_BIND && req.dn.toString() === "" && req.credentials === "") {
        return {
          backend: self,
          handlers: [defaultNoOpHandler]
        };
      }
      const op = "0x" + req.protocolOp.toString(16);
      if (req.protocolOp === Protocol.LDAP_REQ_EXTENSION) {
        route = routes[req.requestName];
        if (route) {
          return {
            backend: route.backend,
            handlers: route[op] ? route[op] : [noExOpHandler]
          };
        } else {
          return {
            backend: self,
            handlers: [noExOpHandler]
          };
        }
      } else if (req.protocolOp === Protocol.LDAP_REQ_UNBIND) {
        route = routes.unbind;
        if (route) {
          return {
            backend: route.backend,
            handlers: route[op]
          };
        } else {
          return {
            backend: self,
            handlers: [defaultNoOpHandler]
          };
        }
      } else if (req.protocolOp === Protocol.LDAP_REQ_ABANDON) {
        return {
          backend: self,
          handlers: [defaultNoOpHandler]
        };
      }
      assert.ok(req.dn);
      const keys = this._sortedRouteKeys();
      let fallbackHandler = [noSuffixHandler];
      const testDN = typeof req.dn === "string" ? "" : req.dn;
      for (let i = 0; i < keys.length; i++) {
        const suffix = keys[i];
        route = routes[suffix];
        assert.ok(route.dn);
        if (route.dn.equals(testDN) || route.dn.parentOf(testDN) || suffix === "") {
          if (route[op]) {
            req.suffix = route.dn;
            return {
              backend: route.backend,
              handlers: route[op]
            };
          } else {
            if (suffix === "") {
              break;
            } else {
              fallbackHandler = [defaultHandler];
            }
          }
        }
      }
      return {
        backend: self,
        handlers: fallbackHandler
      };
    };
    Server.prototype._mount = function(op, name, argv, notDN) {
      assert.ok(op);
      assert.ok(name !== void 0);
      assert.ok(argv);
      if (typeof name !== "string") {
        throw new TypeError("name (string) required");
      }
      if (!argv.length) {
        throw new Error("at least one handler required");
      }
      let backend = this;
      let index2 = 0;
      if (typeof argv[0] === "object" && !Array.isArray(argv[0])) {
        backend = argv[0];
        index2 = 1;
      }
      const route = this._getRoute(notDN ? name : dn.parse(name), backend);
      const chain = this._chain.slice();
      argv.slice(index2).forEach(function(a) {
        chain.push(a);
      });
      route["0x" + op.toString(16)] = mergeFunctionArgs(chain);
      return this;
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/persistent_search.js
var require_persistent_search = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/persistent_search.js"(exports, module) {
    var EntryChangeNotificationControl = require_controls().EntryChangeNotificationControl;
    function PersistentSearch() {
      this.clientList = [];
    }
    PersistentSearch.prototype.addClient = function(req, res, callback) {
      if (typeof req !== "object") {
        throw new TypeError("req must be an object");
      }
      if (typeof res !== "object") {
        throw new TypeError("res must be an object");
      }
      if (callback && typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      const log2 = req.log;
      const client = {};
      client.req = req;
      client.res = res;
      log2.debug("%s storing client", req.logId);
      this.clientList.push(client);
      log2.debug("%s stored client", req.logId);
      log2.debug(
        "%s total number of clients %s",
        req.logId,
        this.clientList.length
      );
      if (callback) {
        callback(client);
      }
    };
    PersistentSearch.prototype.removeClient = function(req, res, callback) {
      if (typeof req !== "object") {
        throw new TypeError("req must be an object");
      }
      if (typeof res !== "object") {
        throw new TypeError("res must be an object");
      }
      if (callback && typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      const log2 = req.log;
      log2.debug("%s removing client", req.logId);
      const client = {};
      client.req = req;
      client.res = res;
      this.clientList.forEach(function(element, index2, array) {
        if (element.req === client.req) {
          log2.debug("%s removing client from list", req.logId);
          array.splice(index2, 1);
        }
      });
      log2.debug(
        "%s number of persistent search clients %s",
        req.logId,
        this.clientList.length
      );
      if (callback) {
        callback(client);
      }
    };
    function getOperationType(requestType) {
      switch (requestType) {
        case "AddRequest":
        case "add":
          return 1;
        case "DeleteRequest":
        case "delete":
          return 2;
        case "ModifyRequest":
        case "modify":
          return 4;
        case "ModifyDNRequest":
        case "modrdn":
          return 8;
        default:
          throw new TypeError(
            "requestType %s, is an invalid request type",
            requestType
          );
      }
    }
    function getEntryChangeNotificationControl(req, obj) {
      if (req.persistentSearch.value.returnECs) {
        const attrs = obj.attributes;
        const value = {};
        value.changeType = getOperationType(attrs.changetype);
        if (value.changeType === 8 && attrs.previousDN) {
          value.previousDN = attrs.previousDN;
        }
        value.changeNumber = attrs.changenumber;
        return new EntryChangeNotificationControl({ value });
      } else {
        return false;
      }
    }
    function checkChangeType(req, requestType) {
      return req.persistentSearch.value.changeTypes & getOperationType(requestType);
    }
    module.exports = {
      PersistentSearchCache: PersistentSearch,
      checkChangeType,
      getEntryChangeNotificationControl
    };
  }
});

// node_modules/activedirectory2/node_modules/ldapjs/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/activedirectory2/node_modules/ldapjs/lib/index.js"(exports, module) {
    var logger = require_logger();
    var client = require_client2();
    var Attribute = require_attribute();
    var Change = require_change();
    var Protocol = require_protocol();
    var Server = require_server();
    var controls = require_controls();
    var persistentSearch = require_persistent_search();
    var dn = require_dn();
    var errors = require_errors2();
    var filters = require_filters();
    var messages = require_messages();
    var url = require_url2();
    var hasOwnProperty = (target, val) => Object.prototype.hasOwnProperty.call(target, val);
    module.exports = {
      Client: client.Client,
      createClient: client.createClient,
      Server,
      createServer: function(options) {
        if (options === void 0) {
          options = {};
        }
        if (typeof options !== "object") {
          throw new TypeError("options (object) required");
        }
        if (!options.log) {
          options.log = logger;
        }
        return new Server(options);
      },
      Attribute,
      Change,
      dn,
      DN: dn.DN,
      RDN: dn.RDN,
      parseDN: dn.parse,
      persistentSearch,
      PersistentSearchCache: persistentSearch.PersistentSearchCache,
      filters,
      parseFilter: filters.parseString,
      url,
      parseURL: url.parse
    };
    var k;
    for (k in Protocol) {
      if (hasOwnProperty(Protocol, k)) {
        module.exports[k] = Protocol[k];
      }
    }
    for (k in messages) {
      if (hasOwnProperty(messages, k)) {
        module.exports[k] = messages[k];
      }
    }
    for (k in controls) {
      if (hasOwnProperty(controls, k)) {
        module.exports[k] = controls[k];
      }
    }
    for (k in filters) {
      if (hasOwnProperty(filters, k)) {
        if (k !== "parse" && k !== "parseString") {
          module.exports[k] = filters[k];
        }
      }
    }
    for (k in errors) {
      if (hasOwnProperty(errors, k)) {
        module.exports[k] = errors[k];
      }
    }
  }
});

// node_modules/async/dist/async.mjs
var async_exports = {};
__export(async_exports, {
  all: () => every$1,
  allLimit: () => everyLimit$1,
  allSeries: () => everySeries$1,
  any: () => some$1,
  anyLimit: () => someLimit$1,
  anySeries: () => someSeries$1,
  apply: () => apply,
  applyEach: () => applyEach$1,
  applyEachSeries: () => applyEachSeries,
  asyncify: () => asyncify,
  auto: () => auto,
  autoInject: () => autoInject,
  cargo: () => cargo,
  cargoQueue: () => cargo$1,
  compose: () => compose,
  concat: () => concat$1,
  concatLimit: () => concatLimit$1,
  concatSeries: () => concatSeries$1,
  constant: () => constant,
  default: () => async_default,
  detect: () => detect$1,
  detectLimit: () => detectLimit$1,
  detectSeries: () => detectSeries$1,
  dir: () => dir,
  doDuring: () => doWhilst$1,
  doUntil: () => doUntil,
  doWhilst: () => doWhilst$1,
  during: () => whilst$1,
  each: () => each,
  eachLimit: () => eachLimit$2,
  eachOf: () => eachOf$1,
  eachOfLimit: () => eachOfLimit$2,
  eachOfSeries: () => eachOfSeries$1,
  eachSeries: () => eachSeries$1,
  ensureAsync: () => ensureAsync,
  every: () => every$1,
  everyLimit: () => everyLimit$1,
  everySeries: () => everySeries$1,
  filter: () => filter$1,
  filterLimit: () => filterLimit$1,
  filterSeries: () => filterSeries$1,
  find: () => detect$1,
  findLimit: () => detectLimit$1,
  findSeries: () => detectSeries$1,
  flatMap: () => concat$1,
  flatMapLimit: () => concatLimit$1,
  flatMapSeries: () => concatSeries$1,
  foldl: () => reduce$1,
  foldr: () => reduceRight,
  forEach: () => each,
  forEachLimit: () => eachLimit$2,
  forEachOf: () => eachOf$1,
  forEachOfLimit: () => eachOfLimit$2,
  forEachOfSeries: () => eachOfSeries$1,
  forEachSeries: () => eachSeries$1,
  forever: () => forever$1,
  groupBy: () => groupBy,
  groupByLimit: () => groupByLimit$1,
  groupBySeries: () => groupBySeries,
  inject: () => reduce$1,
  log: () => log,
  map: () => map$1,
  mapLimit: () => mapLimit$1,
  mapSeries: () => mapSeries$1,
  mapValues: () => mapValues,
  mapValuesLimit: () => mapValuesLimit$1,
  mapValuesSeries: () => mapValuesSeries,
  memoize: () => memoize,
  nextTick: () => nextTick,
  parallel: () => parallel$1,
  parallelLimit: () => parallelLimit,
  priorityQueue: () => priorityQueue,
  queue: () => queue$1,
  race: () => race$1,
  reduce: () => reduce$1,
  reduceRight: () => reduceRight,
  reflect: () => reflect,
  reflectAll: () => reflectAll,
  reject: () => reject$2,
  rejectLimit: () => rejectLimit$1,
  rejectSeries: () => rejectSeries$1,
  retry: () => retry,
  retryable: () => retryable,
  select: () => filter$1,
  selectLimit: () => filterLimit$1,
  selectSeries: () => filterSeries$1,
  seq: () => seq,
  series: () => series,
  setImmediate: () => setImmediate$1,
  some: () => some$1,
  someLimit: () => someLimit$1,
  someSeries: () => someSeries$1,
  sortBy: () => sortBy$1,
  timeout: () => timeout,
  times: () => times,
  timesLimit: () => timesLimit,
  timesSeries: () => timesSeries,
  transform: () => transform,
  tryEach: () => tryEach$1,
  unmemoize: () => unmemoize,
  until: () => until,
  waterfall: () => waterfall$1,
  whilst: () => whilst$1,
  wrapSync: () => asyncify
});
function apply(fn, ...args) {
  return (...callArgs) => fn(...args, ...callArgs);
}
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
function asyncify(func) {
  if (isAsync(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise = func.apply(this, args);
      return handlePromise(promise, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise, callback) {
  return promise.then((value) => {
    invokeCallback(callback, null, value);
  }, (err) => {
    invokeCallback(callback, err && err.message ? err : new Error(err));
  });
}
function invokeCallback(callback, error, value) {
  try {
    callback(error, value);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
function isAsync(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function")
    throw new Error("expected a function");
  return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity = asyncFn.length) {
  if (!arity)
    throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve, reject2) => {
      args[arity - 1] = (err, ...cbArgs) => {
        if (err)
          return reject2(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  return awaitable;
}
function applyEach(eachfn) {
  return function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _, iterCb) => {
    var index2 = counter++;
    _iteratee(value, (err, v) => {
      results[index2] = v;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
function isArrayLike(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
function once(fn) {
  function wrapper(...args) {
    if (fn === null)
      return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  Object.assign(wrapper, fn);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return function next() {
    return ++i < len ? { value: coll[i], key: i } : null;
  };
}
function createES2015Iterator(iterator) {
  var i = -1;
  return function next() {
    var item = iterator.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i];
    if (key === "__proto__") {
      return next();
    }
    return i < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike(coll)) {
    return createArrayIterator(coll);
  }
  var iterator = getIterator(coll);
  return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null)
      throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done)
      return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done)
        return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled)
      return;
    if (err)
      return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err) {
    if (canceled)
      return;
    awaiting = false;
    done = true;
    callback(err);
  }
  replenish();
}
function eachOfLimit$1(coll, limit, iteratee, callback) {
  return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once(callback);
  var index2 = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true)
      return;
    if (err) {
      callback(err);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  for (; index2 < length; index2++) {
    iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$2(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
function map(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$2(coll, 1, iteratee, callback);
}
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
function promiseCallback() {
  let resolve, reject2;
  function callback(err, ...args) {
    if (err)
      return reject2(err);
    resolve(args.length > 1 ? args : args[0]);
  }
  callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
    resolve = res, reject2 = rej;
  });
  return callback;
}
function auto(tasks, concurrency, callback) {
  if (typeof concurrency !== "number") {
    callback = concurrency;
    concurrency = null;
  }
  callback = once(callback || promiseCallback());
  var numTasks = Object.keys(tasks).length;
  if (!numTasks) {
    return callback(null);
  }
  if (!concurrency) {
    concurrency = numTasks;
  }
  var results = {};
  var runningTasks = 0;
  var canceled = false;
  var hasError = false;
  var listeners = /* @__PURE__ */ Object.create(null);
  var readyTasks = [];
  var readyToCheck = [];
  var uncheckedDependencies = {};
  Object.keys(tasks).forEach((key) => {
    var task = tasks[key];
    if (!Array.isArray(task)) {
      enqueueTask(key, [task]);
      readyToCheck.push(key);
      return;
    }
    var dependencies = task.slice(0, task.length - 1);
    var remainingDependencies = dependencies.length;
    if (remainingDependencies === 0) {
      enqueueTask(key, task);
      readyToCheck.push(key);
      return;
    }
    uncheckedDependencies[key] = remainingDependencies;
    dependencies.forEach((dependencyName) => {
      if (!tasks[dependencyName]) {
        throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
      }
      addListener(dependencyName, () => {
        remainingDependencies--;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
        }
      });
    });
  });
  checkForDeadlocks();
  processQueue();
  function enqueueTask(key, task) {
    readyTasks.push(() => runTask(key, task));
  }
  function processQueue() {
    if (canceled)
      return;
    if (readyTasks.length === 0 && runningTasks === 0) {
      return callback(null, results);
    }
    while (readyTasks.length && runningTasks < concurrency) {
      var run = readyTasks.shift();
      run();
    }
  }
  function addListener(taskName, fn) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
      taskListeners = listeners[taskName] = [];
    }
    taskListeners.push(fn);
  }
  function taskComplete(taskName) {
    var taskListeners = listeners[taskName] || [];
    taskListeners.forEach((fn) => fn());
    processQueue();
  }
  function runTask(key, task) {
    if (hasError)
      return;
    var taskCallback = onlyOnce((err, ...result) => {
      runningTasks--;
      if (err === false) {
        canceled = true;
        return;
      }
      if (result.length < 2) {
        [result] = result;
      }
      if (err) {
        var safeResults = {};
        Object.keys(results).forEach((rkey) => {
          safeResults[rkey] = results[rkey];
        });
        safeResults[key] = result;
        hasError = true;
        listeners = /* @__PURE__ */ Object.create(null);
        if (canceled)
          return;
        callback(err, safeResults);
      } else {
        results[key] = result;
        taskComplete(key);
      }
    });
    runningTasks++;
    var taskFn = wrapAsync(task[task.length - 1]);
    if (task.length > 1) {
      taskFn(results, taskCallback);
    } else {
      taskFn(taskCallback);
    }
  }
  function checkForDeadlocks() {
    var currentTask;
    var counter = 0;
    while (readyToCheck.length) {
      currentTask = readyToCheck.pop();
      counter++;
      getDependents(currentTask).forEach((dependent) => {
        if (--uncheckedDependencies[dependent] === 0) {
          readyToCheck.push(dependent);
        }
      });
    }
    if (counter !== numTasks) {
      throw new Error(
        "async.auto cannot execute tasks due to a recursive dependency"
      );
    }
  }
  function getDependents(taskName) {
    var result = [];
    Object.keys(tasks).forEach((key) => {
      const task = tasks[key];
      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
        result.push(key);
      }
    });
    return result;
  }
  return callback[PROMISE_SYMBOL];
}
function stripComments(string) {
  let stripped = "";
  let index2 = 0;
  let endBlockComment = string.indexOf("*/");
  while (index2 < string.length) {
    if (string[index2] === "/" && string[index2 + 1] === "/") {
      let endIndex = string.indexOf("\n", index2);
      index2 = endIndex === -1 ? string.length : endIndex;
    } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
      let endIndex = string.indexOf("*/", index2);
      if (endIndex !== -1) {
        index2 = endIndex + 2;
        endBlockComment = string.indexOf("*/", index2);
      } else {
        stripped += string[index2];
        index2++;
      }
    } else {
      stripped += string[index2];
      index2++;
    }
  }
  return stripped;
}
function parseParams(func) {
  const src = stripComments(func.toString());
  let match = src.match(FN_ARGS);
  if (!match) {
    match = src.match(ARROW_FN_ARGS);
  }
  if (!match)
    throw new Error("could not parse args in autoInject\nSource:\n" + src);
  let [, args] = match;
  return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
}
function autoInject(tasks, callback) {
  var newTasks = {};
  Object.keys(tasks).forEach((key) => {
    var taskFn = tasks[key];
    var params;
    var fnIsAsync = isAsync(taskFn);
    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
    if (Array.isArray(taskFn)) {
      params = [...taskFn];
      taskFn = params.pop();
      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
    } else if (hasNoDeps) {
      newTasks[key] = taskFn;
    } else {
      params = parseParams(taskFn);
      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
        throw new Error("autoInject task functions require explicit parameters.");
      }
      if (!fnIsAsync)
        params.pop();
      newTasks[key] = params.concat(newTask);
    }
    function newTask(results, taskCb) {
      var newArgs = params.map((name) => results[name]);
      newArgs.push(taskCb);
      wrapAsync(taskFn)(...newArgs);
    }
  });
  return auto(newTasks, callback);
}
function setInitial(dll, node) {
  dll.length = 1;
  dll.head = dll.tail = node;
}
function queue(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on(event, handler) {
    events[event].push(handler);
  }
  function once2(event, handler) {
    const handleAndRemove = (...args) => {
      off(event, handleAndRemove);
      handler(...args);
    };
    events[event].push(handleAndRemove);
  }
  function off(event, handler) {
    if (!event)
      return Object.keys(events).forEach((ev) => events[ev] = []);
    if (!handler)
      return events[event] = [];
    events[event] = events[event].filter((ev) => ev !== handler);
  }
  function trigger(event, ...args) {
    events[event].forEach((handler) => handler(...args));
  }
  var processingScheduled = false;
  function _insert(data, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback2(err, ...args) {
      if (err)
        return rejectOnError ? rej(err) : res();
      if (args.length <= 1)
        return res(args[0]);
      res(args);
    }
    var item = q._createTaskItem(
      data,
      rejectOnError ? promiseCallback2 : callback || promiseCallback2
    );
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve, reject2) => {
        res = resolve;
        rej = reject2;
      });
    }
  }
  function _createCB(tasks) {
    return function(err, ...args) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index2 = workersList.indexOf(task);
        if (index2 === 0) {
          workersList.shift();
        } else if (index2 > 0) {
          workersList.splice(index2, 1);
        }
        task.callback(err, ...args);
        if (err != null) {
          trigger("error", err, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  function _maybeDrain(data) {
    if (data.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  const eventMethod = (name) => (handler) => {
    if (!handler) {
      return new Promise((resolve, reject2) => {
        once2(name, (err, data) => {
          if (err)
            return reject2(err);
          resolve(data);
        });
      });
    }
    off(name);
    on(name, handler);
  };
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    _createTaskItem(data, callback) {
      return {
        data,
        callback
      };
    },
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data, false, false, callback);
    },
    pushAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data, false, true, callback);
    },
    kill() {
      off();
      q._tasks.empty();
    },
    unshift(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data, true, false, callback);
    },
    unshiftAsync(data, callback) {
      if (Array.isArray(data)) {
        if (_maybeDrain(data))
          return;
        return data.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data = [];
        var l = q._tasks.length;
        if (q.payload)
          l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node = q._tasks.shift();
          tasks.push(node);
          workersList.push(node);
          data.push(node.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
function cargo(worker, payload) {
  return queue(worker, 1, payload);
}
function cargo$1(worker, concurrency, payload) {
  return queue(worker, concurrency, payload);
}
function reduce(coll, memo, iteratee, callback) {
  callback = once(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err, v) => {
      memo = v;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
function seq(...functions) {
  var _functions = functions.map(wrapAsync);
  return function(...args) {
    var that = this;
    var cb = args[args.length - 1];
    if (typeof cb == "function") {
      args.pop();
    } else {
      cb = promiseCallback();
    }
    reduce$1(
      _functions,
      args,
      (newargs, fn, iterCb) => {
        fn.apply(that, newargs.concat((err, ...nextargs) => {
          iterCb(err, nextargs);
        }));
      },
      (err, results) => cb(err, ...results)
    );
    return cb[PROMISE_SYMBOL];
  };
}
function compose(...args) {
  return seq(...args.reverse());
}
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
}
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, ...args) => {
      if (err)
        return iterCb(err);
      return iterCb(err, args);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err, result);
  });
}
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
function constant(...args) {
  return function(...ignoredArgs) {
    var callback = ignoredArgs.pop();
    return callback(null, ...args);
  };
}
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _, callback) => {
      iteratee(value, (err, result) => {
        if (err || err === false)
          return callback(err);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err)
        return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
}
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
}
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
function doWhilst(iteratee, test, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results;
  function next(err, ...args) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    results = args;
    _test(...args, check);
  }
  function check(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return check(null, true);
}
function doUntil(iteratee, test, callback) {
  const _test = wrapAsync(test);
  return doWhilst$1(iteratee, (...args) => {
    const cb = args.pop();
    _test(...args, (err, truth) => cb(err, !truth));
  }, callback);
}
function _withoutIndex(iteratee) {
  return (value, index2, callback) => iteratee(value, callback);
}
function eachLimit(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachLimit$1(coll, limit, iteratee, callback) {
  return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
function eachSeries(coll, iteratee, callback) {
  return eachLimit$2(coll, 1, iteratee, callback);
}
function ensureAsync(fn) {
  if (isAsync(fn))
    return fn;
  return function(...args) {
    var callback = args.pop();
    var sync = true;
    args.push((...innerArgs) => {
      if (sync) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync = false;
  };
}
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
}
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      truthValues[index2] = !!v;
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i])
        results.push(arr[i]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      if (err)
        return iterCb(err);
      if (v) {
        results.push({ index: index2, value: x });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err)
      return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
  return filter2(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit(limit), coll, iteratee, callback);
}
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next(err) {
    if (err)
      return done(err);
    if (err === false)
      return;
    task(next);
  }
  return next();
}
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err)
        return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
function groupBy(coll, iteratee, callback) {
  return groupByLimit$1(coll, Infinity, iteratee, callback);
}
function groupBySeries(coll, iteratee, callback) {
  return groupByLimit$1(coll, 1, iteratee, callback);
}
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err, result) => {
      if (err)
        return next(err);
      newObj[key] = result;
      next(err);
    });
  }, (err) => callback(err, newObj));
}
function mapValues(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, Infinity, iteratee, callback);
}
function mapValuesSeries(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, 1, iteratee, callback);
}
function memoize(fn, hasher = (v) => v) {
  var memo = /* @__PURE__ */ Object.create(null);
  var queues = /* @__PURE__ */ Object.create(null);
  var _fn = wrapAsync(fn);
  var memoized = initialParams((args, callback) => {
    var key = hasher(...args);
    if (key in memo) {
      setImmediate$1(() => callback(null, ...memo[key]));
    } else if (key in queues) {
      queues[key].push(callback);
    } else {
      queues[key] = [callback];
      _fn(...args, (err, ...resultArgs) => {
        if (!err) {
          memo[key] = resultArgs;
        }
        var q = queues[key];
        delete queues[key];
        for (var i = 0, l = q.length; i < l; i++) {
          q[i](err, ...resultArgs);
        }
      });
    }
  });
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}
function parallel$1(tasks, callback) {
  return parallel(eachOf$1, tasks, callback);
}
function parallelLimit(tasks, limit, callback) {
  return parallel(eachOfLimit(limit), tasks, callback);
}
function queue$1(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
function leftChi(i) {
  return (i << 1) + 1;
}
function parent(i) {
  return (i + 1 >> 1) - 1;
}
function smaller(x, y) {
  if (x.priority !== y.priority) {
    return x.priority < y.priority;
  } else {
    return x.pushCount < y.pushCount;
  }
}
function priorityQueue(worker, concurrency) {
  var q = queue$1(worker, concurrency);
  var {
    push,
    pushAsync
  } = q;
  q._tasks = new Heap();
  q._createTaskItem = ({ data, priority }, callback) => {
    return {
      data,
      priority,
      callback
    };
  };
  function createDataItems(tasks, priority) {
    if (!Array.isArray(tasks)) {
      return { data: tasks, priority };
    }
    return tasks.map((data) => {
      return { data, priority };
    });
  }
  q.push = function(data, priority = 0, callback) {
    return push(createDataItems(data, priority), callback);
  };
  q.pushAsync = function(data, priority = 0, callback) {
    return pushAsync(createDataItems(data, priority), callback);
  };
  delete q.unshift;
  delete q.unshiftAsync;
  return q;
}
function race(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length)
    return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
function reduceRight(array, memo, iteratee, callback) {
  var reversed = [...array].reverse();
  return reduce$1(reversed, memo, iteratee, callback);
}
function reflect(fn) {
  var _fn = wrapAsync(fn);
  return initialParams(function reflectOn(args, reflectCallback) {
    args.push((error, ...cbArgs) => {
      let retVal = {};
      if (error) {
        retVal.error = error;
      }
      if (cbArgs.length > 0) {
        var value = cbArgs;
        if (cbArgs.length <= 1) {
          [value] = cbArgs;
        }
        retVal.value = value;
      }
      reflectCallback(null, retVal);
    });
    return _fn.apply(this, args);
  });
}
function reflectAll(tasks) {
  var results;
  if (Array.isArray(tasks)) {
    results = tasks.map(reflect);
  } else {
    results = {};
    Object.keys(tasks).forEach((key) => {
      results[key] = reflect.call(this, tasks[key]);
    });
  }
  return results;
}
function reject(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err, v) => {
      cb(err, !v);
    });
  }, callback);
}
function reject$1(coll, iteratee, callback) {
  return reject(eachOf$1, coll, iteratee, callback);
}
function rejectLimit(coll, limit, iteratee, callback) {
  return reject(eachOfLimit(limit), coll, iteratee, callback);
}
function rejectSeries(coll, iteratee, callback) {
  return reject(eachOfSeries$1, coll, iteratee, callback);
}
function constant$1(value) {
  return function() {
    return value;
  };
}
function retry(opts, task, callback) {
  var options = {
    times: DEFAULT_TIMES,
    intervalFunc: constant$1(DEFAULT_INTERVAL)
  };
  if (arguments.length < 3 && typeof opts === "function") {
    callback = task || promiseCallback();
    task = opts;
  } else {
    parseTimes(options, opts);
    callback = callback || promiseCallback();
  }
  if (typeof task !== "function") {
    throw new Error("Invalid arguments for async.retry");
  }
  var _task = wrapAsync(task);
  var attempt = 1;
  function retryAttempt() {
    _task((err, ...args) => {
      if (err === false)
        return;
      if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
      } else {
        callback(err, ...args);
      }
    });
  }
  retryAttempt();
  return callback[PROMISE_SYMBOL];
}
function parseTimes(acc, t) {
  if (typeof t === "object") {
    acc.times = +t.times || DEFAULT_TIMES;
    acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
    acc.errorFilter = t.errorFilter;
  } else if (typeof t === "number" || typeof t === "string") {
    acc.times = +t || DEFAULT_TIMES;
  } else {
    throw new Error("Invalid arguments for async.retry");
  }
}
function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  let arity = opts && opts.arity || task.length;
  if (isAsync(task)) {
    arity += 1;
  }
  var _task = wrapAsync(task);
  return initialParams((args, callback) => {
    if (args.length < arity - 1 || callback == null) {
      args.push(callback);
      callback = promiseCallback();
    }
    function taskFn(cb) {
      _task(...args, cb);
    }
    if (opts)
      retry(opts, taskFn, callback);
    else
      retry(taskFn, callback);
    return callback[PROMISE_SYMBOL];
  });
}
function series(tasks, callback) {
  return parallel(eachOfSeries$1, tasks, callback);
}
function some(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
}
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1(coll, (x, iterCb) => {
    _iteratee(x, (err, criteria) => {
      if (err)
        return iterCb(err);
      iterCb(err, { value: x, criteria });
    });
  }, (err, results) => {
    if (err)
      return callback(err);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
function timeout(asyncFn, milliseconds, info) {
  var fn = wrapAsync(asyncFn);
  return initialParams((args, callback) => {
    var timedOut = false;
    var timer;
    function timeoutCallback() {
      var name = asyncFn.name || "anonymous";
      var error = new Error('Callback function "' + name + '" timed out.');
      error.code = "ETIMEDOUT";
      if (info) {
        error.info = info;
      }
      timedOut = true;
      callback(error);
    }
    args.push((...cbArgs) => {
      if (!timedOut) {
        callback(...cbArgs);
        clearTimeout(timer);
      }
    });
    timer = setTimeout(timeoutCallback, milliseconds);
    fn(...args);
  });
}
function range(size) {
  var result = Array(size);
  while (size--) {
    result[size] = size;
  }
  return result;
}
function timesLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(range(count), limit, _iteratee, callback);
}
function times(n, iteratee, callback) {
  return timesLimit(n, Infinity, iteratee, callback);
}
function timesSeries(n, iteratee, callback) {
  return timesLimit(n, 1, iteratee, callback);
}
function transform(coll, accumulator, iteratee, callback) {
  if (arguments.length <= 3 && typeof accumulator === "function") {
    callback = iteratee;
    iteratee = accumulator;
    accumulator = Array.isArray(coll) ? [] : {};
  }
  callback = once(callback || promiseCallback());
  var _iteratee = wrapAsync(iteratee);
  eachOf$1(coll, (v, k, cb) => {
    _iteratee(accumulator, v, k, cb);
  }, (err) => callback(err, accumulator));
  return callback[PROMISE_SYMBOL];
}
function tryEach(tasks, callback) {
  var error = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args) => {
      if (err === false)
        return taskCb(err);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error, result));
}
function unmemoize(fn) {
  return (...args) => {
    return (fn.unmemoized || fn)(...args);
  };
}
function whilst(test, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test);
  var results = [];
  function next(err, ...rest) {
    if (err)
      return callback(err);
    results = rest;
    if (err === false)
      return;
    _test(check);
  }
  function check(err, truth) {
    if (err)
      return callback(err);
    if (err === false)
      return;
    if (!truth)
      return callback(null, ...results);
    _fn(next);
  }
  return _test(check);
}
function until(test, iteratee, callback) {
  const _test = wrapAsync(test);
  return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
}
function waterfall(tasks, callback) {
  callback = once(callback);
  if (!Array.isArray(tasks))
    return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length)
    return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next));
  }
  function next(err, ...args) {
    if (err === false)
      return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args);
    }
    nextTask(args);
  }
  nextTask([]);
}
var hasQueueMicrotask, hasSetImmediate, hasNextTick, _defer, setImmediate$1, breakLoop, eachOfLimit, eachOfLimit$2, eachOf$1, map$1, applyEach$1, eachOfSeries$1, mapSeries$1, applyEachSeries, PROMISE_SYMBOL, FN_ARGS, ARROW_FN_ARGS, FN_ARG_SPLIT, FN_ARG, DLL, reduce$1, mapLimit$1, concatLimit$1, concat$1, concatSeries$1, detect$1, detectLimit$1, detectSeries$1, dir, doWhilst$1, each, eachLimit$2, eachSeries$1, every$1, everyLimit$1, everySeries$1, filter$1, filterLimit$1, filterSeries$1, forever$1, groupByLimit$1, log, mapValuesLimit$1, _defer$1, nextTick, parallel, Heap, race$1, reject$2, rejectLimit$1, rejectSeries$1, DEFAULT_TIMES, DEFAULT_INTERVAL, some$1, someLimit$1, someSeries$1, sortBy$1, tryEach$1, whilst$1, waterfall$1, index, async_default;
var init_async = __esm({
  "node_modules/async/dist/async.mjs"() {
    hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    setImmediate$1 = wrap(_defer);
    breakLoop = {};
    eachOfLimit = (limit) => {
      return (obj, iteratee, callback) => {
        callback = once(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if (isAsyncGenerator(obj)) {
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        }
        if (isAsyncIterable(obj)) {
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = createIterator(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
    eachOf$1 = awaitify(eachOf, 3);
    map$1 = awaitify(map, 3);
    applyEach$1 = applyEach(map$1);
    eachOfSeries$1 = awaitify(eachOfSeries, 3);
    mapSeries$1 = awaitify(mapSeries, 3);
    applyEachSeries = applyEach(mapSeries$1);
    PROMISE_SYMBOL = Symbol("promiseCallback");
    FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
    ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
    FN_ARG_SPLIT = /,/;
    FN_ARG = /(=.+)?(\s*)$/;
    DLL = class {
      constructor() {
        this.head = this.tail = null;
        this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        node.prev = node.next = null;
        this.length -= 1;
        return node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        newNode.prev = node;
        newNode.next = node.next;
        if (node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode;
        this.length += 1;
      }
      insertBefore(node, newNode) {
        newNode.prev = node.prev;
        newNode.next = node;
        if (node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode;
        this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur) {
          yield cur.data;
          cur = cur.next;
        }
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr)) {
            this.removeLink(curr);
          }
          curr = next;
        }
        return this;
      }
    };
    reduce$1 = awaitify(reduce, 4);
    mapLimit$1 = awaitify(mapLimit, 4);
    concatLimit$1 = awaitify(concatLimit, 4);
    concat$1 = awaitify(concat, 3);
    concatSeries$1 = awaitify(concatSeries, 3);
    detect$1 = awaitify(detect, 3);
    detectLimit$1 = awaitify(detectLimit, 4);
    detectSeries$1 = awaitify(detectSeries, 3);
    dir = consoleFunc("dir");
    doWhilst$1 = awaitify(doWhilst, 3);
    each = awaitify(eachLimit, 3);
    eachLimit$2 = awaitify(eachLimit$1, 4);
    eachSeries$1 = awaitify(eachSeries, 3);
    every$1 = awaitify(every, 3);
    everyLimit$1 = awaitify(everyLimit, 4);
    everySeries$1 = awaitify(everySeries, 3);
    filter$1 = awaitify(filter, 3);
    filterLimit$1 = awaitify(filterLimit, 4);
    filterSeries$1 = awaitify(filterSeries, 3);
    forever$1 = awaitify(forever, 2);
    groupByLimit$1 = awaitify(groupByLimit, 4);
    log = consoleFunc("log");
    mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    if (hasNextTick) {
      _defer$1 = process.nextTick;
    } else if (hasSetImmediate) {
      _defer$1 = setImmediate;
    } else {
      _defer$1 = fallback;
    }
    nextTick = wrap(_defer$1);
    parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2) {
            [result] = result;
          }
          results[key] = result;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    Heap = class {
      constructor() {
        this.heap = [];
        this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        this.heap = [];
        return this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p];
          this.heap[p] = t;
          index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
            l = l + 1;
          }
          if (smaller(this.heap[index2], this.heap[l])) {
            break;
          }
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l];
          this.heap[l] = t;
          index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount;
        this.heap.push(node);
        this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        this.heap[0] = this.heap[this.heap.length - 1];
        this.heap.pop();
        this.percDown(0);
        return top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0; i < this.heap.length; i++) {
          yield this.heap[i].data;
        }
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0; i < this.heap.length; i++) {
          if (!testFn(this.heap[i])) {
            this.heap[j] = this.heap[i];
            j++;
          }
        }
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1); i >= 0; i--) {
          this.percDown(i);
        }
        return this;
      }
    };
    race$1 = awaitify(race, 2);
    reject$2 = awaitify(reject$1, 3);
    rejectLimit$1 = awaitify(rejectLimit, 4);
    rejectSeries$1 = awaitify(rejectSeries, 3);
    DEFAULT_TIMES = 5;
    DEFAULT_INTERVAL = 0;
    some$1 = awaitify(some, 3);
    someLimit$1 = awaitify(someLimit, 4);
    someSeries$1 = awaitify(someSeries, 3);
    sortBy$1 = awaitify(sortBy, 3);
    tryEach$1 = awaitify(tryEach);
    whilst$1 = awaitify(whilst, 3);
    waterfall$1 = awaitify(waterfall);
    index = {
      apply,
      applyEach: applyEach$1,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo,
      cargoQueue: cargo$1,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$2,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$2,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel: parallel$1,
      parallelLimit,
      priorityQueue,
      queue: queue$1,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$2,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      // aliases
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$2,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$2,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    async_default = index;
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports, module) {
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (obj, name, value) => Object.defineProperty(obj, name, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis = exports;
    var defaultMergeOpts = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys.push(symbol);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array) {
      const result = array.slice(0, 0);
      getEnumerableOwnPropertyKeys(array).forEach((key) => {
        defineProperty(result, key, clone(array[key]));
      });
      return result;
    }
    function cloneOptionObject(obj) {
      const result = Object.getPrototypeOf(obj) === null ? /* @__PURE__ */ Object.create(null) : {};
      getEnumerableOwnPropertyKeys(obj).forEach((key) => {
        defineProperty(result, key, clone(obj[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array) => {
        const indices = [];
        for (let k = 0; k < array.length; k++) {
          if (!hasOwnProperty.call(array, k)) {
            continue;
          }
          indices.push(String(k));
          if (array === merged) {
            defineProperty(result, resultIndex++, array[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array[k]));
          }
        }
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
      });
      return result;
    };
    function merge(merged, source, config) {
      if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
    }
    module.exports = function(...options) {
      const config = merge(clone(defaultMergeOpts), this !== globalThis && this || {}, defaultMergeOpts);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge(merged, { _: option }, config);
      }
      return merged._;
    };
  }
});

// node_modules/activedirectory2/lib/models/group.js
var require_group = __commonJS({
  "node_modules/activedirectory2/lib/models/group.js"(exports, module) {
    "use strict";
    function Group(properties) {
      if (!properties) {
        return this;
      }
      for (const prop of Object.getOwnPropertyNames(properties)) {
        Object.defineProperty(this, prop, {
          value: properties[prop],
          enumerable: true,
          writable: true
        });
      }
    }
    module.exports = Group;
  }
});

// node_modules/activedirectory2/lib/components/utilities.js
var require_utilities = __commonJS({
  "node_modules/activedirectory2/lib/components/utilities.js"(exports, module) {
    "use strict";
    var ldap = require_lib3();
    function createClient(url, opts, ad) {
      const _url = url || ad.url || ad.opts.url;
      if (!_url) {
        throw new Error("No url specified for ActiveDirectory client.");
      }
      const ldapOpts = getLdapClientOpts(Object.assign({ url: _url }, ad && ad.opts ? ad.opts : {}, opts || {}));
      return ldap.createClient(ldapOpts);
    }
    function getCompoundFilter(filter2) {
      if (!filter2) {
        return false;
      }
      if (filter2.charAt(0) === "(" && filter2.charAt(filter2.length - 1) === ")") {
        return filter2;
      }
      return `(${filter2})`;
    }
    function getGroupQueryFilter(groupName) {
      if (!groupName) {
        return "(objectCategory=Group)";
      }
      if (isDistinguishedName(groupName)) {
        return "(&(objectCategory=Group)(distinguishedName=" + parseDistinguishedName(groupName) + "))";
      }
      return `(&(objectCategory=Group)(cn=${groupName}))`;
    }
    function getLdapClientOpts(opts) {
      const clientOpts = [
        "url",
        "host",
        "port",
        "secure",
        "tlsOptions",
        "socketPath",
        "log",
        "timeout",
        "idleTimeout",
        "reconnect",
        "queue",
        "queueSize",
        "queueTimeout",
        "queueDisable",
        "bindDN",
        "bindCredentials",
        "maxConnections",
        "connectTimeout",
        "tlsOptions",
        "strictDN",
        "paged"
      ];
      const options = {};
      clientOpts.forEach((opt) => {
        if (Object.prototype.hasOwnProperty.call(opts, opt)) {
          options[opt] = opts[opt];
        }
      });
      return options;
    }
    function getRequiredLdapAttributesForGroup(opts) {
      const _opts = opts || {};
      if (shouldIncludeAllAttributes(_opts.attributes)) {
        return [];
      }
      return [].concat(
        ["dn", "objectCategory", "groupType", "cn"],
        includeGroupMembershipFor(_opts, "group") ? ["member"] : []
      );
    }
    function getRequiredLdapAttributesForUser(opts) {
      const _opts = opts || {};
      if (shouldIncludeAllAttributes(_opts.attributes)) {
        return [];
      }
      return [].concat(
        ["dn", "cn"],
        includeGroupMembershipFor(_opts, "user") ? ["member"] : []
      );
    }
    function getUserQueryFilter(username) {
      if (!username) {
        return "(objectCategory=User)";
      }
      if (isDistinguishedName(username)) {
        return "(&(objectCategory=User)(distinguishedName=" + parseDistinguishedName(username) + "))";
      }
      return "(&(objectCategory=User)(|(sAMAccountName=" + username + ")(userPrincipalName=" + username + ")))";
    }
    function includeGroupMembershipFor(opts, name) {
      const lowerCaseName = name.toLowerCase();
      return (opts.includeMembership || []).some((i) => {
        const j = i.toLowerCase();
        return j === "all" || j === lowerCaseName;
      });
    }
    function isDistinguishedName(value) {
      if (!value || value.length === 0) {
        return false;
      }
      const regex = /(([^=]+=.+),?)+/gi;
      return regex.test(value);
    }
    function isGroupResult(item) {
      const regex = /CN=Group,CN=Schema,CN=Configuration,.*/i;
      if (!item) {
        return false;
      }
      if (item.groupType) {
        return true;
      }
      if (item.objectCategory) {
        return regex.test(item.objectCategory);
      }
      if (item.objectClass && item.objectClass.length > 0) {
        return item.objectClass.some((c) => c.toLowerCase() === "group");
      }
      return false;
    }
    function isUserResult(item) {
      const regex = /CN=Person,CN=Schema,CN=Configuration,.*/i;
      if (!item) {
        return false;
      }
      if (item.userPrincipalName) {
        return true;
      }
      if (item.objectCategory) {
        return regex.test(item.objectCategory);
      }
      if (item.objectClass && item.objectClass.length > 0) {
        return item.objectClass.some((c) => c.toLowerCase() === "user");
      }
      return false;
    }
    function joinAttributes() {
      for (const arg of Array.from(arguments)) {
        if (shouldIncludeAllAttributes(arg)) {
          return [];
        }
      }
      const attrs = [];
      Array.from(arguments).forEach((arr) => {
        arr.forEach((i) => attrs.push(i));
      });
      return attrs.filter((ele, i, arr) => arr.indexOf(ele) === i);
    }
    function parseDistinguishedName(dn) {
      if (!dn || Array.isArray(dn)) {
        return dn;
      }
      const tmp = dn.split(",");
      const component = [];
      for (let i = 0; i < tmp.length; i++) {
        if (i && !tmp[i].match(/^(CN|OU|DC)=/i)) {
          component.push(component.pop() + "\\," + tmp[i]);
        } else {
          component.push(tmp[i]);
        }
      }
      for (let i = 0; i < component.length; i++) {
        const compvalue = component[i].substr(3);
        let newvalue = "";
        for (let j = 0; j < compvalue.length; j++) {
          let char = compvalue.substr(j, 1);
          switch (char) {
            case "*":
              char = "\\\\2A";
              break;
            case "(":
              char = "\\\\28";
              break;
            case ")":
              char = "\\\\29";
              break;
            case "+":
              char = "\\+";
              break;
            case "<":
              char = "\\<";
              break;
            case ">":
              char = "\\>";
              break;
            case ";":
              char = "\\;";
              break;
            case '"':
              char = '\\"';
              break;
            case "=":
              char = "\\=";
              break;
            case " ":
              if (j === 0 || j === compvalue.length - 1) {
                char = "\\ ";
              }
              break;
          }
          newvalue = newvalue + char;
        }
        component[i] = component[i].substr(0, 3) + newvalue;
      }
      return component.join(",");
    }
    function pickAttributes(result, attributes) {
      let _attributes = attributes;
      if (shouldIncludeAllAttributes(attributes)) {
        _attributes = Object.getOwnPropertyNames(result);
      }
      const obj = {};
      _attributes.forEach((attr) => {
        if (Object.prototype.hasOwnProperty.call(result, attr)) {
          obj[attr] = result[attr];
        }
      });
      return obj;
    }
    function shouldIncludeAllAttributes(attributes) {
      if (!Array.isArray(attributes)) {
        return false;
      }
      return attributes.length === 0 ? true : attributes.filter((a) => a === "*").length > 0;
    }
    var maxOutputLength = 256;
    function truncateLogOutput(output, maxLength) {
      const _maxLength = maxLength || maxOutputLength;
      if (!output) {
        return output;
      }
      let _output = output;
      if (typeof output !== "string") {
        _output = output.toString();
      }
      const length = _output.length;
      if (length < _maxLength + 3) {
        return _output;
      }
      const prefix = Math.ceil((_maxLength - 3) / 2);
      const suffix = Math.floor((_maxLength - 3) / 2);
      return _output.slice(0, prefix) + "..." + _output.slice(length - suffix);
    }
    function binarySidToStringSid(sid) {
      const _32bit = 4294967296;
      const revision = sid.readUInt8(0);
      const authority = _32bit * sid.readUInt16BE(2) + sid.readUInt32BE(4);
      const parts = ["S", revision, authority];
      for (let i = 8; i < sid.length; i += 4) {
        parts.push(sid.readUInt32LE(i));
      }
      return parts.join("-");
    }
    module.exports = {
      binarySidToStringSid,
      createClient,
      getCompoundFilter,
      getGroupQueryFilter,
      getLdapClientOpts,
      getRequiredLdapAttributesForGroup,
      getRequiredLdapAttributesForUser,
      getUserQueryFilter,
      includeGroupMembershipFor,
      isDistinguishedName,
      isGroupResult,
      isUserResult,
      joinAttributes,
      parseDistinguishedName,
      pickAttributes,
      shouldIncludeAllAttributes,
      truncateLogOutput
    };
  }
});

// node_modules/activedirectory2/lib/client/RangeAttribute.js
var require_RangeAttribute = __commonJS({
  "node_modules/activedirectory2/lib/client/RangeAttribute.js"(exports, module) {
    "use strict";
    var rangeRegex = /^([^;]+);range=(\d+)-([\d*]+)$/i;
    function RangeAttribute(attribute) {
      if (attribute && typeof attribute === "string") {
        return RangeAttribute.fromString(attribute);
      }
      this.attributeName = null;
      this.low = null;
      this.high = null;
    }
    RangeAttribute.prototype.next = function next() {
      if (this.high !== null && this.high !== this.low) {
        const low = this.low;
        const high = this.high;
        this.low = high + 1;
        this.high = high + (high - low) + 1;
        if (low === 0) {
          this.high += 1;
        }
        return this;
      }
      return null;
    };
    RangeAttribute.prototype.isComplete = function isComplete() {
      return this.high == null || typeof this.high === "undefined";
    };
    RangeAttribute.prototype.toString = function toString() {
      return this.attributeName + ";range=" + this.low + "-" + (this.high ? this.high : "*");
    };
    RangeAttribute.fromString = function fromString(str) {
      const match = rangeRegex.exec(str);
      const rrsa = new RangeAttribute();
      rrsa.attributeName = match[1];
      rrsa.low = parseInt(match[2], 10);
      rrsa.high = parseInt(match[3], 10) || null;
      return rrsa;
    };
    RangeAttribute.getRangeAttributes = function getRangeAttributes(entry) {
      const attributes = [];
      for (const attribute of Object.keys(entry)) {
        if (RangeAttribute.isRangeAttribute(attribute)) {
          const range2 = new RangeAttribute(attribute);
          attributes.push(range2);
        }
      }
      return attributes;
    };
    RangeAttribute.isRangeAttribute = function isRangeAttribute(attribute) {
      return rangeRegex.test(attribute);
    };
    RangeAttribute.hasRangeAttributes = function hasRangeAttributes(entry) {
      return Object.keys(entry).filter((entry2) => {
        return RangeAttribute.isRangeAttribute(entry2);
      }).length > 0;
    };
    module.exports = RangeAttribute;
  }
});

// node_modules/activedirectory2/lib/components/parseRangeAttributes.js
var require_parseRangeAttributes = __commonJS({
  "node_modules/activedirectory2/lib/components/parseRangeAttributes.js"(exports, module) {
    "use strict";
    var util = require_util();
    var events = require_events();
    var RangeAttribute = require_RangeAttribute();
    var log2;
    module.exports = function init($ad, $log) {
      log2 = $log;
      return RangeAttributeParser;
    };
    function parseDistinguishedName(dn) {
      log2.trace("parseDistinguishedName(%s)", dn);
      if (!dn) {
        return dn;
      }
      dn = dn.replace(/"/g, '\\"');
      return dn.replace("\\,", "\\\\,");
    }
    function Result(result) {
      this.originalResult = result;
      this.rangeAttributes = /* @__PURE__ */ new Map();
      this.rangeAttributeResults = /* @__PURE__ */ new Map();
    }
    Result.prototype.name = function name() {
      return this.originalResult.dn;
    };
    Result.prototype.value = function value() {
      const result = {};
      Object.getOwnPropertyNames(this.originalResult).forEach(
        (k) => {
          result[k] = this.originalResult[k];
        }
      );
      Array.from(this.rangeAttributes.keys()).forEach((k) => {
        result[k] = this.rangeAttributeResults.get(k);
      });
      return result;
    };
    function RangeAttributeParser(searcher) {
      this.searcher = searcher;
      this.results = /* @__PURE__ */ new Map();
      events.EventEmitter.call(this);
    }
    util.inherits(RangeAttributeParser, events.EventEmitter);
    RangeAttributeParser.prototype.getResults = function getResults() {
      const results = [];
      Array.from(this.results.values()).forEach((v) => results.push(v.value()));
      return results;
    };
    RangeAttributeParser.prototype.parseResult = function parseResult(result) {
      log2.trace("parsing result for range attributes: %j", result);
      const _result = this.results.has(result.dn) ? this.results.get(result.dn) : new Result(result);
      this.results.set(result.dn, _result);
      if (!RangeAttribute.hasRangeAttributes(result)) {
        this.emit("done", this.getResults());
        return;
      }
      const rangeAttributes = RangeAttribute.getRangeAttributes(result);
      if (rangeAttributes.length === 0) {
        this.emit("done", this.getResults());
        return;
      }
      let queryAttributes = [];
      rangeAttributes.forEach((attr) => {
        const attrName = attr.attributeName;
        if (!_result.rangeAttributes.has(attrName)) {
          _result.rangeAttributes.set(attrName, attr);
        }
        if (!_result.rangeAttributeResults.has(attrName)) {
          _result.rangeAttributeResults.set(attrName, []);
        }
        const currRangeName = attr.toString();
        const attrResults = _result.rangeAttributeResults.get(attrName);
        const newResults = [].concat(attrResults, result[currRangeName]);
        _result.rangeAttributeResults.set(attrName, newResults);
        const nextAttr = attr.next();
        _result.rangeAttributes.set(attrName, nextAttr);
        delete _result.originalResult[currRangeName];
        if (nextAttr) {
          const nextRangeName = _result.rangeAttributes.get(attrName).toString();
          if (nextRangeName !== currRangeName) {
            queryAttributes.push(nextRangeName);
          }
        }
      });
      if (queryAttributes.length === 0) {
        this.emit("done", this.getResults());
        return;
      }
      const rangeKeys = Array.from(_result.rangeAttributes.keys());
      queryAttributes = queryAttributes.concat(
        this.searcher.query.attributes.filter((a) => rangeKeys.indexOf(a) === -1)
      );
      const filter2 = `(distinguishedName=${parseDistinguishedName(result.dn)})`;
      const query = {
        filter: filter2,
        attributes: queryAttributes,
        scope: this.searcher.query.scope
      };
      this.searcher.rangeSearch(query, (err, result2) => {
        if (err) {
          this.emit("error", err);
          return;
        }
        this.parseResult(result2);
      });
    };
  }
});

// node_modules/activedirectory2/lib/components/search.js
var require_search = __commonJS({
  "node_modules/activedirectory2/lib/components/search.js"(exports, module) {
    "use strict";
    var url = require_url();
    var ldap = require_lib3();
    var utils = require_utilities();
    var async = (init_async(), __toCommonJS(async_exports));
    var ad;
    var log2;
    var RangeAttributeParser;
    function isReferralAllowed(referralUri) {
      if (ad.defaultReferrals.enabled === false || !referralUri) {
        return false;
      }
      let result = true;
      for (const excludePattern of ad.defaultReferrals.exclude) {
        const regex = new RegExp(excludePattern, "i");
        if (regex.test(referralUri)) {
          result = false;
          break;
        }
      }
      return result;
    }
    function Searcher(opts) {
      this.baseDN = opts.baseDN;
      this.callback = opts.callback;
      this.opts = opts;
      this.ldapOpts = utils.getLdapClientOpts(this.opts);
      this.query = this.opts.opts;
      this.results = /* @__PURE__ */ new Map();
      this.pendingReferrals = /* @__PURE__ */ new Set();
      this.searchComplete = false;
      this.rangeProcessing = false;
      this.client = utils.createClient(ad.url || ad.opts.url, this.ldapOpts, ad);
      this.client.on("connectTimeout", (err) => {
        this.callback(err);
      });
      this.client.on("error", (err) => {
        this.callback(err);
      });
      this.controls = this.opts.controls || [];
      const pagedControls = this.controls.filter(
        (control) => control instanceof ldap.PagedResultsControl
      );
      if (!this.opts.opts.paged && pagedControls.length === 0) {
        log2.trace(
          'Adding PagedResultControl to search (%s) with filter "%s" for %j',
          this.baseDN,
          this.query.filter,
          this.query.attributes ? this.opts.attributes : "[*]"
        );
        this.controls.push(new ldap.PagedResultsControl({
          value: { size: ad.pageSize }
        }));
      }
      if (this.opts.includeDeleted) {
        const deletedControls = this.controls.filter(
          (control) => control.type === "1.2.840.113556.1.4.417"
        );
        if (deletedControls.length === 0) {
          log2.trace(
            'Adding ShowDeletedOidControl(1.2.840.113556.1.4.417) to search (%s) with filter "%s" for %j',
            this.baseDN,
            this.query.filter,
            this.query.attributes ? this.query.attributes : "[*]"
          );
          this.controls.push(new ldap.Control({
            type: "1.2.840.113556.1.4.417",
            criticality: true
          }));
        }
      }
    }
    Searcher.prototype.search = function search2() {
      log2.trace(
        'Querying active directory (%s) with filter "%s" for %j',
        this.baseDN,
        this.query.filter,
        this.query.attributes ? this.query.attributes : "[*]"
      );
      this.client.search(this.baseDN, this.query, this.controls, (err, res) => {
        if (err) {
          if (this.callback) {
            this.callback(err);
          }
          return;
        }
        const errCallback = (err2) => {
          if (err2.name === "SizeLimitExceededError") {
            this.onSearchEnd(res);
            return;
          }
          this.client.unbind();
          log2.trace(
            err2,
            "[%s] An error occurred performing the requested LDAP search on %s (%j)",
            err2.errno || "UNKNOWN",
            this.baseDN,
            this.opts
          );
          if (this.callback) {
            this.callback(err2);
          }
        };
        res.on("searchEntry", this.onSearchEntry.bind(this));
        res.on("searchReference", this.onReferralChase.bind(this));
        res.on("error", errCallback);
        res.on("end", (err2) => {
          this.searchComplete = true;
          this.onSearchEnd(err2);
        });
      });
    };
    Searcher.prototype.rangeSearch = function rangeSearch(query, rangeCB) {
      log2.trace(
        'Quering (%s) for range search with filter "%s" for: %j',
        this.baseDN,
        query.filter,
        query.attributes
      );
      this.client.search(this.baseDN, query, this.controls, (err, res) => {
        if (err) {
          return rangeCB(err);
        }
        res.on("searchEntry", (entry) => {
          const obj = entry.object;
          rangeCB(null, obj);
        });
        res.on("searchReference", this.onReferralChase.bind(this));
        res.on("end", () => {
          this.rangeProcessing = false;
        });
        res.on("error", rangeCB);
      });
    };
    Searcher.prototype.entryParser = function entryParser(entry, raw, callback) {
      if (this.opts.opts.entryParser) {
        return this.opts.opts.entryParser(entry, raw, callback);
      } else if (this.opts.entryParser) {
        return this.opts.entryParser(entry, raw, callback);
      } else if (ad.opts.entryParser) {
        return ad.opts.entryParser(entry, raw, callback);
      }
      return callback(entry);
    };
    Searcher.prototype.onSearchEntry = function onSearchEntry(entry) {
      log2.trace("onSearchEntry(entry)");
      const result = entry.object;
      delete result.controls;
      this.rangeProcessing = true;
      const rangeProcessor = new RangeAttributeParser(this);
      rangeProcessor.on("error", this.callback);
      rangeProcessor.on("done", (results) => {
        async.each(
          results,
          (result2, acb) => {
            this.entryParser(
              result2,
              entry.raw,
              (r) => {
                this.results.set(result2.dn, r);
                this.rangeProcessing = false;
                acb();
              }
            );
          },
          () => {
            if (this.searchComplete) {
              this.onSearchEnd();
            }
          }
        );
      });
      rangeProcessor.parseResult(result);
    };
    Searcher.prototype.onReferralChase = function onReferralChase(referral) {
      referral.uris.forEach((uri) => {
        if (!isReferralAllowed(uri)) {
          return;
        }
        log2.trace("Following LDAP referral chase at %s", uri);
        const referral2 = url.parse(uri);
        const referralBaseDn = (referral2.pathname || "/").substring(1);
        const refSearcher = new Searcher({
          baseDN: referralBaseDn,
          opts: this.opts,
          callback: (err, res) => {
            if (err) {
              log2.trace(
                err,
                "[%s] An error occurred chasing the LDAP referral on %s (%j)",
                err.errno,
                referralBaseDn,
                this.opts
              );
            }
            this.removeReferral(refSearcher);
          }
        });
        this.pendingReferrals.add(refSearcher);
        refSearcher.search();
      });
    };
    Searcher.prototype.onSearchEnd = function onSearchEnd() {
      if (!this.rangeProcessing && this.pendingReferrals.size === 0) {
        this.client.unbind();
        log2.trace(
          'Active directory search (%s) for "%s" returned %d entries.',
          this.baseDN,
          this.query.filter,
          this.results.length
        );
        if (this.callback) {
          this.callback(null, Array.from(this.results.values()));
        }
      }
    };
    Searcher.prototype.removeReferral = function removeReferral(referral) {
      if (!referral) {
        return;
      }
      referral.client.unbind();
      this.pendingReferrals.delete(referral);
    };
    function search(baseDN, opts, callback) {
      const options = Object.assign({}, ad.opts);
      if (typeof baseDN === "function") {
        options.baseDN = ad.baseDN;
        options.callback = baseDN;
        options.opts = {};
      } else if (typeof baseDN === "object") {
        options.baseDN = baseDN.baseDN || ad.baseDN;
        options.callback = opts;
        options.opts = baseDN;
      } else if (typeof baseDN === "string") {
        options.baseDN = baseDN;
        if (typeof opts === "function") {
          options.callback = opts;
          options.opts = {};
        } else {
          options.callback = callback;
          options.opts = opts;
        }
      }
      const searcher = new Searcher(options);
      return searcher.search();
    }
    module.exports = function($ad, $log) {
      ad = $ad;
      log2 = $log;
      RangeAttributeParser = require_parseRangeAttributes()($ad, $log);
      return search;
    };
  }
});

// node_modules/activedirectory2/lib/components/getGroupMembershipForDN.js
var require_getGroupMembershipForDN = __commonJS({
  "node_modules/activedirectory2/lib/components/getGroupMembershipForDN.js"(exports, module) {
    "use strict";
    var async = (init_async(), __toCommonJS(async_exports));
    var Group = require_group();
    var utils = require_utilities();
    var ad;
    var log2;
    var search;
    function GroupMembersForDN(opts, dn, callback, stack) {
      this.opts = opts;
      this.dn = dn;
      this.callback = callback;
      this.stack = stack || /* @__PURE__ */ new Map();
    }
    GroupMembersForDN.prototype.asyncIterator = function asyncIterator(group, acb) {
      if (this.stack.has(group.cn || group.dn)) {
        return acb();
      }
      if (utils.isGroupResult(group)) {
        log2.trace('Adding group "%s" to %s"', group.dn, this.dn);
        const g = new Group(group);
        this.stack.set(g.cn || g.dn, g);
        const getter = new GroupMembersForDN(this.opts, g.dn, (err, nestedGroups) => {
          if (err) {
            return acb(err);
          }
          nestedGroups.forEach((ng) => {
            if (!this.stack.has(ng.cn || ng.dn)) {
              this.stack.set(ng.cn || ng.dn, ng);
            }
          });
          acb();
        }, this.stack);
        getter.getMembers();
      } else {
        acb();
      }
    };
    GroupMembersForDN.prototype.asyncCallback = function asyncCallback(err) {
      if (err) {
        return this.callback(err);
      }
      const groups = Array.from(this.stack.values());
      log2.trace(
        'Group "%s" has %d group(s). Groups: %j',
        this.dn,
        groups.length,
        groups.map((g) => g.dn)
      );
      this.callback(err, groups);
    };
    GroupMembersForDN.prototype.getMembers = function getMembers() {
      if (!this.dn) {
        const error = new Error("No distinguishedName (dn) specified for group membership retrieval.");
        log2.trace(error);
        ad.emit("error", error);
        return this.callback(error);
      }
      const localOpts = Object.assign(
        {},
        this.opts,
        {
          filter: "(member=" + utils.parseDistinguishedName(this.dn) + ")",
          scope: "sub",
          attributes: utils.joinAttributes(
            this.opts.attributes || ad.defaultAttributes.group,
            ["groupType"]
          )
        }
      );
      search(localOpts, (err, results) => {
        if (err) {
          this.callback(err);
          return;
        }
        async.forEach(
          results,
          this.asyncIterator.bind(this),
          this.asyncCallback.bind(this)
        );
      });
    };
    function getGroupMembershipForDN(opts, dn, stack, callback) {
      let _opts = opts || {};
      let _dn = dn;
      let _cb = callback;
      if (typeof stack === "function") {
        _cb = stack;
      }
      if (typeof dn === "function") {
        _cb = dn;
        _dn = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _dn = opts;
        _opts = {};
      }
      log2.trace("getGroupMembershipForDN(%j,%s)", _opts, _dn);
      const getter = new GroupMembersForDN(_opts, _dn, _cb);
      return getter.getMembers();
    }
    module.exports = function init($ad, $log) {
      ad = $ad;
      log2 = $log;
      search = require_search()(ad, log2);
      return getGroupMembershipForDN;
    };
  }
});

// node_modules/activedirectory2/lib/models/user.js
var require_user = __commonJS({
  "node_modules/activedirectory2/lib/models/user.js"(exports, module) {
    "use strict";
    function User(properties) {
      if (!properties) {
        return this;
      }
      for (const prop of Object.getOwnPropertyNames(properties)) {
        Object.defineProperty(this, prop, {
          value: properties[prop],
          enumerable: true,
          writable: true
        });
      }
    }
    User.prototype.isMemberOf = function isMemberOf(group) {
      if (!group) {
        return false;
      }
      const _group = group.toLowerCase();
      return this.groups.filter((g) => g.toLowerCase() === _group).length > 0;
    };
    module.exports = User;
  }
});

// node_modules/activedirectory2/lib/components/getUsersForGroup.js
var require_getUsersForGroup = __commonJS({
  "node_modules/activedirectory2/lib/components/getUsersForGroup.js"(exports, module) {
    "use strict";
    var async = (init_async(), __toCommonJS(async_exports));
    var User = require_user();
    var utils = require_utilities();
    var ad;
    var log2;
    var search;
    function chunk(arr, chunkSize) {
      const result = [];
      for (let i = 0, j = arr.length; i < j; i += chunkSize) {
        result.push(arr.slice(i, i + chunkSize));
      }
      return result;
    }
    function GroupUsersFinder(opts, groupName, callback) {
      this.opts = opts;
      this.groupName = groupName;
      this.callback = callback;
      this.chunks = [];
      this.chunksProcessed = 0;
      this.users = /* @__PURE__ */ new Map();
      if (Object.prototype.hasOwnProperty.call(this.opts, "recursionstack") === false) {
        this.opts.recursionstack = [];
      }
    }
    GroupUsersFinder.prototype.forEachIter = function forEachIter(member, acb) {
      if (!member.groupType) {
        const user = new User(
          utils.pickAttributes(member, this.opts.attributes || ad.defaultAttributes.user)
        );
        ad.emit("user", user);
        this.users.set(member.dn, user);
        return acb();
      }
      if (this.opts.recursionstack.indexOf(member.dn) === -1) {
        ad.getUsersForGroup(this.opts, member.dn, (err, nestedUsers) => {
          if (err)
            throw err;
          nestedUsers.forEach((u) => this.users.set(u.dn, u));
          acb();
        });
      } else {
        acb();
      }
    };
    GroupUsersFinder.prototype.eachIterator = function eachIterator(members, acb) {
      let filter2 = members.reduce((prev, curr) => {
        const res = "(distinguishedName=" + utils.parseDistinguishedName(curr) + ")";
        return prev ? prev + res : res;
      }, null);
      filter2 = `(&(|(objectCategory=User)(objectCategory=Group))(|${filter2}))`;
      const localOpts = {
        filter: filter2,
        scope: "sub",
        attributes: utils.joinAttributes(
          this.opts.attributes || ad.defaultAttributes.user || [],
          utils.getRequiredLdapAttributesForUser(this.opts),
          ["groupType"]
        )
      };
      search(localOpts, (err, members2) => {
        if (err) {
          return acb(err);
        }
        const asyncCallback = (err2) => {
          if (this.chunks.length > 1) {
            this.chunksProcessed += 1;
            log2.trace(
              "Finished processing chunk %d/%d",
              this.chunksProcessed,
              this.chunks.length
            );
          }
          acb(err2);
        };
        async.forEach(members2, this.forEachIter.bind(this), asyncCallback);
      });
    };
    GroupUsersFinder.prototype.find = function find() {
      const groupAttributes = Object.assign(
        {},
        this.opts,
        {
          attributes: utils.joinAttributes(
            this.opts.attributes || ad.defaultAttributes.group,
            ["member"]
          )
        }
      );
      ad.findGroup(groupAttributes, this.groupName, (err, group) => {
        if (err) {
          return this.callback(err);
        } else if (!group) {
          return this.callback(null, group);
        }
        this.opts.recursionstack.push(group.dn);
        if (!Array.isArray(group.member)) {
          group.member = group.member ? [group.member] : [];
        }
        this.chunks = chunk(group.member, ad.pageSize);
        if (this.chunks.length > 1) {
          log2.trace(
            'Splitting %d member(s) of "%s" into %d parallel chunks',
            group.member.length,
            this.groupName,
            this.chunks.length
          );
        }
        const eachCallback = (err2) => {
          log2.trace('%d user(s) belong in the group "%s"', this.users.size, this.groupName);
          this.callback(err2, Array.from(this.users.values()));
        };
        async.each(this.chunks, this.eachIterator.bind(this), eachCallback);
      });
    };
    function getUsersForGroup(opts, groupName, callback) {
      let _opts = opts || {};
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = opts;
        _opts = {};
      }
      const finder = new GroupUsersFinder(_opts, _groupName, _cb);
      return finder.find();
    }
    module.exports = function init($ad, $log) {
      ad = $ad;
      log2 = $log;
      search = require_search()(ad, log2);
      return getUsersForGroup;
    };
  }
});

// node_modules/activedirectory2/lib/components/find.js
var require_find = __commonJS({
  "node_modules/activedirectory2/lib/components/find.js"(exports, module) {
    "use strict";
    var async = (init_async(), __toCommonJS(async_exports));
    var User = require_user();
    var Group = require_group();
    var utils = require_utilities();
    var ad;
    var log2;
    var search;
    function Finder(opts, callback) {
      this.opts = opts;
      this.callback = callback;
      this.result = {
        groups: [],
        users: [],
        other: []
      };
    }
    Finder.prototype.asyncCallback = function asyncCallback(err) {
      if (err) {
        if (this.callback) {
          this.callback(err);
        }
        return;
      }
      log2.trace(
        '%d group(s), %d user(s), %d other found for query "%s". Results: %j',
        this.result.groups.length,
        this.result.users.length,
        this.result.other.length,
        this.opts.filter,
        this.result
      );
      ad.emit("groups", this.result.groups);
      ad.emit("users", this.result.users);
      if (this.callback) {
        this.callback(null, this.result);
      }
    };
    Finder.prototype.asyncIterator = function asyncIterator(item, cb) {
      if (utils.isGroupResult(item)) {
        this.parseGroupResult(item, cb);
      } else if (utils.isUserResult(item)) {
        this.parseUserResult(item, cb);
      } else {
        this.parseOtherResult(item, cb);
      }
    };
    Finder.prototype.find = function find2() {
      const localOpts = Object.assign({ scope: "sub" }, this.opts, {
        attributes: utils.joinAttributes(
          this.opts.attributes || [],
          ad.defaultAttributes.group,
          ad.defaultAttributes.user,
          utils.getRequiredLdapAttributesForGroup(this.opts),
          utils.getRequiredLdapAttributesForUser(this.opts),
          ["objectCategory"]
        )
      });
      search(localOpts, (err, results) => {
        if (err) {
          if (this.callback) {
            this.callback(err);
          }
          return;
        }
        if (results.length === 0) {
          log2.trace(
            'No results found for query "%s"',
            utils.truncateLogOutput(localOpts.filter)
          );
          if (this.callback) {
            this.callback();
          }
          ad.emit("done");
          return;
        }
        async.forEach(
          results,
          this.asyncIterator.bind(this),
          this.asyncCallback.bind(this)
        );
      });
    };
    Finder.prototype.parseGroupResult = function parseGroupResult(item, cb) {
      const groupAttributes = this.opts.attributes || ad.defaultAttributes.group;
      const group = new Group(utils.pickAttributes(item, groupAttributes));
      this.result.groups.push(group);
      if (utils.includeGroupMembershipFor(this.opts, "group")) {
        ad.getGroupMembershipForDN(this.opts, group.dn, (err, groups) => {
          if (err) {
            return cb(err);
          }
          group.groups = groups;
          ad.emit("group", group);
          cb();
        });
      } else {
        ad.emit("group", group);
        cb();
      }
    };
    Finder.prototype.parseOtherResult = function parseOtherResult(item, cb) {
      const groupAttributes = this.opts.attributes || ad.defaultAttributes.group;
      const userAttributes = this.opts.attributes || ad.defaultAttributes.user;
      const other = utils.pickAttributes(
        item,
        this.opts.attributes || [].concat(userAttributes, groupAttributes).filter((ele, i, arr) => {
          return i === arr.indexOf(ele);
        })
      );
      this.result.other.push(other);
      ad.emit("other", other);
      cb();
    };
    Finder.prototype.parseUserResult = function parseUserResult(item, cb) {
      const userAttributes = this.opts.attributes || ad.defaultAttributes.user;
      const user = new User(utils.pickAttributes(item, userAttributes));
      this.result.users.push(user);
      if (utils.includeGroupMembershipFor(this.opts, "user")) {
        ad.getGroupMembershipForDN(this.opts, user.dn, (err, groups) => {
          if (err) {
            return cb(err);
          }
          user.groups = groups;
          ad.emit("user", user);
          cb();
        });
      } else {
        ad.emit("user", user);
        cb();
      }
    };
    function find(opts, callback) {
      let _opts = opts;
      let _cb = callback;
      if (typeof opts === "function") {
        _cb = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _opts = { filter: opts };
      }
      log2.trace("find(%j)", _opts);
      const finder = new Finder(_opts, _cb);
      return finder.find();
    }
    module.exports = function init($ad, $log) {
      ad = $ad;
      log2 = $log;
      search = require_search()(ad, log2);
      return find;
    };
  }
});

// node_modules/activedirectory2/lib/components/findGroups.js
var require_findGroups = __commonJS({
  "node_modules/activedirectory2/lib/components/findGroups.js"(exports, module) {
    "use strict";
    var async = (init_async(), __toCommonJS(async_exports));
    var Group = require_group();
    var utils = require_utilities();
    var defaultGroupFilter = "(objectClass=group)(!(objectClass=computer))(!(objectClass=user))(!(objectClass=person))";
    var ad;
    var log2;
    var search;
    function GroupsFinder(opts, callback) {
      this.opts = opts;
      this.callback = callback;
      this.filter = defaultGroupFilter;
      if (this.opts && this.opts.filter && /^\(&/.test(this.opts.filter)) {
        this.filter = this.opts.filter;
      } else if (this.opts && this.opts.filter) {
        this.filter = "(&" + defaultGroupFilter + utils.getCompoundFilter(this.opts.filter) + ")";
      } else {
        this.filter = `(&${this.filter})`;
      }
      this.groups = [];
      this.localOpts = {};
    }
    GroupsFinder.prototype.asyncIterator = function asyncIterator(result, acb) {
      if (!utils.isGroupResult(result)) {
        return acb();
      }
      const group = new Group(
        // not localOpts because it includes extra attributes just for the query
        utils.pickAttributes(result, this.opts.attributes || ad.defaultAttributes.group)
      );
      log2.trace(
        'found group for query "%s". group: %j',
        utils.truncateLogOutput(this.filter),
        group
      );
      this.groups.push(group);
      if (utils.includeGroupMembershipFor(this.localOpts, "group")) {
        const getUsersCallback = (err, groups) => {
          if (err) {
            return acb(err);
          }
          group.groups = groups;
          ad.emit("group", group);
          acb();
        };
        ad.getGroupMembershipForDN(this.localOpts, group.dn, getUsersCallback);
      } else {
        ad.emit("group", group);
        acb();
      }
    };
    GroupsFinder.prototype.asyncCallback = function asyncCallback(err) {
      if (err) {
        return this.callback(err);
      }
      log2.trace(
        '%d group(s) found for query "%s". Groups: %j',
        this.groups.length,
        utils.truncateLogOutput(this.localOpts.filter),
        this.groups
      );
      ad.emit("groups", this.groups);
      this.callback(null, this.groups);
    };
    GroupsFinder.prototype.find = function find() {
      this.localOpts = Object.assign(
        {},
        this.opts,
        {
          filter: this.filter,
          scope: "sub",
          attributes: utils.joinAttributes(
            this.opts.attributes || ad.defaultAttributes.group,
            utils.getRequiredLdapAttributesForGroup(this.opts)
          )
        }
      );
      search(this.localOpts, this.onComplete.bind(this));
    };
    GroupsFinder.prototype.onComplete = function onComplete(err, results) {
      if (err) {
        if (this.callback) {
          this.callback(err);
        }
        return;
      }
      if (results.length === 0) {
        log2.trace('Group not found for query "%s"', utils.truncateLogOutput(this.filter));
        if (this.callback) {
          this.callback(err, []);
        }
        return;
      }
      async.forEach(
        results,
        this.asyncIterator.bind(this),
        this.asyncCallback.bind(this)
      );
    };
    function findGroups(opts, callback) {
      let _opts = opts || {};
      let _cb = callback;
      if (typeof opts === "function") {
        _cb = opts;
        _opts = "";
      }
      if (typeof opts === "string" && opts.length > 0) {
        _opts = {
          filter: "(&" + defaultGroupFilter + utils.getCompoundFilter(opts) + ")"
        };
      }
      log2.trace("findGroups(%j)", _opts);
      const groupsFinder = new GroupsFinder(_opts, _cb);
      return groupsFinder.find();
    }
    module.exports = function init($ad, $log) {
      ad = $ad;
      log2 = $log;
      search = require_search()(ad, log2);
      return findGroups;
    };
  }
});

// node_modules/activedirectory2/lib/components/findUsers.js
var require_findUsers = __commonJS({
  "node_modules/activedirectory2/lib/components/findUsers.js"(exports, module) {
    "use strict";
    var async = (init_async(), __toCommonJS(async_exports));
    var utils = require_utilities();
    var User = require_user();
    var ad;
    var log2;
    var search;
    var defaultUserFilter = "(|(objectClass=user)(objectClass=person))(!(objectClass=computer))(!(objectClass=group))";
    function UsersFinder(opts, includeMembership, callback) {
      this.opts = opts;
      this.includeMembership = includeMembership;
      this.callback = callback;
      this.users = [];
    }
    UsersFinder.prototype.asyncIterator = function asyncIterator(result, acb) {
      if (!utils.isUserResult(result)) {
        return acb();
      }
      const user = new User(
        utils.pickAttributes(result, this.opts.attributes || ad.defaultAttributes.user)
      );
      this.users.push(user);
      if (utils.includeGroupMembershipFor(this.opts, "user") || this.includeMembership) {
        ad.getGroupMembershipForDN(this.opts, user.dn, (err, groups) => {
          if (err) {
            return acb(err);
          }
          user.groups = groups;
          ad.emit("user", user);
          acb();
        });
      } else {
        ad.emit("user", user);
        acb();
      }
    };
    UsersFinder.prototype.asyncCallback = function asyncCallback(err) {
      if (err) {
        this.callback(err);
      }
      log2.trace(
        '%d user(s) found for query "%s". Users: %j',
        this.users.length,
        utils.truncateLogOutput(this.opts.filter),
        this.users
      );
      ad.emit("users", this.users);
      this.callback(null, this.users);
    };
    UsersFinder.prototype.find = function find() {
      const localOpts = Object.assign(
        {},
        this.opts,
        {
          filter: this.opts.filter || `(&${defaultUserFilter})`,
          scope: "sub",
          attributes: utils.joinAttributes(
            this.opts.attributes || ad.defaultAttributes.user,
            utils.getRequiredLdapAttributesForUser(this.opts),
            ["objectCategory"]
          )
        }
      );
      search(localOpts, (err, results) => {
        if (err) {
          return this.callback(err);
        }
        if (results.length === 0) {
          log2.trace(
            'No users found matching query "%s"',
            utils.truncateLogOutput(localOpts.filter)
          );
          return this.callback(null, this.users);
        }
        async.forEach(
          results,
          this.asyncIterator.bind(this),
          this.asyncCallback.bind(this)
        );
      });
    };
    function findUsers(opts, includeMembership, callback) {
      let _opts = opts;
      let _inclMembership = includeMembership;
      let _cb = callback;
      if (typeof includeMembership === "function") {
        _cb = includeMembership;
        _inclMembership = false;
      }
      if (typeof opts === "function") {
        _cb = opts;
        _opts = "";
      }
      if (typeof opts === "string" && opts.length > 0) {
        _opts = {
          filter: "(&" + defaultUserFilter + utils.getCompoundFilter(opts) + ")"
        };
      }
      log2.trace("findUsers(%j,%s)", _opts, _inclMembership);
      const finder = new UsersFinder(_opts, _inclMembership, _cb);
      return finder.find();
    }
    module.exports = function init($ad, $log) {
      ad = $ad;
      log2 = $log;
      search = require_search()(ad, log2);
      return findUsers;
    };
  }
});

// node_modules/activedirectory2/lib/activedirectory.js
var require_activedirectory = __commonJS({
  "node_modules/activedirectory2/lib/activedirectory.js"(exports, module) {
    "use strict";
    var events = require_events();
    var util = require_util();
    var ldap = require_lib3();
    var async = (init_async(), __toCommonJS(async_exports));
    var merge = require_merge_options();
    var Group = require_group();
    var utils = require_utilities();
    var searcher = require_search();
    var search = null;
    var isPasswordLoggingEnabled = false;
    var log2 = require_abstract_logging();
    var defaultPageSize = 1e3;
    var defaultAttributes;
    var originalDefaultAttributes;
    defaultAttributes = originalDefaultAttributes = {
      user: [
        "dn",
        "distinguishedName",
        "userPrincipalName",
        "sAMAccountName",
        /* 'objectSID', */
        "mail",
        "lockoutTime",
        "whenCreated",
        "pwdLastSet",
        "userAccountControl",
        "employeeID",
        "sn",
        "givenName",
        "initials",
        "cn",
        "displayName",
        "comment",
        "description"
      ],
      group: [
        "dn",
        "cn",
        "description",
        "distinguishedName",
        "objectCategory"
      ]
    };
    var defaultReferrals;
    var originalDefaultReferrals;
    defaultReferrals = originalDefaultReferrals = {
      enabled: false,
      // Active directory returns the following partitions as default referrals which we don't want to follow
      exclude: [
        "ldaps?://ForestDnsZones\\..*/.*",
        "ldaps?://DomainDnsZones\\..*/.*",
        "ldaps?://.*/CN=Configuration,.*"
      ]
    };
    var defaultEntryParser = function(entry, raw, callback) {
      if (Object.prototype.hasOwnProperty.call(raw, "objectSid")) {
        entry.objectSid = utils.binarySidToStringSid(raw.objectSid);
      }
      if (Object.prototype.hasOwnProperty.call(raw, "objectGUID")) {
        entry.objectGUID = utils.binarySidToStringSid(raw.objectGUID);
      }
      callback(entry);
    };
    function ActiveDirectory(options) {
      if (!(this instanceof ActiveDirectory)) {
        const inst = Object.create(ActiveDirectory.prototype);
        ActiveDirectory.apply(inst, arguments);
        return inst;
      }
      if (arguments.length === 0) {
        return this;
      }
      if (typeof options === "string") {
        const _opts = {
          url: options,
          baseDN: arguments[1],
          username: arguments[2],
          password: arguments[3],
          defaults: arguments[4] || null
        };
        return new ActiveDirectory(_opts);
      }
      const defaultOptions = {
        url: "",
        baseDN: "",
        bindDN: options.username || "",
        bindCredentials: options.password || "",
        referrals: defaultReferrals,
        attributes: defaultAttributes,
        pageSize: options.pageSize || defaultPageSize,
        defaults: {},
        opts: {
          url: "",
          bindDN: "",
          bindCredentials: "",
          entryParser: defaultEntryParser
        }
      };
      const ldapOptions = utils.getLdapClientOpts(options);
      const customEntryParser = options.entryParser ? { entryParser: options.entryParser } : {};
      ldapOptions.bindDN = ldapOptions.bindDN || options.username;
      ldapOptions.bindCredentials = ldapOptions.bindCredentials || options.password;
      const _options = merge({}, defaultOptions, options);
      Object.defineProperties(this, {
        opts: {
          value: merge({}, defaultOptions.opts, ldapOptions, customEntryParser)
        },
        baseDN: { value: _options.baseDN },
        pageSize: { value: _options.pageSize },
        defaultAttributes: {
          value: merge(
            {},
            originalDefaultAttributes,
            options.attributes,
            _options.defaults ? _options.defaults.attributes : {}
          )
        },
        defaultReferrals: {
          value: merge(
            {},
            originalDefaultReferrals,
            _options.referrals,
            _options.defaults ? _options.defaults.referrals : {}
          )
        }
      });
      log2 = _options.logging || log2;
      defaultAttributes = this.defaultAttributes;
      defaultReferrals = this.defaultReferrals;
      log2.trace(
        "Using username/password (%s/%s) to bind to ActiveDirectory (%s).",
        this.opts.bindDN,
        isPasswordLoggingEnabled ? this.opts.bindCredentials : "********",
        this.opts.url
      );
      log2.trace(
        "Referrals are %s",
        defaultReferrals.enabled ? "enabled. Exclusions: " + JSON.stringify(defaultReferrals.exclude) : "disabled"
      );
      log2.trace("Default user attributes: %j", defaultAttributes.user || []);
      log2.trace("Default group attributes: %j", defaultAttributes.group || []);
      events.EventEmitter.call(this);
      search = searcher(this, log2);
    }
    util.inherits(ActiveDirectory, events.EventEmitter);
    ActiveDirectory.filters = ldap.filters;
    ActiveDirectory.prototype.emit = function emit(event, data) {
      if (this.listenerCount(event) > 0) {
        events.EventEmitter.prototype.emit.call(this, event, data);
      }
    };
    ActiveDirectory.prototype.getGroupMembershipForDN = function ggmfd(opts, dn, stack, callback) {
      const getter = require_getGroupMembershipForDN()(this, log2);
      return getter(opts, dn, stack, callback);
    };
    ActiveDirectory.prototype.getDistinguishedNames = function gdns(opts, filter2, callback) {
      let _opts = opts || {};
      let _filter2 = filter2;
      let _cb = callback;
      if (typeof filter2 === "function") {
        _cb = filter2;
        _filter2 = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _filter2 = opts;
        _opts = {};
      }
      log2.trace("getDistinguishedNames(%j,%j)", _opts, _filter2);
      _opts = merge(
        {},
        {
          filter: _filter2,
          scope: "sub",
          attributes: utils.joinAttributes(_opts.attributes || [], ["dn"])
        },
        _opts
      );
      search(_opts, (err, results) => {
        if (err) {
          return _cb(err);
        }
        const dns = results.map((result) => result.dn);
        log2.trace(
          '%d distinguishedName(s) found for LDAP query: "%s". Results: %j',
          results.length,
          utils.truncateLogOutput(_opts.filter),
          results
        );
        _cb(null, dns);
      });
    };
    ActiveDirectory.prototype.getUserDistinguishedName = function gudn(opts, username, callback) {
      let _opts = opts || {};
      let _username = username;
      let _cb = callback;
      if (typeof username === "function") {
        _cb = username;
        _username = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      log2.trace("getDistinguishedName(%j,%s)", _opts, _username);
      if (utils.isDistinguishedName(_username)) {
        log2.trace('"%s" is already a distinguishedName. NOT performing query.', _username);
        return _cb(null, _username);
      }
      this.getDistinguishedNames(_opts, utils.getUserQueryFilter(_username), (err, dns) => {
        if (err) {
          return _cb(err);
        }
        log2.trace(
          '%d distinguishedName(s) found for user: "%s". Returning first dn: "%s"',
          dns.length,
          _username,
          dns[0]
        );
        _cb(null, dns[0]);
      });
    };
    ActiveDirectory.prototype.getGroupDistinguishedName = function ggdn(opts, groupName, callback) {
      let _opts = opts || {};
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      log2.trace("getGroupDistinguishedName(%j,%s)", _opts, _groupName);
      if (utils.isDistinguishedName(_groupName)) {
        log2.trace('"%s" is already a distinguishedName. Skipping query.', _groupName);
        return _cb(null, _groupName);
      }
      this.getDistinguishedNames(_opts, utils.getGroupQueryFilter(_groupName), (err, dns) => {
        if (err) {
          return _cb(err);
        }
        log2.trace(
          '%d distinguishedName(s) found for group "%s". Returning first dn: "%s"',
          dns.length,
          _groupName,
          dns[0]
        );
        _cb(null, dns[0]);
      });
    };
    ActiveDirectory.prototype.getUsersForGroup = function getUsersForGroup(opts, groupName, callback) {
      const searcher2 = require_getUsersForGroup()(this, log2);
      return searcher2(opts, groupName, callback);
    };
    ActiveDirectory.prototype.getGroupMembershipForUser = function getGroupMembershipForUser(opts, username, callback) {
      const results = [];
      let _opts = opts;
      let _username = username;
      let _cb = callback;
      if (typeof username === "function") {
        _cb = username;
        _username = opts;
        _opts = {};
      }
      _opts = merge({}, _opts || {});
      log2.trace("getGroupMembershipForUser(%j,%s)", _opts, _username);
      const groupDnCallback = (err, groups) => {
        if (err) {
          return _cb(err, results);
        }
        groups.forEach((g) => {
          const result = new Group(
            utils.pickAttributes(g, _opts.attributes || this.defaultAttributes.group)
          );
          this.emit("group", result);
          results.push(result);
        });
        if (_cb) {
          _cb(err, results);
        }
      };
      this.getUserDistinguishedName(_opts, _username, (err, dn) => {
        if (err) {
          return _cb(err, results);
        }
        if (!dn) {
          log2.trace('Could not find a distinguishedName for the specified username: "%s"', _username);
          return _cb(err, results);
        }
        this.getGroupMembershipForDN(_opts, dn, groupDnCallback);
      });
    };
    ActiveDirectory.prototype.getGroupMembershipForGroup = function getGroupMembershipForGroup(opts, groupName, callback) {
      let _opts = opts || {};
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      log2.trace("getGroupMembershipForGroup(%j,%s)", _opts, _groupName);
      this.getGroupDistinguishedName(_opts, _groupName, (err, dn) => {
        if (err) {
          return _cb(err);
        }
        if (!dn) {
          log2.trace('Could not find a distinguishedName for the specified group name: "%s"', _groupName);
          return _cb();
        }
        this.getGroupMembershipForDN(_opts, dn, (err2, groups) => {
          if (err2) {
            return _cb(err2);
          }
          const results = [];
          groups.forEach((g) => {
            const group = new Group(
              utils.pickAttributes(g, _opts.attributes || this.defaultAttributes.group)
            );
            this.emit("group", group);
            results.push(group);
          });
          _cb(err2, results);
        });
      });
    };
    ActiveDirectory.prototype.userExists = function userExists(opts, username, callback) {
      let _opts = opts || {};
      let _username = username;
      let _cb = callback;
      if (typeof username === "function") {
        _cb = username;
        _username = opts;
        _opts = {};
      }
      _opts = merge({}, _opts || {});
      log2.trace("userExists(%j,%s)", _opts, _username);
      this.findUser(_opts, _username, function(err, user) {
        if (err) {
          return _cb(err);
        }
        log2.trace('"%s" %s exist.', _username, user != null ? "DOES" : "DOES NOT");
        _cb(null, user != null);
      });
    };
    ActiveDirectory.prototype.groupExists = function groupExists(opts, groupName, callback) {
      let _opts = opts || {};
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      log2.trace("groupExists(%j,%s)", _opts, _groupName);
      this.findGroup(_opts, _groupName, function(err, result) {
        if (err) {
          return _cb(err);
        }
        log2.trace('"%s" %s exist.', _groupName, result != null ? "DOES" : "DOES NOT");
        _cb(null, result != null);
      });
    };
    ActiveDirectory.prototype.isUserMemberOf = function isUserMemberOf(opts, username, groupName, callback) {
      let _opts = opts;
      let _username = username;
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = username;
        _username = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      log2.trace("isUserMemberOf(%j,%s,%s)", _opts, _username, _groupName);
      _opts.attributes = ["cn", "dn"];
      this.getGroupMembershipForUser(_opts, _username, function(err, groups) {
        if (err) {
          return _cb(err);
        }
        if (groups.length === 0) {
          log2.trace('"%s" IS NOT a member of "%s". No groups found for user.', _username, _groupName);
          return _cb(null, false);
        }
        const lowerCaseGroupName = _groupName.toLowerCase().replace(/\s/g, "");
        const result = groups.filter((g) => g.dn.toLowerCase().replace(/\s/g, "") === lowerCaseGroupName || g.cn.toLowerCase().replace(/\s/g, "").includes(lowerCaseGroupName)).length > 0;
        log2.trace('"%s" %s a member of "%s"', _username, result ? "IS" : "IS NOT", _groupName);
        _cb(null, result);
      });
    };
    ActiveDirectory.prototype.find = function find(opts, callback) {
      const finder = require_find()(this, log2);
      finder(opts, callback);
    };
    ActiveDirectory.prototype.findDeletedObjects = function find(opts, callback) {
      let _opts = opts || {};
      let _cb = callback;
      if (typeof opts === "function") {
        _cb = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _opts = { filter: opts };
      }
      _opts = merge({}, _opts);
      log2.trace("findDeletedObjects(%j)", _opts);
      const defaultDeletedAttributes = [
        "attributeID",
        "attributeSyntax",
        "dnReferenceUpdate",
        "dNSHostName",
        "flatName",
        "governsID",
        "groupType",
        "instanceType",
        "lDAPDisplayName",
        "legacyExchangeDN",
        "mS-DS-CreatorSID",
        "mSMQOwnerID",
        "nCName",
        "objectClass",
        "objectGUID",
        "objectSid",
        "oMSyntax",
        "proxiedObjectName",
        "replPropertyMetaData",
        "sAMAccountName",
        "securityIdentifier",
        "sIDHistory",
        "subClassOf",
        "systemFlags",
        "trustPartner",
        "trustDirection",
        "trustType",
        "trustAttributes",
        "userAccountControl",
        "uSNChanged",
        "uSNCreated",
        "whenCreated",
        "msDS-AdditionalSamAccountName",
        "msDS-Auxiliary-Classes",
        "msDS-Entry-Time-To-Die",
        "msDS-IntId",
        "msSFU30NisDomain",
        "nTSecurityDescriptor",
        "uid"
      ];
      const localOpts = merge(
        {},
        {
          scope: "one",
          attributes: utils.joinAttributes(_opts.attributes || [], defaultDeletedAttributes),
          controls: []
        },
        _opts
      );
      const searchDeletedObjects = (baseDN, options) => {
        const innerOpts = merge({}, options, { includeDeleted: true });
        search(baseDN, innerOpts, (err, results) => {
          if (err) {
            return _cb(err);
          }
          if (results.length === 0) {
            log2.trace('No deleted objects found for query "%s"', utils.truncateLogOutput(_opts.filter));
            this.emit("done", null);
            return _cb();
          }
          const deletedItems = [];
          async.forEach(
            results,
            (result, acb) => {
              const deletedItem = utils.pickAttributes(result, _opts.attributes || {});
              this.emit("entry:deleted", deletedItem);
              deletedItems.push(deletedItem);
            },
            (err2) => {
              log2.trace(
                '%d deleted objects found for query "%s". Results: %j',
                deletedItems.length,
                utils.truncateLogOutput(localOpts.filter),
                deletedItems
              );
              this.emit("deleted", deletedItems);
              _cb(err2, deletedItems);
            }
          );
        });
      };
      if (!localOpts.baseDN) {
        log2.trace("No baseDN specified for Deleted Object. Querying RootDSE at %s.", this.opts.url);
        this.getRootDSE(this.opts.url, ["defaultNamingContext"], (err, result) => {
          if (err) {
            return _cb(err);
          }
          log2.trace("Retrieved defaultNamingContext (%s) from RootDSE at %s.", result.defaultNamingContext, this.opts.url);
          searchDeletedObjects("CN=Deleted Objects," + result.defaultNamingContext, localOpts);
        });
      } else {
        searchDeletedObjects(localOpts.baseDN, localOpts);
      }
    };
    ActiveDirectory.prototype.findGroup = function findGroup(opts, groupName, callback) {
      let _opts = opts || {};
      let _groupName = groupName;
      let _cb = callback;
      if (typeof groupName === "function") {
        _cb = groupName;
        _groupName = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _groupName = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      _opts.filter = _opts.filter ? _opts.filter : utils.getGroupQueryFilter(_groupName);
      log2.trace("findGroup(%j,%s)", _opts, _groupName);
      const finder = require_findGroups()(this, log2);
      finder(_opts, (err, groups) => {
        if (err) {
          return _cb(err);
        }
        if (groups && groups.length > 0) {
          return _cb(null, groups[0]);
        }
        return _cb();
      });
    };
    ActiveDirectory.prototype.findGroups = function findGroup(opts, callback) {
      const finder = require_findGroups()(this, log2);
      return finder(opts, callback);
    };
    ActiveDirectory.prototype.findUser = function findUser(opts, username, includeMembership, callback) {
      let _opts = opts || {};
      let _username = username;
      let _inclMembership = includeMembership;
      let _cb = callback;
      if (typeof includeMembership === "function") {
        _cb = includeMembership;
        _inclMembership = null;
      }
      if (typeof username === "function") {
        _cb = username;
        _username = opts;
        _opts = {};
      }
      if (typeof username === "boolean") {
        _inclMembership = username;
        _username = opts;
        _opts = {};
      }
      if (typeof opts === "string") {
        _username = opts;
        _opts = {};
      }
      _opts = merge({}, _opts);
      _opts.filter = _opts.filter ? _opts.filter : utils.getUserQueryFilter(_username);
      log2.trace("findUser(%j,%s,%s)", _opts, _username, _inclMembership);
      const finder = require_findUsers()(this, log2);
      let isErrInvoked = false;
      return finder(_opts, _inclMembership, (err, users) => {
        if (err && !isErrInvoked) {
          isErrInvoked = true;
          return _cb(err);
        }
        if (users && users.length > 0) {
          return _cb(null, users[0]);
        }
        return _cb();
      });
    };
    ActiveDirectory.prototype.findUsers = function findUsers(opts, includeMembership, callback) {
      const finder = require_findUsers()(this, log2);
      return finder(opts, includeMembership, callback);
    };
    ActiveDirectory.prototype.authenticate = function authenticate(username, password, callback) {
      log2.trace("authenticate(%j,%s)", username, isPasswordLoggingEnabled ? password : "********");
      if (!username || !password) {
        const err = {
          code: 49,
          errno: "LDAP_INVALID_CREDENTIALS",
          description: "The supplied credential is invalid"
        };
        return callback(err, false);
      }
      const client = utils.createClient(null, null, this);
      let callbackInvoked = false;
      function invokeCallback2(err, result) {
        if (callbackInvoked)
          return;
        callbackInvoked = true;
        callback(err, result);
      }
      client.on("connectTimeout", (err) => {
        this.emit("error", err);
        return invokeCallback2(err, false);
      });
      client.on("error", (err) => {
        this.emit("error", err);
        return invokeCallback2(err, false);
      });
      client.bind(username, password, (err) => {
        client.unbind();
        const message = util.format(
          'Authentication %s for "%s" as "%s" (password: "%s")',
          err ? "failed" : "succeeded",
          this.opts.url,
          username,
          isPasswordLoggingEnabled ? password : "********"
        );
        if (err) {
          log2.trace("%s. Error: %s", message, err);
          this.emit("error", err);
          return invokeCallback2(err, false);
        }
        log2.trace(message);
        return invokeCallback2(err, true);
      });
    };
    ActiveDirectory.prototype.getRootDSE = function getRootDSE(url, attributes, callback) {
      let _url = url;
      let _attributes = attributes;
      let _cb = callback;
      if (typeof url !== "string" && this instanceof ActiveDirectory) {
        _url = this.url || this.opts.url;
        _cb = url;
      }
      if (typeof attributes === "function") {
        _attributes = null;
        _cb = attributes;
      }
      _attributes = _attributes || ["*"];
      if (!url) {
        throw new Error("Must specify an URL in the form: ldap://example.com:389");
      }
      log2.trace("getRootDSE(%s,%j)", _url, _attributes);
      const client = utils.createClient.call(this, _url, this);
      client.on("error", (err) => {
        if (err.errno !== "ECONNRESET") {
          log2.trace("A connection error occured searching for root DSE at %s. Error: %s", _url, err);
          this.emit("error", err);
        }
      });
      client.bind("", "", function(err) {
        if (err) {
          log2.trace('Anonymous bind to "%s" failed. Error: %s', url, err);
          return _cb(err);
        }
        client.search("", { scope: "base", attributes: _attributes, filter: "(objectClass=*)" }, function(err2, result) {
          if (err2) {
            log2.trace('Root DSE search failed for "%s". Error: %s', url, err2);
            return _cb(err2);
          }
          result.on("end", function() {
            client.unbind();
          });
          result.on("searchEntry", function(entry) {
            const obj = entry.object;
            delete obj.controls;
            _cb(null, obj);
          });
        });
      });
    };
    ActiveDirectory.getRootDSE = function staticGetRootDSE(url, attributes, cb) {
      if (typeof url !== "string") {
        throw new Error("Must specify an URL in the form: ldap://example.com:389");
      }
      if (typeof attributes === "function") {
        return ActiveDirectory.prototype.getRootDSE(url, null, attributes);
      }
      return ActiveDirectory.prototype.getRootDSE(url, attributes, cb);
    };
    ActiveDirectory.defaultAttributes = defaultAttributes;
    module.exports = ActiveDirectory;
  }
});

// node_modules/activedirectory2/lib/adpromise.js
var require_adpromise = __commonJS({
  "node_modules/activedirectory2/lib/adpromise.js"(exports, module) {
    "use strict";
    var util = require_util();
    var AD = require_activedirectory();
    function promiseWrapper(instance, method, args) {
      function promise(resolve, reject2) {
        const cb = function(err, result) {
          return err ? reject2(err) : resolve(result);
        };
        const _args = [].concat(Array.from(args), cb);
        AD.prototype[method].apply(instance, _args);
      }
      return new Promise(promise);
    }
    function PromisedAD() {
      AD.apply(this, arguments);
    }
    util.inherits(PromisedAD, AD);
    PromisedAD.prototype.authenticate = function authenticate(username, password) {
      return promiseWrapper(this, "authenticate", arguments);
    };
    PromisedAD.prototype.find = function find(opts) {
      return promiseWrapper(this, "find", arguments);
    };
    PromisedAD.prototype.findDeletedObjects = function findDeletedObjects(opts) {
      return promiseWrapper(this, "findDeletedObjects", arguments);
    };
    PromisedAD.prototype.findGroup = function findGroup(opts, groupName) {
      return promiseWrapper(this, "findGroup", arguments);
    };
    PromisedAD.prototype.findGroups = function findGroups(opts) {
      return promiseWrapper(this, "findGroups", arguments);
    };
    PromisedAD.prototype.findUser = function findUser(opts, username, includeMembership) {
      return promiseWrapper(this, "findUser", arguments);
    };
    PromisedAD.prototype.findUsers = function findUsers(opts, includeMembership) {
      return promiseWrapper(this, "findUsers", arguments);
    };
    PromisedAD.prototype.getDistinguishedNames = function gdn(opts, filter2) {
      return promiseWrapper(this, "getDistinguishedNames", arguments);
    };
    PromisedAD.prototype.getGroupDistinguishedName = function ggdn(opts, groupName) {
      return promiseWrapper(this, "getGroupDistinguishedName", arguments);
    };
    PromisedAD.prototype.getGroupMembershipForDN = function ggmfd(opts, dn) {
      return promiseWrapper(this, "getGroupMembershipForDN", arguments);
    };
    PromisedAD.prototype.getGroupMembershipForGroup = function ggmfg(opts, groupName) {
      return promiseWrapper(this, "getGroupMembershipForGroup", arguments);
    };
    PromisedAD.prototype.getGroupMembershipForUser = function ggmfu(opts, username) {
      return promiseWrapper(this, "getGroupMembershipForUser", arguments);
    };
    PromisedAD.prototype.getRootDSE = function getRootDSE(url, attributes) {
      return promiseWrapper(this, "getRootDSE", arguments);
    };
    PromisedAD.getRootDSE = function staticGetRootDSE(url, attributes) {
      function promise(resolve, reject2) {
        const args = [url, attributes];
        args.push((err, result) => {
          return err ? reject2(err) : resolve(result);
        });
        return AD.getRootDSE.apply(PromisedAD.prototype, args);
      }
      return new Promise(promise);
    };
    PromisedAD.prototype.getUserDistinguishedName = function gudn(opts, username) {
      return AD.prototype.getUserDistinguishedName.apply(this, arguments);
    };
    PromisedAD.prototype.getUsersForGroup = function getUsersForGroup(opts, groupName) {
      return promiseWrapper(this, "getUsersForGroup", arguments);
    };
    PromisedAD.prototype.groupExists = function groupExists(opts, groupName) {
      return promiseWrapper(this, "groupExists", arguments);
    };
    PromisedAD.prototype.isUserMemberOf = function isUserMemberOf(opts, username, groupName) {
      return promiseWrapper(this, "isUserMemberOf", arguments);
    };
    PromisedAD.prototype.userExists = function userExists(opts, username) {
      return promiseWrapper(this, "userExists", arguments);
    };
    module.exports = PromisedAD;
  }
});

// node_modules/activedirectory2/index.js
var require_activedirectory2 = __commonJS({
  "node_modules/activedirectory2/index.js"(exports, module) {
    module.exports = require_activedirectory();
    module.exports.promiseWrapper = require_adpromise();
  }
});
export default require_activedirectory2();
//# sourceMappingURL=activedirectory2.js.map
